-- MySQL dump 10.13  Distrib 8.0.21, for Win64 (x86_64)
--
-- Host: 120.26.218.121    Database: moyublog
-- ------------------------------------------------------
-- Server version	5.7.37

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `t_blog`
--

DROP TABLE IF EXISTS `t_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `hits` int(10) unsigned DEFAULT '0',
  `date` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `description` text,
  `content` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=54 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog`
--

LOCK TABLES `t_blog` WRITE;
/*!40000 ALTER TABLE `t_blog` DISABLE KEYS */;
INSERT INTO `t_blog` VALUES (1,'01背包问题',41,'2021-12-16 12:27:36','这个01背包就是逊啦','## 题目\n题目在[acwing](https://www.acwing.com/problem/content/2/)\n![0-1-bei-bao-wen-ti-1](http://cdn.moyusoldier.cn/0-1-bei-bao-wen-ti-1.png)\n\n## 讲解视频\n讲解在[bilibili](https://www.bilibili.com/video/BV1qt411Z7nE?t=1718)\n## 解法-二维DP\n\n\n![0-1-bei-bao-wen-ti-2](http://cdn.moyusoldier.cn/0-1-bei-bao-wen-ti-2.png)\ndp[i][j]表示前i件物品，容量为j时的最大价值，即重叠子问题。\n\n状态转移方程：\n\n1.不放第i件物品，转化为\"前i-1件物品与容量为j\"的情况，这时候最大价值不会变化。\n\n2.放第i件物品，只有背包的体积比该物品体积大时，才考虑这种情况。这时候的最大价值应该为\"前i-1件物品，容量为j-v[i]\"的情况加上第i件物品的价值。\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1010;\nint n,m;\nint f[N][N];\nint v[N], w[N];\n\nint main(void)\n{\n   cin >> n >> m;\n   for (int i = 1;i <= n;i++)\n   {\n      cin >> v[i] >> w[i];\n   }\n   for (int i = 1;i <= n;i++)\n   {\n      for (int j = 0;j <= m;j++)\n      {\n         f[i][j] = f[i - 1][j];\n      //只有背包的体积比该物品体积大时，才考虑放入该物品的情况\n         if (j>=v[i])\n         {\n            f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);\n         }\n      }\n   }\n   int res = 0;\n   for (int i = 0;i <= m;i++)\n   {\n      res = max(res, f[n][i]);\n   }\n   cout << res << endl;\n   return 0;\n}\n```\n\n## 解法升级-一维DP\n为什么可以压缩空间?考虑到我们遍历二维数组的方式为逐行遍历，且下一行的数据之和上一行的有关，我们只保留一行的数据，然后依旧通过外层循环不断对这一行数据进行刷新。对应到数组上即删除数组的一维。\n\n根据之前的状态转移方程我们可以看出，要确定当前状态我们要已知它正上面的那个数据和左上方的某个数据，进而在刷新一行数据的时候，从后往前遍历不会导致每个位置的刷新读到错误数据（刚刚刷新的数据），而确保了每个位置的刷新读到的都是上一行的数据。\n\n所以，空间复杂度由O(NV)变为O(V)，即只与背包的体积有关。\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1010;\nint n, m;\nint f[N];\nint v[N], w[N];\n\nint main(void)\n{\n   cin >> n >> m;\n   for (int i = 1;i <= n;i++)\n   {\n      cin >> v[i] >> w[i];\n   }\n   for (int i = 1;i <= n;i++)\n   {\n      for (int j = m;j >= v[i];j--)\n      {\n         f[j] = max(f[j], f[j - v[i]] + w[i]);\n      }\n   }\n   cout << f[m] << endl;\n   return 0;\n}\n```\n\n\n\n## 写在后面\n01背包问题是一个NP完全问题，也就是说，如果你发现了该问题的一个多项式算法，那么恭喜你证明出了 P=NP，可以期待一下图灵奖了。\n\n正因如此，我们不应期望该问题有多项式时间复杂度的解法,而必须尝试非多项式时间复杂度的算法，例如时间复杂度与元素大小相关的动态规划。\n\n考虑上述动态规划算法的时间复杂度，根据二维数组有N*V个状态，其中N为物品的数量，V为背包的体积，状态之间转移时间复杂度O(1)，故可以得出该算法的时间复杂度为O(NV)。至于问什么说这不是多项式时间，为了分析方便，我们把时间复杂度写作O(nC)，其中C表示背包的体积，这下就可看出来时间复杂度不是输入数据规模的多项式函数，因为当输入数据大小相同时，只需改变C的值就可以改变时间复杂度。'),(12,'从yolo开始的目标检测入门',7,'2021-12-14 14:03:03','肆式青春中一次拉跨的yolo尝试','## 目标检测的两大流派\n\n- two-stage：以R-CNN系为代表，R-CNN，Fast R-CNN，Faster R-CNN， 准确率更高。\n\n  - stage1:生成候选区域RP\n  - stage2:对RP进行检测，分类和边框调整\n\n- one-stage：以Yolo系，SSD系为代表，速度更快。\n\n  - 没有stage1，对整张图进行检测\n  \n  ![img](http://cdn.moyusoldier.cn/yolo-00.png)\n  \n  【注】two-stage 准确率更高，one-stage速度更快仅较大体而言，采用不同的特征提取模型（backbone）、输入分辨率，特征图尺寸，候选框的个数(锚框的个数)等对模型精度和速度均有影响。\n\n![img](http://cdn.moyusoldier.cn/yolo-01.jpg)\n\n## Yolov1初探\n\n### 1.预测阶段\n\n​	假定模型已经训练完成，现在只考虑网络的前向传播过程，输入一张彩色图片，怎样才能得到目标检测的结果呢？\n\n![yolo-03](http://cdn.moyusoldier.cn/yolo-03.png)\n\n\n\n​	首先将输入的彩色图片resize成448x448x3的张量用于输入，在经历一系列操作（视作黑箱）之后，生成7x7x30的张量，这个张量包含了所有预测框的坐标，置信度和类别结果。只需解析此张量即可得到最终目标检测的结果。\n\n​	![yolo-04](http://cdn.moyusoldier.cn/yolo-04.png)\n\n7x7x30的张量该如何解析呢？\n\n​	【左图】将图片划分为SxS(S=7)维的grid cell，每个grid cell 生成B(B=2)个bounding box，每个bounding box的中心点落在该grid cell内，总计生成了7x7x2=98个bounding box，每个bounding box都包含4个位置参数和1个置信度参数。\n\n\n\n​	![yolo-05](http://cdn.moyusoldier.cn/yolo-05.png)\n\n​	【上图】将所有的bounding box都可视化的结果就是上图，黑框边框的粗细程度表示置信度的大小。\n\n​	【下图】每个grid cell 还可以生成20个类别（PASCAL VOC 数据集的20个类别）的条件概率，即在该bounding box包含物体的情况下，物体是某一个类别的概率，每个grid cell 生成的两个bounding box共享这一份概率。\n\n​	一个bounding box预测得到物体的全概率=该bounding box包含物体的概率（置信度） x 物体是某一类别的条件概率。![yolo-07](http://cdn.moyusoldier.cn/yolo-07.png)\n\n​	将每个grid cell概率最大的类别可视化的结果就是下图。\n\n​	【右图】结合上图与右图，将bounding box进行筛选即可得到最后的结果。\n\n![yolo-06](http://cdn.moyusoldier.cn/yolo-06.png)\n\n​	\n\n​	7x7x30的张量可视化结果如上图，将这个张量看作有7x7个门的抽屉，每一个抽屉门代表一个grid cell，将抽屉门拉开，可以看到该grid cell包含的30个信息，前五个信息代表第一个bounding box的五元组，挨着的是第二个bounding box的五元组，最后是20个类别的条件概率。\n\n​	\n\n### 2.预测阶段后处理\n\n​	将生成的7x7x2=98个bounding box筛选，把低置信度的bounding box过滤，重复的bounding box只保留一个，最终获得目标检测的结果。\n\n​	![yolo-08](http://cdn.moyusoldier.cn/yolo-08.png)\n\n​	对于7x7x2=98个bounding box对应的全概率按如下步骤进行操作（以第一个类别为例）\n\n 1. 设置阈值，将低于阈值的概率归零\n\n 2. 从大到小排序\n\n 3. NMS-非极大值抑制\n\n    ![yolo-09](http://cdn.moyusoldier.cn/yolo-09.png)\n\n\n\n​		首先以第一个为基准，比较第一个与第二个bounding box对应狗的概率，如果IOU大于某个阈值，认为这两个bounding box识别的是同一个物体，属于重复识别，将低概率的bounding box去掉，即将第二个概率归零。依次比较第一个到最后一个。\n\n​		在以下一个不为0的为基准，重复上述过程，得到如下图结果。\n\n![yolo-10](http://cdn.moyusoldier.cn/yolo-10.png)\n\n​		对20个类别进行20次非极大值抑制，选出不全为零的bounding box，将其对应的类别与概率标注出来，即得到最终结果。\n\n### 3.训练阶段'),(13,'Java多线程',33,'2021-12-15 22:18:43','《找个好班上》系列笔记开山之作','# 1.线程简介\n\n## 1.1进程与线程区别？\n\n定义：进程是资源分配的基本单位，线程是独立调度的基本单位。\n\n包含关系：一个进程中可以有多个线程，它们共享进程资源。\n\n区别：\n\nⅠ 拥有资源\n\n进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。\n\nⅡ 调度\n\n线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n\nⅢ 系统开销\n\n由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。\n\nⅣ 通信方面\n\n线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC（进程间通信机制）。\n\n## 1.2理解多线程\n\n![img](http://cdn.moyusoldier.cn/duoxiancheng-01.png)\n\n- 线程就是独立的执行路径\n- 在程序运行时，即使没有自己创建线程，后台也会有多个线程，比如主线程，GC线程\n- main()称之为主线程，为系统的入口，用于执行整个程序\n- 在一个进程中，如果开辟了多个线程，线程的运行是由调度器（cpu）安排调度的，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的\n- 对同一份资源操作时会存在资源抢夺的问题，需要加入并发控制\n- 线程会带来额外的开销，如CPU调度时间，并发控制开销\n- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致\n  \n\n\n\n# 2.线程实现\n\n## 2.1常用的使用线程的方法\n\n- 继承Thread类\n- 实现Runnable接口\n- 使用线程池例如Executor框架\n  - newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则创建线程。\n  - newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n  - newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n  - newSingleThreadPool 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。\n\n```Java\nclass MyThread1 extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"MyThread1\");\n    }\n}\n\nclass MyThread2 implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"MyThread2\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        //start()方法->就绪状态\n        //run()方法->运行状态\n        MyThread1 myThread1 = new MyThread1();\n        myThread1.start();\n        MyThread2 myThread2 = new MyThread2();\n        new Thread(myThread2).start();\n    }\n}\n```\n\n```shell\nMyThread1\nMyThread2\n```\n\n```java\nclass MyThread2 implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"正在执行\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        //创建一个可重用固定线程数的线程池\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        //创建线程\n        MyThread2 myThread2 = new MyThread2();\n        Thread t1 = new Thread(myThread2);\n        Thread t2 = new Thread(myThread2);\n        Thread t3 = new Thread(myThread2);\n        Thread t4 = new Thread(myThread2);\n        Thread t5 = new Thread(myThread2);\n        //将线程放入池中执行\n        pool.execute(t1);\n        pool.execute(t2);\n        pool.execute(t3);\n        pool.execute(t4);\n        pool.execute(t5);\n        //关闭线程池\n        pool.shutdown();\n    }\n}\n```\n\n```java\npool-1-thread-2正在执行\npool-1-thread-1正在执行\npool-1-thread-2正在执行\npool-1-thread-1正在执行\npool-1-thread-2正在执行\n```\n\n> 扩展：Lambda表达式\n\n目的：为了让代码变得简洁\n\n演化：\n\n - 类： 有些类只用了一次\n - 静态内部类：把一个类定义在另一个类内部，进一步简化\n - 局部内部类：把一个类定义在方法内部，进一步简化\n - 匿名内部类：没有类的名称，借助接口或者父类实现，进一步简化\n - Lambda表达式： 没有接口名，没有方法名，简化到家了\n\n使用场景：函数式接口（任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口，如Runnable）\n\n```Java	\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n使用Lambda表达式创建线程\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        new Thread(()->{\n            System.out.println(Thread.currentThread().getName()+\"正在执行\");\n        }).start();\n    }\n}\n```\n\n```shell\nThread-0正在执行\n```\n\n\n\n## 2.2\"继承 Thread类\"VS\"实现Runnable接口\"\n\n### 2.2.1最佳实践：实现Runnable接口\n\n- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\n- 类可能只要求可执行就行，继承整个 Thread 类开销过大。\n\n### 2.2.2内在联系：静态代理模式\n\n对比JDK实现\n\n```Java\n//抽象接口\npublic interface Runnable {\n    public abstract void run();\n}\n//代理角色\nclass Thread implements Runnable {\n    private Runnable target;\n    public Thread() {\n        init(null, null, \"Thread-\" + nextThreadNum(), 0);\n    }\n    public Thread(Runnable target) {\n        init(null, target, \"Thread-\" + nextThreadNum(), 0);\n    }\n    public synchronized void start() {\n        //...\n    }\n    @Override\n    public void run() {\n        if (target != null) {\n            target.run();\n        }\n    }\n    //...\n}\n```\n\n# 3.线程状态\n\n## 3.1操作系统层面：5种\n\n\n## 3.2Java线程层面：6种\n\n- NEW - 创建\n- RUNNABLE - 就绪/执行\n- BLOCKED - 阻塞\n- WAITING - 阻塞\n- TIMED_WAITING - 阻塞\n- TERMINATED - 终止\n\n![duoxiancheng-03](http://cdn.moyusoldier.cn/duoxiancheng-03.png)\n\n## 3.3Thread类方法\n\n- ### 线程停止\n\n  - 不推荐使用JDK提供的stop()、destroy()方法\n  - 推荐设置标志位让线程自己停下来\n  \n  ```Java\n  class MyThread2 implements Runnable {\n      private boolean flag = true;\n      @Override\n      public void run() {\n          while(flag){\n           //...   \n          }\n      }\n      public void stop(){\n          this.flag = false;\n      }\n  }\n  ```\n  \n- ### 线程休眠 sleep()\n\n  - Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。\n\n  - sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n  - 用于模拟网络延迟，放大问题的发生性\n\n  ```Java\n  public void run() {\n      try {\n          Thread.sleep(3000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n  }\n  ```\n  \n- ### 线程礼让 yield()\n\n  - 让当前正在执行的线程暂停，但不阻塞\n\n  - 将线程从运行状态转为就绪状态\n\n  - 让CPU重新调度，礼让不一定成功，看CPU心情\n  \n  ```java\n  public void run() {\n      Thread.yield();\n  }\n  ```\n  \n- ### 线程插队 join()\n\n  - 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\n  - 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。\n\n  ```java\n  public class JoinExample {\n  \n      private class A extends Thread {\n          @Override\n          public void run() {\n              System.out.println(\"A\");\n          }\n      }\n  \n      private class B extends Thread {\n  \n          private A a;\n  \n          B(A a) {\n              this.a = a;\n          }\n  \n          @Override\n          public void run() {\n              try {\n                  a.join();\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              System.out.println(\"B\");\n          }\n      }\n  \n      public void test() {\n          A a = new A();\n          B b = new B(a);\n          b.start();\n          a.start();\n      }\n  }\n  ```\n\n  \n\n  \n\n  ```java\n  public static void main(String[] args) {\n    JoinExample example = new JoinExample();\n    example.test();\n  }\n  ```\n\n  \n\n  \n\n  ```shell\n  A\n  B\n  ```\n\n- ### 线程状态观测 getState()\n\n  ```java\n  Thread.State state = thread.getState();\n  ```\n\n- ### 线程优先级 getPriority()，setPriority(int)\n\n  - 范围从1~10，数字越大，优先级越高\n  - 优先级低只是意味着获得调度的概率低，并不是不会被调度，取决于CPU\n  - Thread.MIN_PRIORITY = 1;\n  - Thread.MAX_PRIORITY = 10;\n  - Thread.NORM_PRIORITY = 5;\n\n  \n  ```Java\n  //先设置优先级，再启动\n  thread.setPriority(1);\n  thread.start();\n  ```\n  \n- ### 守护线程 setDaemon(boolean)\n\n  - 线程分为用户线程和守护线程\n  - JVM必须确保用户线程执行完毕\n  - JVM不用等待守护线程执行完毕（如垃圾回收线程）\n\n  ```Java\n  //默认false表示是用户线程,正常的线程都是用户线程\n  thread.setDaemon(true);\n  ```\n\n  \n\n# 4.线程同步\n\n## 4.1并发与并行\n\n并发：一个处理器按时间片轮转算法处理多个任务\n\n并行：单位时间多个处理器同时处理多个任务\n\n并发问题的起因：同一个对象被多个线程同时操作\n\n## 4.2线程不安全的例子\n\n- 买火车票\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        BuyTickets buyTickets = new BuyTickets();\n        new Thread(buyTickets, \"a\").start();\n        new Thread(buyTickets, \"b\").start();\n        new Thread(buyTickets, \"c\").start();\n    }\n}\n\nclass BuyTickets implements Runnable {\n    //票\n    private int num = 10;\n\n    @Override\n    public void run() {\n        while (true) {\n            if (num <= 0) {\n                break;\n            }\n            //模拟网络延迟，放大问题的发生性\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"抢到了第\" + num-- + \"张票\");\n        }\n    }\n}\n```\n\n```shell\na抢到了第10张票\nb抢到了第8张票\nc抢到了第9张票\na抢到了第7张票\nb抢到了第6张票\nc抢到了第6张票\na抢到了第5张票\nc抢到了第4张票\nb抢到了第3张票\na抢到了第2张票\nb抢到了第1张票\nc抢到了第1张票\na抢到了第0张票\n```\n\n- 线程不安全的集合\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<String>();\n        for (int i = 0; i < 1000; i++) {\n            new Thread(()->{\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n        //延迟，保证所有线程跑完\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n```shell\n995\n```\n\n## 4.3互斥同步\n\nJava 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的ReentrantLock。\n\n### 4.3.1 Synchronized用法（结合八锁现象理解）\n\n- Synchronized修饰实例方法\n  - 作用范围是整个方法，锁的是方法的调用者，是一个资源类的对象实例this（可以有多个）\n  - 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步\n\n```java\npublic synchronized void func () {\n    // ...\n}\n```\n\n- Synchronized修饰代码块\n\n  - 作用范围是大括号括起来的代码块，锁的是方法的调用者，是一个资源类的对象实例this\n  - 被修饰的代码块称为同步语句块\n\n  - 和修饰实例方法一样，都作用于同一个对象\n\n```Java\npublic void func() {\n    synchronized (this) {\n        // ...\n    }\n}\n```\n\n- Synchronized修饰静态方法\n\n  - 作用范围是整个方法，锁的是这个资源类的Class类模板\n\n  - 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步\n\n```java\npublic synchronized static void fun() {\n    // ...\n}\n```\n\n- Synchronized修饰类\n  - 作用范围是大括号括起来的代码块，锁的是这个资源类的Class类模板（只有唯一一个）\n\n```java\npublic void func() {\n    synchronized (SynchronizedExample.class) {\n        // ...\n    }\n}\n```\n\n### 4.3.2理解Synchronized\n\n- 加锁this，创建一个实例\n\n对于以下代码，创建线程池，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。\n\n```java\npublic class SynchronizedExample {\n\n    public void func1() {\n        synchronized (this) {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n}\n```\n\n```Java\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func1());\n    executorService.execute(() -> e1.func1());\n}\n```\n\n```shell\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n```\n\n- 加锁this，创建多个实例\n\n对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。\n\n```java\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    SynchronizedExample e2 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func1());\n    executorService.execute(() -> e2.func1());\n}\n```\n\n```shell\n0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9\n```\n\n- 加锁class，创建多个实例\n\n```java\npublic class SynchronizedExample {\n\n    public void func2() {\n        synchronized (SynchronizedExample.class) {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n}\n```\n\n```java\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    SynchronizedExample e2 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func2());\n    executorService.execute(() -> e2.func2());\n}\n```\n\n```shell\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n```\n\n### 4.3.3ReentrantLock\n\nReentrantLock 是 java.util.concurrent（J.U.C）包中的锁\n\n```java\npublic class LockExample {\n\n    private Lock lock = new ReentrantLock();\n\n    public void func() {\n        lock.lock();\n        try {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + \" \");\n            }\n        } finally {\n            lock.unlock(); // 确保释放锁，从而避免发生死锁。\n        }\n    }\n}\n```\n\n```Java\npublic static void main(String[] args) {\n    LockExample lockExample = new LockExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> lockExample.func());\n    executorService.execute(() -> lockExample.func());\n}\n```\n\n```shell\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n```\n\n### 4.3.4Synchronized VS ReentrantLock\n\n**1. 锁的实现**\n\nsynchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n\n**2. 性能**\n\n新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。\n\n**3. 等待可中断**\n\n当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。\n\nReentrantLock 可中断，而 synchronized 不行。\n\n**4. 公平锁**\n\n公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。\n\nsynchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。\n\n**5. 锁绑定多个条件**\n\n一个 ReentrantLock 可以同时绑定多个 Condition 对象。\n\n**使用选择**\n\n除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n\n## 4.4 修改线程不安全的例子\n\n- 修改 买火车票\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        BuyTickets buyTickets = new BuyTickets();\n        new Thread(buyTickets, \"a\").start();\n        new Thread(buyTickets, \"b\").start();\n        new Thread(buyTickets, \"c\").start();\n    }\n}\n\nclass BuyTickets implements Runnable {\n    //票\n    private int num = 10;\n\n    @Override\n    public synchronized void run() {\n        while (true) {\n            if (num <= 0) {\n                break;\n            }\n            //模拟网络延迟，放大问题的发生性\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"抢到了第\" + num-- + \"张票\");\n        }\n    }\n}\n```\n\n- 修改 线程不安全集合\n\n```java\n//测试JUC安全类型的集合\npublic class Test {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>();\n        for (int i = 0; i < 10000; i++) {\n            new Thread(() -> {\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n# 5.线程通信 \n\n## 5.1三个线程打印ABC问题\n\n- Synchronized版本\n\n```java\npublic class WaitNotifyABC {\n    private int num;\n    private static final Object LOCK = new Object();\n\n    private void printABC(String name, int targetNum) {\n        for (int i = 0; i < 20; i++) {\n            synchronized (LOCK) {\n                while (num % 3 != targetNum) {\n                    try {\n                        LOCK.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                num++;\n                System.out.println(name);\n                LOCK.notifyAll();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        WaitNotifyABC waitNotifyABC = new WaitNotifyABC();\n        new Thread(() -> waitNotifyABC.printABC(\"A\", 0)).start();\n        new Thread(() -> waitNotifyABC.printABC(\"B\", 1)).start();\n        new Thread(() -> waitNotifyABC.printABC(\"C\", 2)).start();\n    }\n}\n```\n\n- Lock版本\n\n```java\npublic class WaitNotifyABC {\n    private int num;\n    private Lock lock = new ReentrantLock();\n\n    private void printABC(String name, int targetNum) {\n        for (int i = 0; i < 20;) {\n            lock.lock();\n                if (num % 3 == targetNum) {\n                    num++;\n                    i++;\n                    System.out.println(name);\n                }\n                lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        WaitNotifyABC waitNotifyABC = new WaitNotifyABC();\n        new Thread(() -> waitNotifyABC.printABC(\"A\", 0)).start();\n        new Thread(() -> waitNotifyABC.printABC(\"B\", 1)).start();\n        new Thread(() -> waitNotifyABC.printABC(\"C\", 2)).start();\n    }\n}\n```\n\n\n\n# 6.volatile\n\n## 6.1 JMM\n\n![duoxiancheng-05](http://cdn.moyusoldier.cn/duoxiancheng-05.png)\n\n线程对共享变量的操作只能在本地内存区进行，不能直接在主内存区中操作共享变量。\n\n## 6.2 volatile特性\n\n轻量级 synchronized\n\n> 并发三大特性为可见性、有序性、原子性。volatile保证可见性和有序性，不保证原子性\n\n- 保证可见性：volatile可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值。\n\n```java\npublic class Demo01 {\n\n    // 如果不加volatile 程序会死循环\n    // 加了volatile是可以保证可见性的\n    private volatile static Integer number = 0;\n\n    public static void main(String[] args) {\n        \n        //子线程\n        new Thread(()->{\n            while (number==0){//若不加volatile，循环不会退出\n            }\n        }).start();\n        \n        //延时，保证子线程启动\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        //main线程修改number的值\n        number=1;\n        System.out.println(number);\n    }\n}\n```\n\n- 保证有序性：volatile会通过禁止指令重排来保证有序性\n\n  - 指令重排：你写的程序，计算机并不是按照你写的那样去执行的，源代码->编译器优化重拍->指令并行重排->内存系统重排->执行\n\n  - 原理：内存屏障，CPU执行过程中，在volatile语句前后加屏障，在单例模式里使用的最多\n\n- 不保证原子性：对于单个volatile修饰的变量可以保证原子性，但对于i++这种符合操作不能保证原子性\n\n```java\npublic class Demo02 {\n\n    private static volatile int number = 0;\n\n    public static void add(){\n        number++; \n        //++ 不是一个原子性操作，是两个~3个操作\n    }\n\n    public static void main(String[] args) {\n        //理论上number  === 20000\n\n        for (int i = 1; i <= 20; i++) {\n            new Thread(()->{\n                for (int j = 1; j <= 1000 ; j++) {\n                    add();\n                }\n            }).start();\n        }\n\n        while (Thread.activeCount()>2){\n            //main  gc\n            Thread.yield();\n        }\n        System.out.println(Thread.currentThread().getName()+\",num=\"+number);\n    }\n}\n```\n\n```shell\nmain,num=19973\n```\n\n反编译，通过字节码查看number++这行语句的执行过程\n\n```shell\n> javap -c Demo02\n```\n\n```java\n  public static void add();\n    Code:\n       0: getstatic     #2                  // Field number:I\n       3: iconst_1\n       4: iadd\n       5: putstatic     #2                  // Field number:I\n       8: return\n```\n\n如果不加lock和synchronized ，怎么样保证原子性？\n\n——使用原子类\n\n```java\npublic class Demo02 {\n\n    private static volatile AtomicInteger number = new AtomicInteger();\n\n    public static void add(){\n        number.getAndIncrement();\n        //++ 不是一个原子性操作，是两个~3个操作\n    }\n\n    public static void main(String[] args) {\n        //理论上number  === 20000\n\n        for (int i = 1; i <= 20; i++) {\n            new Thread(()->{\n                for (int j = 1; j <= 1000 ; j++) {\n                    add();\n                }\n            }).start();\n        }\n\n        while (Thread.activeCount()>2){\n            //main  gc\n            Thread.yield();\n        }\n        System.out.println(Thread.currentThread().getName()+\",num=\"+number);\n    }\n}\n```\n\n```shell\nmain,num=20000\n```'),(14,'小记代理模式',4,'2021-12-14 14:03:10','啊 可能我未来几年都不会接触到AOP了，记录一下','## 1. 静态代理模式\n\n### 1.1介绍\n\n![](http://cdn.moyusoldier.cn/duoxiancheng-02.png)\n\n四个角色：\n\n- 抽象角色：一般使用接口/抽象类\n- 真实角色：被代理的角色\n- 代理角色：代理真实角色，并做出附属动作\n- 客户：使用代理角色进行操作\n\n### 1.2例子\n\n```Java\n/**\n * 静态代理:结婚案例\n */\npublic class StaticProxy {\n    public static void main(String[] args) {\n        new WeddingCompany(new You()).happyMarry();\n    }\n}\n\n//AbstractSubject抽象接口:结婚\ninterface Marry {\n    void happyMarry();\n}\n\n//RealSubject真实角色:你去结婚\nclass You implements Marry {\n    @Override\n    public void happyMarry() {\n        System.out.println(\"要结婚了,超开心\");\n    }\n}\n\n//Proxy代理角色:婚庆公司帮你结婚\nclass WeddingCompany implements Marry {\n    private Marry target;//代理-->真实角色,帮谁结婚\n\n    public WeddingCompany(Marry target) {\n        this.target = target;\n    }\n\n    @Override\n    public void happyMarry() {\n        before();\n        this.target.happyMarry();\n        after();\n    }\n\n    private void after() {\n        System.out.println(\"log-after\");\n    }\n\n    private void before() {\n        System.out.println(\"log-before\");\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\n```\n\n好老铁也要结婚，如何编写？\n\n```java\nclass He implements Marry {\n    @Override\n    public void happyMarry() {\n        System.out.println(\"好老铁要结婚啦，超开心\");\n    }\n}\n```\n\n\n\n```jade\npublic class StaticProxy {\n    public static void main(String[] args) {\n        new WeddingCompany(new You()).happyMarry();\n        new WeddingCompany(new He()).happyMarry();\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\nlog-before\n好老铁要结婚啦，超开心\nlog-after\n```\n\n一个接口的代理类只需编写一次，实现了该接口的真实对象都可以使用。\n\n小姐妹要租房，如何编写？\n\n```java\ninterface Rent {\n    void happyRent();\n}\n```\n\n\n\n```java\nclass She implements Rent {\n    @Override\n    public void happyRent() {\n        System.out.println(\"要租房啦\");\n    }\n}\n```\n\n\n\n```java\nclass RentCompany implements Rent {\n    private Rent target;\n\n    public RentCompany(Rent target) {\n        this.target = target;\n    }\n\n    @Override\n    public void happyRent() {\n        before();\n        this.target.happyRent();\n        after();\n    }\n\n    private void after() {\n        System.out.println(\"log-after\");\n    }\n\n    private void before() {\n        System.out.println(\"log-before\");\n    }\n}\n```\n\n\n\n```java\npublic class StaticProxy {\n    public static void main(String[] args) {\n        new WeddingCompany(new You()).happyMarry();\n        new WeddingCompany(new He()).happyMarry();\n        new RentCompany(new She()).happyRent();\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\nlog-before\n好老铁要结婚啦，超开心\nlog-after\nlog-before\n要租房啦\nlog-after\n```\n\n需再为租房接口编写一个代理类（麻烦，动态代理改进）\n\n### 1.3优缺点\n\n**优点:**\n\n- 使得我们的真实角色更加纯粹 ，不再去关注一些公共的事情 \n- 公共的业务由代理来完成 ， 实现了业务的分工 \n- 公共业务发生扩展时变得更加集中和方便 \n\n**缺点 :**\n\n- 需要为每个被代理的接口都编写一个代理类 , 工作量变大\n\n我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !\n\n## 2.反射\n\n### 2.1 初始化对象\n\n```java\npackage com.moyu;\n\npublic class Person {\n    private Integer id;\n    private String name;\n\n    public Person() {\n        System.out.println(\"执行无参构造方法\");\n    }\n\n    public Person(Integer id, String name) {\n        this.id = id;\n        this.name = name;\n        System.out.println(\"执行有参构造方法\");\n    }\n\n    public void say(String s){\n        System.out.println(s);\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"id=\" + id +\n                \", name=\'\" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n```\n\n无参构造\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class<?> aClass = Class.forName(\"com.moyu.Person\");\n        Person person = (Person) aClass.newInstance();\n        \n        System.out.println(person);\n    }\n}\n```\n\n\n\n```shell\n执行无参构造方法\nPerson{id=null, name=\'null\'}\n```\n\n有参构造\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n        Class<?> aClass = Class.forName(\"com.moyu.Person\");\n        Constructor<?> constructor = aClass.getConstructor(Integer.class, String.class);\n        Person person = (Person) constructor.newInstance(1, \"moyu\");\n        \n        System.out.println(person);\n    }\n}\n```\n\n\n\n```shell\n执行有参构造方法\nPerson{id=1, name=\'moyu\'}\n```\n\n### 2.2 给属性赋值\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        Class<?> aClass = Class.forName(\"com.moyu.Person\");\n        Person person = (Person) aClass.newInstance();\n        \n        Field id = aClass.getDeclaredField(\"id\");\n        id.setAccessible(true);\n        id.set(person,1);\n        \n        Field name = aClass.getDeclaredField(\"name\");\n        name.setAccessible(true);\n        name.set(person,\"moyu\");\n        \n        System.out.println(person);\n    }\n}\n```\n\n\n\n```shell\n执行无参构造方法\nPerson{id=1, name=\'moyu\'}\n```\n\n### 2.3 调用方法\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        Class<?> aClass = Class.forName(\"com.moyu.Person\");\n        Person person = (Person) aClass.newInstance();\n        Method say = aClass.getDeclaredMethod(\"say\", String.class);\n        say.invoke(person, \"你好\");\n    }\n}\n```\n\n\n\n```shell\n执行无参构造方法\n你好\n```\n\n## 3. 动态代理\n\n### 3.1 介绍\n\n- 动态代理的代理类是自动生成的（只写一次），静态代理的代理类是我们提前编写好的（每个接口都要写一次）\n\n- 动态代理分两类：\n\n  - 基于接口的动态代理 - JDK动态代理\n  - 基于类的动态代理 - CGLIB\n\n  常用Javassist生成动态代理\n\n### 3.2 例子（以JDK动态代理为例）\n\n```java\n//抽象接口\ninterface Marry {\n    void happyMarry();\n}\n```\n\n\n\n```java\n//真实角色\nclass You implements Marry {\n    @Override\n    public void happyMarry() {\n        System.out.println(\"要结婚了,超开心\");\n    }\n}\n```\n\n\n\n```java\n//代理角色\npublic class DynamicProxy implements InvocationHandler {\n\n    private Object object;\n\n    public DynamicProxy(Object object) {\n        this.object = object;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        before();\n        Object result = method.invoke(object, args);\n        after();\n        return result;\n    }\n\n    private void after() {\n        System.out.println(\"log-after\");\n    }\n\n    private void before() {\n        System.out.println(\"log-before\");\n    }\n}\n```\n\n\n\n```java\n//客户\npublic class Client {\n    public static void main(String[] args) {\n        //真实角色\n        You you = new You();\n\n        //代理角色\n        Marry marry = (Marry) Proxy.newProxyInstance(\n            you.getClass().getClassLoader(),\n            you.getClass().getInterfaces(),\n            new DynamicProxy(you));\n\n        marry.happyMarry();\n\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\n```\n\n好老铁也要结婚，如何编写？（这部分看不出动态代理的优点，因为是同一个接口）\n\n```java\npublic class He implements Marry{\n    @Override\n    public void happyMarry() {\n        System.out.println(\"好老铁要结婚啦，超开心\");\n    }\n}\n```\n\n\n\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //真实角色\n        You you = new You();\n        He he = new He();\n\n        //代理角色\n        Marry marry = (Marry) Proxy.newProxyInstance(you.getClass().getClassLoader(),you.getClass().getInterfaces(),new DynamicProxy(you));\n        Marry marry1 = (Marry) Proxy.newProxyInstance(he.getClass().getClassLoader(),he.getClass().getInterfaces(),new DynamicProxy(he));\n\n        marry.happyMarry();\n        marry1.happyMarry();\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\nlog-before\n好老铁要结婚啦，超开心\nlog-after\n```\n\n小姐妹要租房，如何编写？（不同的接口，体现动态代理优点，自动生成代理类）\n\n```java\npublic interface Rent {\n    void happyRent();\n}\n```\n\n\n\n```java\npublic class She implements Rent{\n    @Override\n    public void happyRent() {\n        System.out.println(\"要租房啦\");\n    }\n}\n```\n\n\n\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //真实角色\n        You you = new You();\n        He he = new He();\n        She she = new She();\n\n        //代理角色\n        Marry marry = (Marry) Proxy.newProxyInstance(you.getClass().getClassLoader(), you.getClass().getInterfaces(), new DynamicProxy(you));\n        Marry marry1 = (Marry) Proxy.newProxyInstance(he.getClass().getClassLoader(), he.getClass().getInterfaces(), new DynamicProxy(he));\n        Rent rent = (Rent) Proxy.newProxyInstance(she.getClass().getClassLoader(), she.getClass().getInterfaces(), new DynamicProxy(she));\n\n        marry.happyMarry();\n        marry1.happyMarry();\n        rent.happyRent();\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\nlog-before\n好老铁要结婚啦，超开心\nlog-after\nlog-before\n要租房啦\nlog-after\n```\n\n### 3.3 优点\n\n- 动态代理的代理类可以复用，只需编写一次，省去了重复编写代理类的麻烦\n- 不用再关心代理的对象是谁，只需要实现一套逻辑即可\n\n## 4. Spring AOP\n\n### 4.1 介绍\n\n - 全称：Aspect Oriented Program 面向切面编程。\n\n - 目的：将不同业务逻辑中共有的部分（日志管理、事务管理）封装起来，降低业务逻辑各部分之间的耦合度，提高程序的可重用性\n\n - 一些概念：\n\n    - 横切关注点：不同业务逻辑中共有的部分（日志管理、事务管理）\n\n    - 切面(Aspect)：将横切关注点抽象化为类'),(16,'jwt',37,'2021-12-18 03:40:24','JWT yyds!','![image-20211119151726683](http://cdn.moyusoldier.cn/image-20211119151726683.png)\n## 1.是什么\n\n一种开放标准，它定义了一种方式，用于在各方之间作为 JSON 对象安全地传输信息。\n\n由于此信息经过数字签名，因此可以验证和信任。JWT 可以使用秘密（使用**HMAC**算法）或使用**RSA**或**ECDSA**的公钥/私钥对进行**签名**。\n\n## 2.能做什么\n\n- **授权**：这是使用 JWT 最常见的场景。用户登录后，每个后续请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是当今广泛使用 JWT 的一项功能，因为它的开销很小，并且能够轻松跨不同域使用。\n- **信息交换**：JSON Web Tokens 是一种在各方之间安全传输信息的好方法。因为 JWT 可以被签名——例如，使用公钥/私钥对——你可以确定发件人就是他们所说的那样。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。\n\n## 3.为什么是JWT\n\n### 3.1传统的session认证方式\n\n- **流程**\n\n1. 用户向服务器发送用户名和密码。 \n2. 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。\n3. 服务器向用户返回一个 session_id，写入用户的 Cookie。\n4. 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。\n5. 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。\n\n- **缺点**\n\n1. 用户增多，session保存在内存中，服务器开销增大\n\n2. 用户下次请求必须在这台服务器上才能授权，限制分布式架构，限制session共享\n\n3. 跨站伪造请求(CSRF)攻击：\n\n   1. 用户Alice登录和访问某银行网站A，保留cookie。\n\n   2. Alice被某些信息诱导访问危险网站B。\n\n   3. 危险网站B上有一个<img>标签：\n\n      ```\n      <img src=\"http://www.examplebank.com/account=Alice&amount=1000&payfor=Badman\" >\n      ```\n\n   4. 这个标签的src不指向一张图片，而是一个http请求，这个请求向银行要求将Alice的1000元转给Badman，由于Alice的浏览器上有cookie，这样浏览器发出的这个请求就能得到响应执行。\n\n   5. 这样Alice的钱就被偷了。\n\n4. 前后端分离系统：通常用户的一次请求多次转发，经过多次代理，多次携带session_id\n\n### 3.2 JWT 认证方式\n\n- **原理**\n\nJWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。\n {\n \"姓名\": \"张三\",\n \"角色\": \"管理员\",\n \"到期时间\": \"2018年7月1日0点0分\"\n }\n 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。\n\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n\n- **认证流程**\n\n![8qwls7hxns](http://cdn.moyusoldier.cn/8qwls7hxns.png)\n\n1. Browser通过Web表单将username和password发送到Server，一般是一个http post 请求（推荐使用https，避免敏感信息被嗅探）。\n2. Server核对username和password成功后，将用户的id等其他信息作为JWT Payload，将其与头部分别进行Base64编码后签名，形成一个JWT(Token)。形成的JWT是一个形式为\"head.payload.singurater\"的字符串。\n3. Server将JWT字符串作为登陆成功结果返回给Browser，Browser可以将返回的结果保存在localStorage或sessionStorage上，退出登陆时Browser删除保存的JWT即可。\n4. Browser在每次请求时，将JWT放入Http header的Authorization位，解决XSS和XSRF问题。\n5. Server验证JWT有效性，例如检查签名是否正确，检查Token是否过期，检查Token接收方是否是自己（可选）。\n6. 验证通过后，Server使用JWT中包含的用户信息进行其它逻辑操作，返回相应结果。\n\n- **优点**\n\n1. 简洁：可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快\n2. 自包含：负载中包含了所有用户所需要的信息，避免了多次查询数据库\n3. 因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的\n4. 不需要在服务器端保存会话信息，特别适合于分布式微服务\n\n## 4. JWT结构\n\n一个字符串，形式为“xxxxx.yyyyy.zzzzz”，分为三部分：Header、Payload、Signature\n\n### 4.1标头（header)\n\n标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。\n\n例如：\n\n```\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n\n然后，这个 JSON 被**Base64Url**编码以形成 JWT 的第一部分。\n\n### 4.2载荷（payload)\n\n令牌的第二部分是负载，其中包含声明。\n\n声明是关于实体（通常是用户）和附加数据的声明。\n\n共有三种类型的声明：*注册声明*、*公共*声明和*私人*声明。\n\n- [**注册声明**]：这些是一组预定义的声明，这些声明不是强制性的，而是推荐的，以提供一组有用的、可互操作的声明。其中一些是： **iss**（发行者）、 **exp**（到期时间）、 **sub**（主题）、 **aud**（受众）等。\n\n  > 请注意，声明名称只有三个字符，因为 JWT 是紧凑的。\n\n- [**公共声明**]：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在[IANA JSON Web Token Registry]中定义，或者定义为包含抗冲突命名空间的 URI。\n\n- [**私人权利**]：这些都是使用它们同意并既不是当事人之间建立共享信息的自定义声明注册或公众的权利要求。\n\n一个示例有效载荷可能是：\n\n```\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n然后对有效负载进行**Base64Url**编码以形成 JSON Web 令牌的第二部分。\n\n> 请注意，对于已签名的令牌，此信息虽然受到防篡改保护，但任何人都可以读取。除非加密，否则不要将机密信息放入 JWT 的负载或标头元素中。(即密码不能放在JWT中！！！)\n\n### 4.3签名（signature)\n\n前两部分是使用**Base64Url**进行编码的，即任何人可以解开知道里面的信息。\n\n要创建签名部分，需要使用base64编码的header和payload、secret、header中指定的算法，对其进行签名。\n\n例如，如果要使用 HMAC SHA256 算法，则签名将通过以下方式创建：\n\n```\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```\n\n签名用于验证消息在此过程中没有更改，并且在使用私钥签名的令牌的情况下，它还可以验证 JWT 的发送者是它所说的那个人。\n\n### 4.4 放在一起\n\n输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递，同时与基于 XML 的标准（如 SAML）相比更加紧凑。\n\n![image-20211120140613842](http://cdn.moyusoldier.cn/image-20211120140613842.png)\n\n### 4.5 理解\n\n- JWT是干啥的？\n\n​	用户认证，由于http协议是无状态的，每一次请求都无状态。当一个用户通过用户名和密码登录了之后，他的下一个请求不会携带任何状态，应用程序无法知道他的身份，那就必须重新认证。因此我们希望用户登录成功之后的每一次http请求，都能够保存他的登录状态。\n\n- 为什么要Base64编码？\n\n​	编码了总比明文传输安全？由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据，带来了安全性问题。而session的信息是存在服务端的，相对来说更安全。\n\n- 为什么要Sha256编码\n\n​	header部分和payload部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的signature部分，服务端也就无法通过，在jwt中，消息体是透明的，使用签名可以保证消息不被篡改。\n\n- secret是啥？\n\n​	secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。\n\n- 服务器端如何验证的？\n\n​	Sha256加密jwt的第一部分、第二部分和secret，比较和jwt的第三部分是否相等。'),(19,'solaris环境配置与Pip&Conda包管理',64,'2021-12-19 01:01:55','记录难安装的solaris（其实多安几次就好了）','## 1.Windows环境下solaris环境配置\n\n1. 创建虚拟环境 conda create -n solaris python=3.7\n2. conda install tensorflow==1.13.1（之后在requirements.txt里安装应该也行）\n3. 下载好5个whl文件，依次 pip install pyproj(2.4.2) shapely(1.6.4) gdal(3.0.3) fiona(1.8.13) geopandas(0.6.2)\n4. conda install rasterio\n5. git clone https://github.com/cosmiq/solaris.git  修改requirements.txt 注释掉已经下载好的依赖后pip install -r requirements.txt\n6. 注释掉setup.py的GDAL检测部分（38-55行）后，pip install . 安装solaris \n\n## 2.Linux环境下solaris环境配置\n\n只需把步骤3的包全部用conda安装即可(gdal安不了3.0.3就安3.0.2，把强制检测gdal的地方注释掉)\n\n## 2.Pip&Conda包管理\n\n### 包安装路径\n\n|                   | base                                                    | solaris虚拟环境                                              |\n| ----------------- | ------------------------------------------------------- | ------------------------------------------------------------ |\n| pip/conda install | D:\\conda\\conda\\Lib\\site-packages 和 D:\\conda\\conda\\pkgs | D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages 和 D:\\conda\\conda\\pkgs |\n\n也就是说，conda会在同一个路径下备份所有由pip/conda安装的包。\n\n特例：\n\n​	使用pip install xxx.whl 安装的包，只会在D:\\conda\\conda\\Lib\\site-packages或D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages中，不会在conda路径下。\n\n### list展示路径（环境中可用的包路径）\n\n|                | base                             | solaris                                       |\n| -------------- | -------------------------------- | --------------------------------------------- |\n| pip/conda list | D:\\conda\\conda\\Lib\\site-packages | D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages |\n\n## 3.实验部分（可以不看）\n\n### base环境\n\n#### (base)pip list\n\n```\nC:\\Users\\Lenovo>pip list\nPackage                Version\n---------------------- ---------\nbrotlipy               0.7.0\ncertifi                2021.10.8\ncffi                   1.14.6\ncharset-normalizer     2.0.4\nconda                  4.10.3\nconda-package-handling 1.7.3\ncryptography           35.0.0\nidna                   3.2\nmenuinst               1.4.16\npip                    21.2.4\npycosat                0.6.3\npycparser              2.20\npyOpenSSL              21.0.0\nPySocks                1.7.1\npywin32                228\nrequests               2.26.0\nruamel-yaml-conda      0.15.100\nsetuptools             58.0.4\nsix                    1.16.0\ntqdm                   4.62.3\n```\n\npip list 路径 D:\\conda\\conda\\Lib\\site-packages\n\n> 请读者自行将D:\\conda\\conda替换成自己的Anaconda或Miniconda安装路径\n\n#### (base)conda list\n\n```\nC:\\Users\\Lenovo>conda list\n# packages in environment at D:\\conda\\conda:\n#\n# Name                    Version                   Build  Channel\nbrotlipy                  0.7.0           py37h2bbff1b_1003\nca-certificates           2021.10.26           haa95532_2\ncertifi                   2021.10.8        py37haa95532_0\ncffi                      1.14.6           py37h2bbff1b_0\ncharset-normalizer        2.0.4              pyhd3eb1b0_0\nconda                     4.10.3           py37haa95532_0\nconda-package-handling    1.7.3            py37h8cc25b3_1\nconsole_shortcut          0.1.1                         4\ncryptography              35.0.0           py37h71e12ea_0\nidna                      3.2                pyhd3eb1b0_0\nmenuinst                  1.4.16           py37he774522_0\nopenssl                   1.1.1l               h2bbff1b_0\npip                       21.2.4           py37haa95532_0\npowershell_shortcut       0.0.1                         3\npycosat                   0.6.3            py37h2bbff1b_0\npycparser                 2.20                       py_2\npyopenssl                 21.0.0             pyhd3eb1b0_1\npysocks                   1.7.1                    py37_1\npython                    3.7.6                h60c2a47_2\npywin32                   228              py37hbaba5e8_1\nrequests                  2.26.0             pyhd3eb1b0_0\nruamel_yaml               0.15.100         py37h2bbff1b_0\nsetuptools                58.0.4           py37haa95532_0\nsix                       1.16.0             pyhd3eb1b0_0\nsqlite                    3.36.0               h2bbff1b_0\ntqdm                      4.62.3             pyhd3eb1b0_1\nurllib3                   1.26.7             pyhd3eb1b0_0\nvc                        14.2                 h21ff451_1\nvs2015_runtime            14.27.29016          h5e58377_2\nwheel                     0.37.0             pyhd3eb1b0_1\nwin_inet_pton             1.1.0            py37haa95532_0\nwincertstore              0.2              py37haa95532_2\nyaml                      0.2.5                he774522_0\n```\n\nconda list 路径 D:\\conda\\conda\\Lib\\site-packages（显示的是D:\\conda\\conda ）\n\n#### 下载一个包看看（其实还下载了一堆依赖包）\n\n```\nconda install anaconda-navigator\n```\n\n```\nC:\\Users\\Lenovo>conda list anaconda-navigator\n# packages in environment at D:\\conda\\conda:\n#\n# Name                    Version                   Build  Channel\nanaconda-navigator        2.1.0            py37haa95532_0\n```\n\n```\nC:\\Users\\Lenovo>pip show anaconda-navigator\nName: anaconda-navigator\nVersion: 2.1.0\nSummary: Anaconda Navigator\nHome-page: UNKNOWN\nAuthor: Continuum Analytics\nAuthor-email:\nLicense: UNKNOWN\nLocation: d:\\conda\\conda\\lib\\site-packages\nRequires:\nRequired-by:\n```\n\nconda install 下载的包，conda（D:\\conda\\conda\\pkgs）和pip（D:\\conda\\conda\\Lib\\site-packages）下都有这个包\n\n### solaris虚拟环境\n\n#### (solaris)pip list\n\n```\n(solaris) C:\\Users\\Lenovo>pip list\nPackage      Version\n------------ ---------\ncertifi      2021.10.8\npip          21.2.4\nsetuptools   58.0.4\nwheel        0.37.0\nwincertstore 0.2\n```\n\npip list路径 D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages\n\n#### (solaris)conda list\n\n```\n(solaris) C:\\Users\\Lenovo>conda list\n# packages in environment at D:\\conda\\conda\\envs\\solaris:\n#\n# Name                    Version                   Build  Channel\nca-certificates           2021.10.26           haa95532_2\ncertifi                   2021.10.8        py37haa95532_0\nopenssl                   1.1.1l               h2bbff1b_0\npip                       21.2.4           py37haa95532_0\npython                    3.7.11               h6244533_0\nsetuptools                58.0.4           py37haa95532_0\nsqlite                    3.36.0               h2bbff1b_0\nvc                        14.2                 h21ff451_1\nvs2015_runtime            14.27.29016          h5e58377_2\nwheel                     0.37.0             pyhd3eb1b0_1\nwincertstore              0.2              py37haa95532_2\n```\n\nconda list路径D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages（显示的是D:\\conda\\conda\\envs\\solaris），和pip list路径是一样的\n\n#### 下载一个包\n\nconda install 的包，conda（D:\\conda\\conda\\pkgs）和pip（D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages）下都有这个包。\n\n（pip install应该也一样）\n\npip 通过whl文件安装的包路径 D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages，而conda（D:\\conda\\conda\\pkgs）路径下没有。'),(20,'Spacenet系列官方博客发布时间线',26,'2021-12-18 11:32:10','好耶','# [宣布获胜者 2020/06/05](https://medium.com/the-downlinq/spacenet-6-announcing-the-winners-df817712b515)\n\n\n\n![1_rw6W3jiNHkU-q81s38ED0A](http://cdn.moyusoldier.cn/1_rw6W3jiNHkU-q81s38ED0A.png)\n\n<img src=\"http://cdn.moyusoldier.cn/1_8wEjaqyi7EcY8OwxcZHG4Q.png\" alt=\"1_8wEjaqyi7EcY8OwxcZHG4Q\" style=\"zoom: 50%;\" />\n\n- **EfficientNet**占主导地位：前 5 名中的每一个都使用了神经网络的集成，五个中的四个依赖于[新引入的 EfficientNet 的](https://arxiv.org/abs/1905.11946)轻微变体。EfficientNet 在 ImageNet 上实现了最先进的性能，同时明显比其他最先进的卷积神经网络更小、更快。\n- **更低的训练和推理时间**：总的来说，与过去的挑战相比，训练和推理时间都大大减少了。其中一些是由于网络效率的提高，另一方面是因为与之前的一些 SpaceNet 挑战相比，这是一个更小的数据集。Zbigniewwojna 的模型在推理方面表现最好，速度最快（在 AWS p3.8xlarge 上约为 5.4 s/km²）。\n- **并非总是需要光学预训练**：五名获胜者中只有两名以任何方式利用 SpaceNet 6 光学数据，而是发现 ImageNet 预训练权重提供了相同的性能提升。SatShipAI 在训练 SAR 之前在 PS-RGB 数据上训练了他们的所有模型，而 Motokimura 在切换到 SAR 之前在 PS-RGBNIR 数据上训练了他的集合的 1/3。\n- **多通道掩码**：使用[多通道掩码来表示建筑物内部、边缘和建筑物之间](https://miro.medium.com/max/1324/1*qePAM_bo6hwzSyOjaekS6g.png)的[接触](https://miro.medium.com/max/1324/1*qePAM_bo6hwzSyOjaekS6g.png)的趋势延续了先前的 SpaceNets，并被五名获胜者中的四名使用。只有 SatShipAI 跳过了多通道方法，而是专注于仅将模型的语义分割输出细化为二元预测。\n- **其他编码**：每个参与者都很快了解到 SAR 数据的收集方向（朝北或朝南）对于提高模型性能至关重要。几位获奖者还对 204 个 SAR 图像条带中的每一个的唯一 ID 进行了编码，并将这些信息也输入到网络中。值得注意的是，网络仍然无法直接从图像中自动学习这些信息。这些方法表明，有时即使是很小的预处理步骤对于提高性能和最小化开销观察的一些固有复杂性也特别有价值。\n\n# [模型性能初探 2020/06/16](https://medium.com/the-downlinq/spacenet-6-a-first-look-at-model-performance-9c12c5db2b97)\n\nSAR工作原理：\n\n[第一篇](https://medium.com/the-downlinq/sar-101-an-introduction-to-synthetic-aperture-radar-2f0b6246c4a0)\n\n[第二篇](https://medium.com/the-downlinq/sar-201-an-introduction-to-synthetic-aperture-radar-part-2-895beb0b4c0a)\n\n<img src=\"http://cdn.moyusoldier.cn/1_gAR5XkunyTUF0MH3DwdRAg.png\" alt=\"1_gAR5XkunyTUF0MH3DwdRAg\" style=\"zoom: 25%;\" />\n\n<img src=\"http://cdn.moyusoldier.cn/1_BMuNqGIWr8NT-VcfhZN6UQ.png\" alt=\"1_BMuNqGIWr8NT-VcfhZN6UQ\" style=\"zoom:25%;\" />\n\n**任何小于 40 平方米的结构都无法识别。**\n\n# [探索大规模基础测绘 2020/07/01](https://medium.com/the-downlinq/spacenet-6-exploring-foundational-mapping-at-scale-d0c5a2def123)\n\n\n\n![1_abGjyhpYbDR9JPGDXNiLfw](http://cdn.moyusoldier.cn/1_abGjyhpYbDR9JPGDXNiLfw.png)\n\n<img src=\"http://cdn.moyusoldier.cn/1_GQSzKwe0XqV3lUOkrVwS4g.png\" alt=\"1_GQSzKwe0XqV3lUOkrVwS4g\" style=\"zoom: 50%;\" />\n\n<img src=\"http://cdn.moyusoldier.cn/1_vLZacRyL5bCyMcVqtbsA2A.png\" alt=\"1_vLZacRyL5bCyMcVqtbsA2A\" style=\"zoom:25%;\" />\n\n# [数据融合和着色 2020/07/23](https://medium.com/the-downlinq/spacenet-6-data-fusion-and-colorization-38a77cc4fb74)\n\n\n\n![1__JkIWCS_ajJ-AFIDhAqQyg](http://cdn.moyusoldier.cn/1__JkIWCS_ajJ-AFIDhAqQyg.png)\n\n总的来说，这些结果相当令人失望，但从这个工作流程中可以学到一些很好的经验教训。这里的主要内容是 SAR 和 RGB 融合是值得做的——它比仅使用 SAR SPAN 提供了 55% 的性能提升。此外，对于该任务，使用 SAR SPAN 的性能仅略低于使用所有 4 种极化（39.5 对 42.4）。不幸的是，用深度学习方法重新创建这个数据融合过程是相当困难的。\n\n- 结论\n\n这篇博客标志着我们的后 SpaceNet 6 分析系列的结束。我们一路上学到了很多东西，包括：\n\n1. [EfficentNet 在竞争中脱颖而出。](https://medium.com/the-downlinq/spacenet-6-announcing-the-winners-df817712b515)\n2. [建筑高度和大小对模型性能有什么影响？](https://medium.com/the-downlinq/spacenet-6-a-first-look-at-model-performance-9c12c5db2b97)—在处理 SAR 数据时，高大、矮小或小型建筑物可能非常具有挑战性。\n3. [模型在城市尺度上的表现如何？](https://medium.com/the-downlinq/spacenet-6-exploring-foundational-mapping-at-scale-d0c5a2def123)—比单个tile好 20%。\n4. [需要多少次 SAR 重访才能最大化提取建筑物等静态对象的模型性能？](https://medium.com/the-downlinq/spacenet-6-exploring-foundational-mapping-at-scale-d0c5a2def123)——四个。\n5. RGB 和 SAR 融合是否可以帮助您检测建筑物？——当然。\n6. 我是否应该训练一个网络来对 SAR 数据进行着色并将其应用于缺乏光学图像的区域？——你应该试试。我们的结果非常初步，缺乏最大化性能所需的严谨性。\n\n# [获奖模型发布 2020/07/30](https://medium.com/the-downlinq/spacenet-6-winning-model-release-a8ce702d482a)\n\n模型：https://github.com/SpaceNetChallenge/SpaceNet_SAR_Buildings_Solutions\n\n权重：s3://spacenet-dataset/spacenet-model-weights/spacenet-6/\n\n# [扩展数据集发布 2020/09/23](https://medium.com/the-downlinq/spacenet-6-expanded-dataset-release-e1a7ddaf030)'),(21,'如何更好的使用光学图像提升模型效果？',58,'2021-12-19 04:49:22','探索探索ing','## 论文及baseline\n\n方法：\n\n​	模型首先在光学图像（RGB）上进行训练，然后将该过程得到的最终权重用作SAR训练的初始权重。\n\n结论：\n\n​	\n\n![spacenet6-baseline-performance](http://cdn.moyusoldier.cn/spacenet6-baseline-performance.png)\n\n> Table: Baseline 模型表现，使用Optical+SAR得到的F1为0.21，仅使用SAR（经过一致性旋转，尊重其方向性）使得到的F1为0.14.\n\n**用光学图像做迁移学习确实会提升baseline上的 F1Score**\n\n## 获奖模型\n\n链接：[https://medium.com/the-downlinq/spacenet-6-announcing-the-winners-df817712b515](https://medium.com/the-downlinq/spacenet-6-announcing-the-winners-df817712b515)\n\n![1_rw6W3jiNHkU-q81s38ED0A](http://cdn.moyusoldier.cn/1_rw6W3jiNHkU-q81s38ED0A.png)\n\n![img](http://cdn.moyusoldier.cn/1_8wEjaqyi7EcY8OwxcZHG4Q.png)\n\n结论：\n\n​	**并非总是需要光学预训练**：五名获胜者中只有两名以任何方式利用 SpaceNet 6 光学数据，而是发现 ImageNet 预训练权重提供了相同的性能提升。SatShipAI 在训练 SAR 之前在 PS-RGB 数据上训练了他们的所有模型，而 Motokimura 在切换到 SAR 之前在 PS-RGBNIR 数据上训练了他的集合的 1/3\n\n## 数据融合和着色（官方发布的赛后总结）\n\n链接：[https://medium.com/the-downlinq/spacenet-6-data-fusion-and-colorization-38a77cc4fb74](https://medium.com/the-downlinq/spacenet-6-data-fusion-and-colorization-38a77cc4fb74)\n\n### 方法1：将SAR图像转换为光学图像\n\n结论：效果平平无奇，并且模型输出不连贯。我们得出的结论是，将 SAR 数据转换为与光学数据几乎相同似乎在如此高分辨率下相当具有挑战性，并且可能不是一个可行的解决方案。\n\n### 方法2：对SAR进行着色\n\n#### 具体流程：\n\n一、SAR与光数据融合：使用色调饱和度值 (HSV)图像融合技术融合SAR 和 RGB 光学图像\n\n二、训练着色网络：\n\n​	Pix2Pix生成对抗网络（GAN）\n\n​	输入：SAR SPAN（单通道）\n\n​	输出：Pix2Pix colorized SAR \n\n​	标签：Fused RGB-SAR\n\n三、创建彩色输出\n\n#### 结论：\n\n​	                            ![1__JkIWCS_ajJ-AFIDhAqQyg](http://cdn.moyusoldier.cn/1__JkIWCS_ajJ-AFIDhAqQyg.png)  \n\n>  Table:     不同模型输入到SpaceNet6冠军模型的表现\n>\n> 第一行：如果知道SAR对应的RGB图像，就能达到这种效果，但实际上我们只知道SAR图像\n>\n> 第二行：只知道SAR图像，并且把SAR转换成单通道\n>\n> 第三行：只知道SAR图像，并且使用pix2pix对SAR进行着色\n>\n> （注：冠军模型：只知道SAR图像，并且使用SAR图像，Overall Score=42.4）\n\n​	\n\n​	总的来说，这些结果**相当令人失望**，但从这个工作流程中可以学到一些很好的经验教训。\n\n​	这里的主要内容是 SAR 和 RGB 融合是值得做的——它比仅使用 SAR SPAN 提供了 55% 的性能提升。此外，对于该任务，使用 SAR SPAN 的性能仅略低于使用所有 4 种极化（39.5 对 42.4）。\n\n​	不幸的是，用深度学习方法重新创建这个数据融合过程是相当困难的。我们发现 GAN 倾向于对事物进行不一致的着色，并且会留下混淆我们分割模型的伪影。此外，我们还尝试使用 CycleGAN 来完成域自适应方法和其他 SAR 输入，但结果同样非常糟糕。总的来说，我们采取了最直接的方法，对现有的 Pix2Pix 模型架构几乎没有做任何修改。**额外的训练数据、不同的输入或色彩空间、修改后的数据加载器和定制的网络可能是改善这些结果和推进研究的基线要求。**\n\n论文链接：\n\n[https://arxiv.org/abs/1802.10036](https://arxiv.org/abs/1802.10036) Generating High Quality Visible Images from SAR Images Using CNNs 【使用Pix2Pix进行着色】 \n\n[https://phillipi.github.io/pix2pix/](https://phillipi.github.io/pix2pix/)  Image-to-Image Translation with Conditional Adversarial Networks 【抑制斑点噪声+GAN着色】'),(23,'J2EE复习大纲',28,'2021-12-19 15:24:23','J2EE笔记1','# 1.Servlet部分\n\n## javax.Servlet\n\n### Servlet\n\n>destroy\n>\n>getServletConfig\n>\n>getServletInfo\n>\n>init\n>\n>service\n\n- 生命周期\n\n  1. 加载类：当容器启动或首次请求某个 Servlet 时，容器会读取 web.xml 或 @WebServlet 中的配置信息，对指定的 Servlet 进行加载。\n  2. 实例化：加载成功后，容器会通过反射对 Servlet 进行实例化。\n  3. 初始化：\n     - Servlet 容器调用 init() 方法初始化 Servlet 实例。\n     - 初始化的目的：让 Servlet 实例在处理请求之前完成一些初始化工作，例如建立数据库连接，获取配置信息等。\n     - 在 Servlet 的整个生命周期内，init() 方法只能被调用一次。\n     - 初始化期间，Servlet 实例可以通过 ServletConfig 对象获取在 web.xml 或者 @WebServlet 中配置的初始化参数。\n  4. 请求处理：\n     - 运行时阶段是 Servlet 生命周期中最重要的阶段。Servlet 容器接收到来自客户端请求时，容器会针对该请求分别创建一个 ServletRequst 对象和 ServletResponse 对象，将它们以参数的形式传入 service() 方法内，并调用该方法对请求进行处理。\n     - 这里需要注意的是，执行 service() 方法前，init() 方法必须已成功执行。\n     - 在 service() 方法中，Servlet 通过 ServletRequst 对象获取客户端的相关信息和请求信息。在请求处理完成后，通过 ServletResponse 对象将响应信息进行包装，返回给客户端。当 Servlet 容器将响应信息返回给客户端后，ServletRequst 对象与 ServletResponse 对象就会被销毁。\n     - 在 Servlet 的整个生命周期内，对于 Servlet 的每一次请求，Servlet 容器都会调用一次 service() 方法，并创建新的 ServletRequest 和 ServletResponse 对象。即 service() 方法在 Servlet 的整个生命周期中会被调用多次。\n  5. 销毁：\n     - 当 Servlet 容器关闭、重启或移除 Servlet 实例时，容器就会调用 destory() 方法，释放该实例使用的资源，例如：关闭数据库连接，关闭文件的输入流和输出流等，随后该实例被 Java 的垃圾收集器所回收。\n     - 对于每个 Servlet 实例来说，destory() 方法只能被调用一次。\n\n\n\n### ServletConfig\n\n>getInitParameter\n>\n>getInitParameterNames\n>\n>getServletContext\n>\n>getServletName\n\n### ServletContext\n\n`ServletContext` 对象包含在 [`ServletConfig`](../javax.servlet.ServletConfig.html) 对象中，[`ServletConfig`](../javax.servlet.ServletConfig.html) 对象在初始化  servlet 时由 Web 服务器提供给 servlet\n\n### ServletRequest\n\n### ServletResponse\n\n## javax.servlet.http\n\n### HttpServletRequest\n\n### HttpServletResponse\n\n### HttpSession\n\n### Cookie\n\n### HttpServlet\n\n## javax.servlet.annotation\n\nhttp://c.biancheng.net/servlet/webservlet.html\n\n> HandlesTypes\n> HttpConstraint\n> HttpMethodConstraint\n> MultipartConfig\n> ServletSecurity\n> WebFilter\n> WebInitParam\n> WebListener\n> WebServlet\n## web listeners and web events. \n\n外链笔记\n\n## Filter\n\n### javax.serlvet.Filter\n\nhttp://c.biancheng.net/servlet2/filter.html\n\n### javax.serlvet.FilterChain\n\nhttp://c.biancheng.net/servlet2/filterchain.html\n\n### javax.serlvet.FilterConfig\n\nhttp://c.biancheng.net/servlet2/filterconfig.html\n\n类比ServletConfig接口\n\n>getFilterName\n>\n>getFilterParameter\n>\n>getFilterParameterNames\n>\n>getServletContext\n\n## 请求转发和重定向\n\n### javax.servlet.RequestDispatcher\n\nhttp://c.biancheng.net/servlet2/requestdispatcher.html\n\n请求转发 request.getRequestDispatcher(\"/DoServlet\").forward(request, response);\n\n### javax.servlet.http.HttpServletResponse\n\nhttp://c.biancheng.net/servlet2/redirection.html\n\n重定向 response.sendRedirect(\"/responseDemo/RefreshServlet\");\n\n# 2.JSP部分\n\n外链笔记\n\n# 3.Struts1\n\n外链笔记\n\n# 4.Spring\n\n外链笔记'),(24,'web listeners and web events',23,'2021-12-19 15:25:21','J2EE笔记2','# Listener设计模式-观察者模式\n\n也叫发布-订阅模式，一种一对多关系，B、C、D对象观察A对象，A发生改变时，通知B、C、D 做出相应改变。\n\n# Listener接口\n\n## 介绍\n\n1. 来自Servlet规范中的一组接口（8个）\n2. 专门用来监听域对象生命周期的变化以及域对象共享数据变化情况\n\n## 域对象\n\n1. 在某一个范围内，为Servlet之间提供共享数据的对象	\n\n2. 分类：\n\n   - ServletContext application \n   - HttpSession session\n   - HttpServletRequest request\n\n   注：PageContext pageContext不是域对象 \n\n## 实现步骤\n\n1. 根据监听的目标对象，选择一个合适的监听器接口来实现\n2. 重写监听器接口中监听处理方法\n3. 在web.xml中注册监听器，通知Tomcat\n\n# Servlet监听器\n\n三类八种:\n\n监听三个域对象的创建和销毁的监听器: \n\n* ServletContextListener Event接口中方法为getServletContext\n\n![image-20211108135939379](http://cdn.moyusoldier.cn/image-20211108135939379.png)\n\n* HttpSessionListener  Event接口中方法为getSession\n\n![image-20211108140051915](http://cdn.moyusoldier.cn/image-20211108140051915.png)\n\n* ServletRequestListener Event接口中方法为getServletContext&getServletRequest\n\n![image-20211108140025749](http://cdn.moyusoldier.cn/image-20211108140025749.png)\n\n监听三个域对象的属性变更的监听器(属性添加,移除,替换):\n\n* ServletContextAttributeListener Event接口中方法为getName&getValue\n\n![image-20211108140146322](http://cdn.moyusoldier.cn/image-20211108140146322.png)\n\n* HttpSessionAttributeListener  Event接口中方法为getName&getValue&getSession\n\n![image-20211108140125024](http://cdn.moyusoldier.cn/image-20211108140125024.png)\n\n* ServletRequestAttributeListener  Event接口中方法为getName&getValue\n\n![image-20211108140202769](http://cdn.moyusoldier.cn/image-20211108140202769.png)\n\n监听HttpSession中的JavaBean的状态改变(绑定,解除绑定,钝化,活化)\n\n* HttpSessionBindingListener Event接口中方法为valueBound/valueUnbound\n\n![image-20211108140225671](http://cdn.moyusoldier.cn/image-20211108140225671.png)\n\n* HttpSessionActivationListene Event接口中方法为getSession\n\n![image-20211108140247456](http://cdn.moyusoldier.cn/image-20211108140247456.png)\n'),(25,'JSP',31,'2021-12-19 15:26:11','J2EE笔记3','# JSP基础\n\n## 1.语法\n\n- 脚本程序\n\n```jsp\n<%\nout.println(\"Your IP address is \" + request.getRemoteAddr());\n%>\n```\n\n- JSP声明\n\n```jsp\n<%! int i = 0; %> \n<%! int a, b, c; %> \n<%! Circle a = new Circle(2.0); %> \n```\n\n- JSP表达式\n\n```jsp\n<%= (new java.util.Date()).toLocaleString()%>\n```\n\n## 2.指令\n\n- page\n\n```jsp\n<%@ page attribute=\"value\" %>\n```\n\n- include\n\n```jsp\n<%@ include file=\"文件相对 url 地址\" %>\n```\n\n- taglib\n\n```jsp\n<%@ taglib uri=\"uri\" prefix=\"prefixOfTag\" %>\n```\n\n## 3.动作\n\n| 语法            | 描述                                            | Eg.                                                          |\n| :-------------- | :---------------------------------------------- | ------------------------------------------------------------ |\n| jsp:include     | 在页面被请求的时候引入一个文件。                | <jsp:include page=\"相对 URL 地址\" flush=\"true\" />            |\n| jsp:useBean     | 寻找或者实例化一个JavaBean。                    | <jsp:useBean id=\"name\" class=\"package.class\" />              |\n| jsp:setProperty | 设置JavaBean的属性。                            | <jsp:setProperty name=\"myName\" property=\"someProperty\" .../> |\n| jsp:getProperty | 输出某个JavaBean的属性。                        | <jsp:getProperty name=\"myName\" property=\"someProperty\" .../> |\n| jsp:forward     | 把请求转到一个新的页面。                        | <jsp:forward page=\"date.jsp\" />                              |\n| jsp:plugin      | 根据浏览器类型为Java插件生成OBJECT或EMBED标记。 |                                                              |\n| jsp:element     | 定义动态XML元素                                 |                                                              |\n| jsp:attribute   | 设置动态定义的XML元素属性。                     |                                                              |\n| jsp:body        | 设置动态定义的XML元素内容。                     |                                                              |\n| jsp:text        | 在JSP页面和文档中使用写入文本的模板             |                                                              |\n\n> 注：JSP指令<%@ include file=\"\" %>和动作< jsp:include page=\"\">的区别\n>\n> - include 指令 **静态包含，先合成再编译**。包含的文件的内容会原封不动地插入到包含页中使用该指令地位置，将执行结果输出到浏览器中。JSP编译器再对这个合成地文件进行编译最终编译成的文件只有一个。file支持jsp/html\n>\n> - include 动作 **动态包含，先编译再合成**。include动作标识，该标识被执行时，程序会将请求转发到（注意是转发而不是请求重定向）被包含的页面，并将执行结果输出到浏览器中，然后返回包含页继续执行后面的代码。对两个文件分别编译，服务器执行的其实是两个文件。page支持jsp/html/Servlet组件\n\n# EL基础\n\nJSP2.0以上支持EL语言（表达式语言），使编程更容易\n\n假设要输出一个属性\n\n```jsp\n<jsp:useBean id=\"box\" class=\"com.moyu.servlet.Box\" />\n<jsp:setProperty name=\"box\" property=\"perimeter\" value=\"100\"/>\n```\n\n- JSP表达式输出\n\n```jsp\n<%= box.getPerimeter()%>\n```\n\n- jsp:getProperty，JSP动作输出\n\n```jsp\n<jsp:getProperty name=\"box\" property=\"perimeter\"/>\n```\n\n- EL语言输出\n\n```jsp\n${box.perimeter}\n```\n\n支持变量、运算符(div mod eq ne lt gt le ge)\n\n# EL表达式11个隐含对象\n\n- 对比JSP中9个隐含对象，必考config和application的类型\n\n```java\nfinal javax.servlet.http.HttpServletRequest request;\nfinal javax.servlet.http.HttpServletResponse response\nfinal javax.servlet.jsp.PageContext pageContext;\njavax.servlet.http.HttpSession session = null;\nfinal javax.servlet.ServletContext application;\nfinal javax.servlet.ServletConfig config;\njavax.servlet.jsp.JspWriter out = null;\nfinal java.lang.Object page = this;\njavax.lang.Throwable exception;\n```\n\n- EL表达式11个隐含对象：${}里可以出现的变量\n\n| **隐含对象**     | **描述**                                            |\n| :--------------- | :-------------------------------------------------- |\n| pageScope        | page 作用域                                         |\n| requestScope     | request 作用域                                      |\n| sessionScope     | session 作用域                                      |\n| applicationScope | application 作用域                                  |\n| param            | 如同 ServletRequest.getParameter(String name)       |\n| paramValues      | 如同 ServletRequest.getParameterValues(String name) |\n| header           | 如同 ServletRequest.getHeader(String name)          |\n| headerValues     | 如同 ServletRequest.getHeaders(String name)         |\n| initParam        | 如同 ServletContext.getInitParameter(String name)   |\n| cookie           | 如同 HttpServletRequest.getCookies()                |\n| pageContext      | 当前页面的pageContext                               |\n\n- pageContext\n\n  - 唯一一个和JSP中隐含对象pageContext一模一样，两个隐含对象指向同一个对象，是PageContext类型，其余的EL隐含对象全是Map类型\n\n  - 以下方法提供对隐式对象的**便捷访问**：`getException()`、`getPage()`、`getRequest()`、`getResponse()`、`getSession()`、`getServletConfig()`  和 `getServletContext()`。 \n\n    以下方法提供对**转发、包含和错误处理**的支持：`forward()`、`include()` 和  `handlePageException()`\n\n    即门面对象，通过pageContext.getRequest()/getSession()/getServletContext 进而调用它们的serAttribute()/getAttribute()，麻烦，重载提供了方便，重载函数形式为\n\n  ```jsp\n  pageContext.setAttribute(String name, Object value, int scope) \n  //scope的值有四个：\n  //PageContext.PAGE_SCOPE(=1)、PageContext.REQUEST_SCOPE(=2)、PageContext.SESSION_SCOPE(=3)、PageContext.APPLICATION_SCOPE(=4)\n  ```\n\n  几种等价形式：\n\n  ```jsp\n  pageContext.getSession().setAttribute(String name, Object value);\n  //等价于\n  session.setAttribute(String name, Object value);\n  //等价于\n  pageContext.setAttribute(String name, Object value, PageContext.SESSION_SCOPE);\n  ```\n\n- 四大作用域  page<request<session<application \n\n  -  Map<String name, Object value>类型\n\n  - ```jsp\n    <%\n    	pageContext.setAttribute(\"info\",\"page属性范围\");\n    	request.setAttribute(\"info\",\"request属性范围\");\n    	session.setAttribute(\"info\",\"session属性范围\");\n    	application.setAttribute(\"info\",\"application属性范围\");\n    %>\n    \n    ${info}//从最小作用域找，输出为page属性范围\n    ${pageScope.info}//等价于${pageScope[\"info\"]}\n    ${requestScope.info}\n    ${sessionScope.info}\n    ${applicationScope.info}\n    ```\n\n  - 释放数据：invalidate\\timeout\n\n- param\n\n  - Map<String,String>类型\n\n  - 从客户端发送的请求携带的参数，url 问号后数据如何获取？调用HttpServletRequest类getParameter函数\n\n    ```java\n    String getParameter(String var1);\n    ```\n\n- paramValues\n\n  - Map<String, String[]>类型\n\n    ```java\n    String[] getParameterValues(String var1);\n    ```\n\n- initParam（Servlet组件的配置信息）\n\n  - ```java\n    String getInitParameter(String var1);\n    ```\n\n  - Map<String,String>类型，同param\n\n  - GenericServlet类实现了ServletConfig接口，同时又包含一个ServletConfig对象（看源码），则有两种方法获取initParameter\n\n  - ```java\n    //在servlet中\n    getInitParameter();\n    getServletConfig().getInitParameter();\n    //在JSP中\n    <%=config.getInitParameter(\"port\")%>\n    <%=pageContext.getServletConfig().getInitParameter(\"port\")%>\n    <%=getServletConfig().getInitParameter(\"port\")%>\n    ```\n\n- cookie\n  - Map<String, Cookie>类型\n\n存取运算符\n\n	1. 点 对象的属性，map按key取value\n	2. 方括号 括号里是key或者数组下标\n\n## 举例\n\nhttp://localhost:8080/a.jsp?at=1&at=2&at=3 \n\n1.获取at的值？\n\na.jsp\n\n```	jsp\n${paramValues.at[0]} //输出1\n```\n\n2.输出问号后内容\n\n```jsp\n<%=\n    request.getQueryString()\n%>\n```\n\n```jsp\n${pageContext.getRequest().getQueryString()}\n```\n\n牢记pageContext对象，万能对象，有它就有一切\n\ngetQueryString()是哪个接口里的函数？\n\n答：是HttpServletRequest （针对Http协议的派生接口），不是 ServletRequest，\n\n# Tag\n\nhttps://www.runoob.com/jsp/jsp-custom-tags.html\n\n\n### SimpleTag\n\n### Tag\n\n### SimpleTagSupport\n\n### TagSupport'),(26,'struts1',1,'2021-12-19 15:26:59','J2EE笔记4','# 1. 结构\n\n## 1.1 配置文件\n\n### /WEB-INF/struts-config.xml\n\n核心配置文件，ActionForm、Action要使用它，之所以有效，是因为作为<init-param>写在了web.xml中\n\n定义前端控制器form-bean以及后端控制器action-mapping，通过name属性进行对应\n\n```xml\n<struts-config>\n    <form-beans>\n        <form-bean name=\"calcForm\" type=\"com.abc.form.CalcForm\"/>\n    </form-beans>\n    <action-mappings>\n        <action path=\"/calc\" type=\"com.abc.action.CalcAction\" name=\"calcForm\"\n                input=\"/input.jsp\">\n            <forward name=\"result\" path=\"/result.jsp\" redirect=\"false\"/>\n        </action>\n    </action-mappings>\n</struts-config>\n```\n\n### web.xml\n\n文件一定会存在，Servlet要使用它\n\nServlet的处理路径：Struts1.x中的servlet路径是经典的\"*.do\"\n\n```xml\n    <servlet>\n        <servlet-name>action</servlet-name>\n        <servlet-class>org.apache.struts.action.ActionServlet</servlet-class>\n        <init-param>\n            <param-name>config</param-name>\n            <param-value>\n                /WEB-INF/struts-config.xml\n            </param-value>\n        </init-param>\n        <load-on-startup>2</load-on-startup>\n    </servlet>\n\n    <!-- Standard Action Servlet Mapping -->\n    <servlet-mapping>\n        <servlet-name>action</servlet-name>\n        <url-pattern>*.do</url-pattern>\n    </servlet-mapping>\n```\n\n## 1.2 资源文件\n\n在src目录下(最终会输出到WEB-INF/classes下 )的ApplicationResources.properties文件（全局资源文件，被Controller读取）\n\n## 1.3 JSP\n\n在输入组件中定义的property，实际上在最后页面运行的时候，会自动生成id与name两个属性\n\n```html\n<html:form action=\"/calc\">\n    n1: <html:text property=\"n1\"/><br>\n    n2: <html:text property=\"n2\"/><br>\n    <html:submit property=\"submit\" value=\"Add\"/>\n</html:form>\n```\n\n```html\n以下内容\n<html:text property=\"n2\" />\n会生成\n<input type = \"text\" id =\"n2\" name = \"n2\">\n```\n\n注：该请求的URL为http://localhost:8080/calc.do?n1=xx&n2=xx&submit=Add 有<name,value>的param就会在url的parma里出现\n\n## 1.4 Controller\n\n将一个Servlet的Controller变为两个部分：ActionForm与Action，永远成对出现\n\n产生问题：每一个Action都匹配一个ActionForm，结果ActionForm无限多（最大缺点）\n\n### ActionForm(纯数据)\n\nhttps://blog.csdn.net/lovesummerforever/article/details/18951649\n\n服务器端数据验证，保存错误信息，进行跳转（根据input跳转）\n\n继承自ActionForm类，属性都会生成对应的setter/getter\n\n### Action\n\n配置访问路径，也就是表单提交路径\n\n继承自Action类\n\n负责跳转，与Servlet相似（自己决定）\n\n# 2. 工作原理\n\n## 2.1 MVC\n\nStruts 1.x是MVC的最基础实现，请求的处理流程是重中之重。\n\n![image-20211110150955846](http://cdn.moyusoldier.cn/image-20211110150955846.png)\n\n## 2.2 工作流程\n\n<img src=\"http://cdn.moyusoldier.cn/struts.gif\" alt=\"img\" style=\"zoom: 150%;\" />\n\n\n\n1. 只要是MVC操作，那么核心流程：JSP提交给Servlet，而后Servlet跳转到指定的JSP页面\n2. Struts支持标签操作，在编写JSP时使用HTML标签生成HTML元素，好处是帮助用户隐藏代码细节，如\n\n```xml\n<html:text property=\"n2\" />\n```\n\n会生成HTML元素，同时也可以自动与ActionForm属性相关联（必须在ActionForm中定义好）\n\n```xml\n<html:form action=\"/calc\" >\n```\n\n由于设置了Action的处理路径，HTML代码在运行之前会默认先调用一次ActionForm的reset()方法表示进行内容的初始化\n\n3. 表单提交时输入的是struts-config.xml里配置的action路径，同时后面要加上*.do，因为在Struts里面所有的处理提交都是先提交给一个ActionServlet的，在web.xml中定义了\n\n   ```xml\n   <servlet>\n       <servlet-name>action</servlet-name>\n       <servlet-class>org.apache.struts.action.ActionServlet</servlet-class>\n       <init-param>\n         <param-name>config</param-name>\n         <param-value>\n             /WEB-INF/struts-config.xml   \n          </param-value>\n       </init-param>\n       <load-on-startup>2</load-on-startup>\n     </servlet>\n   \n     <!-- Standard Action Servlet Mapping -->\n     <servlet-mapping>\n       <servlet-name>action</servlet-name>\n       <url-pattern>*.do</url-pattern>\n     </servlet-mapping>\n   ```\n\n   之所以struts-config.xml有效，是因为在ActionServlet中要读取此路径中内容，进行SAX解析进行文件的分析。\n\n   这个ActionServlet是在项目加载时默认先执行的，及容器启动时立刻加载struts-config配置文件。\n\n   而这个ActionServlet也可以作为请求的处理，处理的时候只需要处理的后缀为.do就可以找到这个处理的Servlet。\n\n4. 当ActionServlet接收到用户请求之后，会自动的将请求处理的路径与指定的ActionForm关联，利用反射动态设置ActionForm类对象中的属性，调用setter方法，提交的路径是在Action上配置的，而Action与ActionForm在struts-config.xml中关联\n\n   ```xml\n   <form-beans>\n       <form-bean name=\"calcForm\" type=\"com.abc.form.CalcForm\" />\n   </form-beans>\n   \n   <action-mappings>\n       <action path=\"/calc\" type=\"com.abc.action.CalcAction\" name=\"calcForm\" input=\"/input.jsp\">\n           <forward name=\"result\" name=\"result\" redirect=\"false\" />\n       </action>\n   </action-mappings>\n   ```\n\n5. 当ActionForm里有内容之后，处理错误信息\n\n6. 若错误，将请求给input路径的跳转路径，将请求跳转回指定的页面并且使用<html:errors>标签进行显示\n\n7. 若无错误，继续将处理交给Action完成，Action默认执行execute()，调用业务层方法，而后根据结果跳转到指定的路径。通过ActionMapping类读取struts-config.xml配置信息，并且利用这个类对象的findForward()方法可以设置要读取数据的key的信息，而后要跳转的路径会使用ActionForward类对象包装 ，而后ActionServlet类里面根据接收到的ActionForward里面保存的路径的key(name=\"result\")取出对应的value(name=\"result\")，而后利用RequestDispatcher实现跳转操作。\n\n# 3. DispatchAction&LookupDispatchAction\n\n## 3.1 DispatchAction\n\n- https://blog.csdn.net/lovesummerforever/article/details/18967831\n- 使用场景：an HTML form has multiple submit buttons with the same name 一个表单对应多个提交按钮\n\n```xml\n<!--stuts-config.xml-->\n<action path=\"/saveSubscription\" \n        type=\"org.apache.struts.actions.DispatchAction\" \n        name=\"subscriptionForm\" \n        scope=\"request\" \n        input=\"/subscription.jsp\" \n        parameter=\"method\"/> \n```\n\n```html\n<!--index.jsp-->\n<html:form action=\"/saveSubscription\">\n    <html:submit property=\"method\" value=\"add\"></html:submit>\n    <html:submit property=\"method\" value=\"divide\"></html:submit>\n</html:form>\n```\n\n```java\npublic ActionForward add(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception{\n    \n}\npublic ActionForward delete(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception{\n    \n}\n```\n\nURL为:\n\n  http://localhost:8080/myapp/saveSubscription.do?method=add \n\n  http://localhost:8080/myapp/saveSubscription.do?method=delete\n\n```java\n//DispatchAction.java\npackage org.apache.struts.actions;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.struts.action.ActionForm;\nimport org.apache.struts.action.ActionForward;\nimport org.apache.struts.action.ActionMapping;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport java.util.HashMap;\n\n\npublic abstract class DispatchAction extends BaseAction {\n    \n    protected Class clazz = this.getClass();\n\n    /**\n     * The set of Method objects we have introspected for this class, keyed by\n     * method name.  This collection is populated as different methods are\n     * called, so that introspection needs to occur only once per method\n     * name.\n     我们为该类内省的一组方法对象，以方法名作为键值。 这个集合在调用不同的方法时被填充，因此每个方法名只需要进行一次内省。\n     */\n    protected HashMap methods = new HashMap();\n\n    /** execute函数的参数类型\n     * The set of argument type classes for the reflected method call.  These\n     * are the same for all calls, so calculate them only once.\n     反射方法调用的参数类型类集合。 这些对于所有调用都是相同的，所以只计算一次。  \n     */\n    protected Class[] types =\n        {\n            ActionMapping.class, ActionForm.class, HttpServletRequest.class,\n            HttpServletResponse.class\n        };\n\n    \n    public ActionForward execute(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        if (isCancelled(request)) {\n            ActionForward af = cancelled(mapping, form, request, response);\n\n            if (af != null) {\n                return af;\n            }\n        }\n\n        // Get the parameter. This could be overridden in subclasses.\n        //根据ActionMapping.getParameter()，从定义的struts-config.xml中得到parameter=method\n        String parameter = getParameter(mapping, form, request, response);\n\n        // Get the method\'s name. This could be overridden in subclasses.\n        //根据parameter=method，根据request.getParamater()，得到name=add\n        String name =\n            getMethodName(mapping, form, request, response, parameter);\n\n        // Prevent recursive calls\n        //防止递归调用\n        if (\"execute\".equals(name) || \"perform\".equals(name)) {\n            String message =\n                messages.getMessage(\"dispatch.recursive\", mapping.getPath());\n\n            log.error(message);\n            throw new ServletException(message);\n        }\n\n        // Invoke the named method, and return the result\n        //所有请求先进execute函数，获得name=add,再分配给dispatch函数执行\n        return dispatchMethod(mapping, form, request, response, name);\n    }\n\n    /**\n     * Method which is dispatched to when there is no value for specified\n     * request parameter included in the request.  Subclasses of\n     * <code>DispatchAction</code> should override this method if they wish to\n     * provide default behavior different than throwing a ServletException.\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @param request  The non-HTTP request we are processing\n     * @param response The non-HTTP response we are creating\n     * @return The forward to which control should be transferred, or\n     *         <code>null</code> if the response has been completed.\n     * @throws Exception if the application business logic throws an\n     *                   exception.\n     */\n    protected ActionForward unspecified(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        String message =\n            messages.getMessage(\"dispatch.parameter\", mapping.getPath(),\n                mapping.getParameter());\n\n        log.error(message);\n\n        throw new ServletException(message);\n    }\n\n    /**\n     * Method which is dispatched to when the request is a cancel button\n     * submit. Subclasses of <code>DispatchAction</code> should override this\n     * method if they wish to provide default behavior different than\n     * returning null.\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @param request  The non-HTTP request we are processing\n     * @param response The non-HTTP response we are creating\n     * @return The forward to which control should be transferred, or\n     *         <code>null</code> if the response has been completed.\n     * @throws Exception if the application business logic throws an\n     *                   exception.\n     * @since Struts 1.2.0\n     */\n    protected ActionForward cancelled(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        return null;\n    }\n\n    // ----------------------------------------------------- Protected Methods\n\n    /**\n     * Dispatch to the specified method.\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @param request  The non-HTTP request we are processing\n     * @param response The non-HTTP response we are creating\n     * @param name     The name of the method to invoke\n     * @return The forward to which control should be transferred, or\n     *         <code>null</code> if the response has been completed.\n     * @throws Exception if the application business logic throws an\n     *                   exception.\n     * @since Struts 1.1\n     */\n    protected ActionForward dispatchMethod(ActionMapping mapping,\n        ActionForm form, HttpServletRequest request,\n        HttpServletResponse response, String name)\n        throws Exception {\n        // Make sure we have a valid method name to call.\n        // This may be null if the user hacks the query string.\n        if (name == null) {\n            return this.unspecified(mapping, form, request, response);\n        }\n\n        // Identify the method object to be dispatched to\n        Method method = null;\n\n        //根据函数名name=add，从HashMap methods中得到具体的函数\n        try {\n            method = getMethod(name);\n        } catch (NoSuchMethodException e) {\n            String message =\n                messages.getMessage(\"dispatch.method\", mapping.getPath(), name);\n\n            log.error(message, e);\n\n            String userMsg =\n                messages.getMessage(\"dispatch.method.user\", mapping.getPath());\n            throw new NoSuchMethodException(userMsg);\n        }\n\n        ActionForward forward = null;\n\n        try {\n            Object[] args = { mapping, form, request, response };\n			//执行add函数并返回结果\n            //方法.invoke(对象，参数)\n            forward = (ActionForward) method.invoke(this, args);\n        } catch (ClassCastException e) {\n            String message =\n                messages.getMessage(\"dispatch.return\", mapping.getPath(), name);\n\n            log.error(message, e);\n            throw e;\n        } catch (IllegalAccessException e) {\n            String message =\n                messages.getMessage(\"dispatch.error\", mapping.getPath(), name);\n\n            log.error(message, e);\n            throw e;\n        } catch (InvocationTargetException e) {\n            // Rethrow the target exception if possible so that the\n            // exception handling machinery can deal with it\n            Throwable t = e.getTargetException();\n\n            if (t instanceof Exception) {\n                throw ((Exception) t);\n            } else {\n                String message =\n                    messages.getMessage(\"dispatch.error\", mapping.getPath(),\n                        name);\n\n                log.error(message, e);\n                throw new ServletException(t);\n            }\n        }\n\n        // Return the returned ActionForward instance\n        return (forward);\n    }\n\n    /**\n     * <p>Returns the parameter value.</p>\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @param request  The HTTP request we are processing\n     * @param response The HTTP response we are creating\n     * @return The <code>ActionMapping</code> parameter\'s value\n     * @throws Exception if the parameter is missing.\n     */\n    protected String getParameter(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n\n        // Identify the request parameter containing the method name\n        String parameter = mapping.getParameter();\n\n        if (parameter == null) {\n            String message =\n                messages.getMessage(\"dispatch.handler\", mapping.getPath());\n\n            log.error(message);\n\n            throw new ServletException(message);\n        }\n\n\n        return parameter;\n    }\n\n    /**\n     * Introspect the current class to identify a method of the specified name\n     * that accepts the same parameter types as the <code>execute</code>\n     * method does.\n     *\n     * @param name Name of the method to be introspected\n     * @return The method with the specified name.\n     * @throws NoSuchMethodException if no such method can be found\n     */\n    protected Method getMethod(String name)\n        throws NoSuchMethodException {\n        synchronized (methods) {\n            Method method = (Method) methods.get(name);\n\n            //第一次执行add函数，method中还没有，则将<key=add,value=add函数>放入Hashmap methods中\n            if (method == null) {\n                //反射获得方法，getMethod(方法名，参数类型)\n                method = clazz.getMethod(name, types);\n                methods.put(name, method);\n            }\n\n            return (method);\n        }\n    }\n\n    /**\n     * Returns the method name, given a parameter\'s value.\n     *\n     * @param mapping   The ActionMapping used to select this instance\n     * @param form      The optional ActionForm bean for this request (if\n     *                  any)\n     * @param request   The HTTP request we are processing\n     * @param response  The HTTP response we are creating\n     * @param parameter The <code>ActionMapping</code> parameter\'s name\n     * @return The method\'s name.\n     * @throws Exception if an error occurs.\n     * @since Struts 1.2.0\n     */\n    protected String getMethodName(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response,\n        String parameter) throws Exception {\n        // Identify the method name to be dispatched to.\n        // dispatchMethod() will call unspecified() if name is null\n        return request.getParameter(parameter);\n    }\n}\n\n```\n\n## 3.2 LookupDispatchAction\n\n- LookupDispatchAction是DispatchAction的子类。它们都允许同一个Action根据请求URL中的不同参数执行不同操作（即调用不同的函数）。\n- LookupDispatchAction重写了DispatchAction的getMethodName函数。\n- DispatchAction子类是根据用户请求URL中的参数(button value)，匹配DispatchAction子类中的方法名称来实现的。\n- 而LookupDispatchAction子类的实现是根据URL参数和ApplicationResources.properties找到对应button value，再根据button value和KeyMethodMap找到对应的执行函数。\n- 继承LookupDispatchAction的子类，复写getKeyMethodMap()方法，该方法返回一个Map。而这个Map的key应该和资源属性文件中的键匹配（也就是button value），这个Map的value，应该和LookupDispatchAction子类中的方法名称相匹配。\n\n```xml\n<!--stuts-config.xml-->\n<action path=\"/test\"\n        type=\"org.example.MyAction\"\n        name=\"MyForm\"\n        scope=\"request\"\n        input=\"/test.jsp\"\n        parameter=\"method\"/>\n```\n\n```html\n<!--index.jsp-->\n<html:form action=\"/test\">\n    <html:submit property=\"method\">\n        <bean:message key=\"button.add\"/>\n    </html:submit>\n    <html:submit property=\"method\">\n        <bean:message key=\"button.delete\"/>\n    </html:submit>\n</html:form>\n```\n\n```properties\n# ApplicationResources.properties\nbutton.add=Add Record\nbutton.delete=Delete Record\n```\n\n```java\n    protected Map getKeyMethodMap() {\n        Map map = new HashMap();\n        map.put(\"button.add\", \"add\");\n        map.put(\"button.delete\", \"delete\");\n        return map;\n    }\n  \n    public ActionForward add(ActionMapping mapping,\n            ActionForm form,\n            HttpServletRequest request,\n            HttpServletResponse response)\n            throws IOException, ServletException {\n        // do add\n        return mapping.findForward(\"success\");\n    }\n  \n    public ActionForward delete(ActionMapping mapping,\n            ActionForm form,\n            HttpServletRequest request,\n            HttpServletResponse response)\n            throws IOException, ServletException {\n        // do delete\n        return mapping.findForward(\"success\");\n    }\n```\n\nURL为:\n\nhttp://localhost:8080/test.do?method=add record \n\n其中的add record为button.add在属性文件中对应的属性值，注意URL不区分大小写\n\n流程：Add Record -> button.add ->add\n\n```java\n//LookupDispatchAction.java\npackage org.apache.struts.actions;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.struts.Globals;\nimport org.apache.struts.action.ActionForm;\nimport org.apache.struts.action.ActionForward;\nimport org.apache.struts.action.ActionMapping;\nimport org.apache.struts.config.MessageResourcesConfig;\nimport org.apache.struts.config.ModuleConfig;\nimport org.apache.struts.util.MessageResources;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\n\npublic abstract class LookupDispatchAction extends DispatchAction {\n\n    /**\n     * Commons Logging instance.\n     */\n    private static final Log LOG = LogFactory.getLog(LookupDispatchAction.class);\n\n    /**\n     * Reverse lookup map from resource value to resource key.\n     localeMap中存储<userLocale, lookupMap>\n     lookupMap中存储<\"add Record\",\"button.add\">\n     */\n    protected Map localeMap = new HashMap();\n\n    /**\n     * Resource key to method name lookup.\n     这个就是keyMethodMap,就是自己定义的那个Map，存储<\"button.add\",\"add\">\n     */\n    protected Map keyMethodMap = null;\n\n    // ---------------------------------------------------------- Public Methods\n\n    /**\n     * Process the specified HTTP request, and create the corresponding HTTP\n     * response (or forward to another web component that will create it).\n     * Return an <code>ActionForward</code> instance describing where and how\n     * control should be forwarded, or <code>null</code> if the response has\n     * already been completed.\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param request  The HTTP request we are processing\n     * @param response The HTTP response we are creating\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @return Describes where and how control should be forwarded.\n     * @throws Exception if an error occurs\n     */\n    public ActionForward execute(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        return super.execute(mapping, form, request, response);\n    }\n\n    /**\n     * This is the first time this Locale is used so build the reverse lookup\n     * Map. Search for message keys in all configured MessageResources for the\n     * current module.\n     *\n     * @param request    The HTTP request we are processing\n     * @param userLocale The locale for this request\n     * @return The reverse lookup map for the specified locale.\n     */\n    private Map initLookupMap(HttpServletRequest request, Locale userLocale) {\n        Map lookupMap = new HashMap();\n\n        this.keyMethodMap = this.getKeyMethodMap();\n\n        ModuleConfig moduleConfig =\n            (ModuleConfig) request.getAttribute(Globals.MODULE_KEY);\n\n        MessageResourcesConfig[] mrc =\n            moduleConfig.findMessageResourcesConfigs();\n\n        // Look through all module\'s MessageResources\n        for (int i = 0; i < mrc.length; i++) {\n            MessageResources resources =\n                this.getResources(request, mrc[i].getKey());\n\n            // Look for key in MessageResources\n            Iterator iter = this.keyMethodMap.keySet().iterator();\n\n            while (iter.hasNext()) {\n                String key = (String) iter.next();\n                String text = resources.getMessage(userLocale, key);\n\n                // Found key and haven\'t added to Map yet, so add the text\n                if ((text != null) && !lookupMap.containsKey(text)) {\n                    lookupMap.put(text, key);\n                }\n            }\n        }\n\n        return lookupMap;\n    }\n\n    /**\n     * Provides the mapping from resource key to method name.\n     *\n     * @return Resource key / method name map.\n     */\n    protected abstract Map getKeyMethodMap();\n\n    /**\n     * Lookup the method name corresponding to the client request\'s locale.\n     *\n     * @param request The HTTP request we are processing\n     * @param keyName The parameter name to use as the properties key\n     * @param mapping The ActionMapping used to select this instance\n     * @return The method\'s localized name.\n     * @throws ServletException if keyName cannot be resolved\n     * @since Struts 1.2.0\n     根据\"Add Record\" 返回\"add\"：\"Add Record\"->\"button.add\",\"button.add\"->\"add\"\n     */\n    protected String getLookupMapName(HttpServletRequest request,\n        String keyName, ActionMapping mapping)\n        throws ServletException {\n        // Based on this request\'s Locale get the lookupMap\n        Map lookupMap = null;\n\n        synchronized (localeMap) {\n            Locale userLocale = this.getLocale(request);\n\n            lookupMap = (Map) this.localeMap.get(userLocale);\n\n            if (lookupMap == null) {\n                lookupMap = this.initLookupMap(request, userLocale);\n                this.localeMap.put(userLocale, lookupMap);\n            }\n        }\n\n        // Find the key for the resource\n        // \"Add Record\"->\"button.add\"\n        String key = (String) lookupMap.get(keyName);\n\n        if (key == null) {\n            String message =\n                messages.getMessage(\"dispatch.resource\", mapping.getPath());\n            LOG.error(message + \" \'\" + keyName + \"\'\");\n            throw new ServletException(message);\n        }\n\n        // Find the method name\n        // \"button.add\"->\"add\"\n        String methodName = (String) keyMethodMap.get(key);\n\n        if (methodName == null) {\n            String message =\n                messages.getMessage(\"dispatch.lookup\", mapping.getPath(), key);\n\n            throw new ServletException(message);\n        }\n\n        return methodName;\n    }\n\n    /**\n     * Returns the method name, given a parameter\'s value.\n     *\n     * @param mapping   The ActionMapping used to select this instance\n     * @param form      The optional ActionForm bean for this request (if\n     *                  any)\n     * @param request   The HTTP request we are processing\n     * @param response  The HTTP response we are creating\n     * @param parameter The <code>ActionMapping</code> parameter\'s name\n     * @return The method\'s name.\n     * @throws Exception if an error occurs\n     * @since Struts 1.2.0\n     */\n    protected String getMethodName(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response,\n        String parameter) throws Exception {\n        // Identify the method name to be dispatched to.\n        // dispatchMethod() will call unspecified() if name is null\n        String keyName = request.getParameter(parameter);\n\n        if ((keyName == null) || (keyName.length() == 0)) {\n            return null;\n        }\n\n        String methodName = getLookupMapName(request, keyName, mapping);\n\n        return methodName;\n    }\n}\n\n```\n\n\n\n# 4. 页面转发控制 \n\nhttps://blog.csdn.net/lovesummerforever/article/details/19125933'),(27,'Spring',16,'2021-12-19 15:27:49','J2EE笔记5','# spring\n\n1. 理解BeanFactory\n2. 理解ApplicationContext\n3. 理解FileSystemXmlApplicationContext\n4. 理解ClassPathXmlApplicationContext\n5. 理解XmlWebApplicationContext\n6. 理解JavaEE Web Application如何集成Spring框架***\n7. 理解Spring framework的配置。\n\n```xml\n<bean id=\"a\" class=\"a.b.c.Hello\"/>\n<bean name=\"a\" class=\"a.b.c.Hello\"/>\n```\n\n尽量用id属性来标识bean对象，name属性的值可以重复，另外，bean可以有多个名字，例如：\n\n```xml\n<bean name=\"a,b,c\" class=\"a.b.c.Hello\"/>\n```\n\n在独立的Java应用中启动Spring框架：\n\n```java\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class Test {\n	public static void main(String[] args) {\n		ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");	\n		//要知道下面这条语句和上面的语句，二者有何不同？\n		//ApplicationContext ctx = new FileSystemXmlApplicationContext(\"beans.xml\");\n		\n		a.b.c.Hello h1 = (a.b.c.Hello) ctx.getBean(\"a\");\n		a.b.c.Hello h2 = (a.b.c.Hello) ctx.getBean(\"b\");\n		System.out.println(h1 == h2);  //true， 因为是同一个bean对象。		\n	}\n}\n```\n\n```xml\n<bean class=\"a.b.c.Hello\"/>\n```\n\nid, name都没有指定，那么name值默认为和类的全名一致。\n\n```java\na.b.c.Hello h3 = (a.b.c.Hello) ctx.getBean(\"a.b.c.Hello\");\n```\n\n总结一下，尽量使用id来标识bean，id有唯一性的要求。\n\n关于对象的创建，有一些设计模式，例如，工厂方法，对应的spring配置为\n\n```xml\n<bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/>\n```\n\n对应的Java代码\n\n```java\npublic class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n\n    public static ClientService createInstance() {\n        return clientService;\n    }\n}\n```\n\n也可以不指定类型，完全有一个工厂bean来负责创建\n\n```xml\n<!-- the factory bean, which contains a method called createInstance() -->\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n```\n\n上面的bean声明，没有指定类型，该bean的创建有工厂bean的createClientServiceInstance方法来完成。\n\n当然，一个工厂bean可以定义不同的方法来创建不同类型的bean，配置代码和Java代码如下：\n\n```xml\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    <!-- inject any dependencies required by this locator bean -->\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n\n<bean id=\"accountService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createAccountServiceInstance\"/>\n```\n\n```java\npublic class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n\n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}\n```\n\n\n上面举例说明了bean的创建，接下来，bean的属性的处理，包括依赖注入（Dependency Injection）\n通过构函数来完成依赖注入\n\n```java\npackage x.y;\n\npublic class ThingOne {\n\n    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\n        // ...\n    }\n}\npublic class ThingTwo {}\npublic class ThingThree {}\n```\n\n```xml\n<beans>\n    <bean id=\"beanOne\" class=\"x.y.ThingOne\">\n        <constructor-arg ref=\"beanTwo\"/>\n        <constructor-arg ref=\"beanThree\"/>\n    </bean>\n\n    <bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\n    <bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\n</beans>\n```\n\n另外一个通过构造函数来写入bean属性的例子\n\n```java\npackage examples;\n\npublic class ExampleBean {\n\n    // Number of years to calculate the Ultimate Answer\n    private int years;\n\n    // The Answer to Life, the Universe, and Everything\n    private String ultimateAnswer;\n\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}\n```\n\n```xml\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    <constructor-arg type=\"int\" value=\"7500000\"/>\n    <constructor-arg type=\"java.lang.String\" value=\"42\"/>\n</bean>\n```\n\n从上面的两个例子可以看出Spring对构造函数的调用，会自动匹配构造函数的参数类型。\n也可以直接指定参数名字。\n\n```xml \n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    <constructor-arg name=\"years\" value=\"7500000\"/>\n    <constructor-arg name=\"ultimateAnswer\" value=\"42\"/>\n</bean>\n```\n\n下面是通过Setter方法注入依赖。\n\n```xml\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    <!-- setter injection using the nested ref element -->\n    <property name=\"beanOne\">\n        <ref bean=\"anotherExampleBean\"/>\n    </property>\n\n    <!-- setter injection using the neater ref attribute -->\n    <property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n    <property name=\"integerProperty\" value=\"1\"/>\n</bean>\n\n<bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n<bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\n```\n\n需要注意的是，可以通过ref=\"aBean\"属性来注入依赖，也可以通过<ref bean=\"aBean\"/>子元素来完成注入依赖。\nref是reference的简写，是指某个bean的引用。\n\nJava代码就不提供了，无非就是getter/setter方法。\n\n下面是通过Spring来给应用程序配置一个连接池的代码\n\n```xml\n<bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n    <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb\"/>\n    <property name=\"username\" value=\"root\"/>\n    <property name=\"password\" value=\"asdfasdf\"/>\n</bean>\n```\n\nApplicationContext是组件的容器，得到ApplicationContext对象，就可以通过getBean方法得到Bean，那么在我们的应用程序中，如何得到ApplicationContext对象呢？\n来介绍一个有趣的接口，Aware接口，什么什么Aware接口，Aware这个英语单词，意思是“知道的”，知道什么什么。既然知道，那么就拥有什么什么类型的引用变量，指向那个对象。\n所以：ApplicationContextAware接口中的抽象函数就是	public void setApplicationContext(ApplicationContext applicationContext)  在Web应用程序中，可以通过WebApplicationContextUtils这个类的public static WebApplicationContext getWebApplicationContext(ServletContext sc)获取ApplicationContext对象，不过我们很少调用这个函数，为什么？\n\n在独立的Java应用，可以使用一个全局静态方法来获取ApplicationContext对象。\n\nbean对象的作用域，默认是单例模式，只有一个实例。\n\n```xml\n<!-- the following is equivalent, though redundant (singleton scope is the default) -->\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/>\n```\n\nscope的值可以是singleton, prototype, request, session, application, 以及websocket。\n\n一定要理解singleton和prototype的区别！\n\n最后，使用xml来定义bean是否很麻烦？如果bean的数量特别多，那么在xml文件中声明很麻烦了。\n可以通过注解（Annotation）来简化声明。\n在xml文件中声明使用Java注解\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n对应的Java代码\n\n```java\n@Configuration\npublic class MyConfiguration {\n\n    @Bean\n    public StringStore stringStore() {\n        return new StringStore();\n    }\n\n    @Bean\n    public IntegerStore integerStore() {\n        return new IntegerStore();\n    }\n}\n```\n\n注入依赖， 使用这个注解： @Autowired， Autowired注解可以注解在变量上，也可以注解在Setter方法上。\n构造函数注入依赖\n\n```java\npublic class MovieRecommender {\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n        this.customerPreferenceDao = customerPreferenceDao;\n    }\n	\n}\n```\n\nSetter方法注入依赖\n\n```java\npublic class SimpleMovieLister {\n\n    @Autowired\n    public void setMovieFinder(Optional<MovieFinder> movieFinder) {\n        ...\n    }\n}\n```\n\n再来看另外的Java代码，加载组件\n\n```java\n@Configuration\n@ComponentScan(basePackages = \"org.example\")\npublic class AppConfig  {\n    ...\n}\n```\n\n或者使用xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n	<context:annotation-config/> <!--  annotation-config可以不声明了，因为component-scan会自动打开注解扫描 -->\n    	<context:component-scan base-package=\"org.example\"/>\n\n</beans>\n```\n\n通过base-package指明要扫描的包中的组件类。\n组件类可以通过这些注解来声明：@Component, @Repository, @Service, @Controller\n\n比较一下Java注解来声明bean，和使用xml来声明bean\n\n```java\n@Configuration\npublic class AppConfig {\n\n    @Bean(\"myService\")\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}\n```\n\n```xml\n<beans>\n    <bean id=\"myService\" class=\"com.acme.services.MyServiceImpl\"/>\n</beans>\n```\n\n接下来看看资源文件的处理\n一切资源都使用接口Resource来声明，非常抽象的一个接口，如同BeanFactory, ApplicationContext\n该接口定义在org.springframework.core.io包中，当然也属于spring core(核心包），\n然后该接口有很多派生接口，处理各种不同来源的资源，以及对资源的读写。\n如同其他注入的属性类型，也可以注入Resource，例如给某个bean对象注入Resource属性\n\n```xml\n<property name=\"template\" value=\"classpath:some/resource/path/myTemplate.txt\">\n<property name=\"template\" value=\"file:///some/resource/path/myTemplate.txt\"/>\n```\n\nSpring对配置文件的加载\n\n```xml\n<context:property-placeholder location=\"classpath:jdbc.properties \" />\n```\n\n注意property-placeholderlocation元素只能出现一次，出现多个的话，只加载一个，其余不加载。\n所以，如果想加载多个属性文件（.proeprties）\n可以这样使用：\n\n```xml\n<context:property-placeholderlocation=\"classpath:*.properties\" />\n```\n\n或者\n\n```xml\n<bean id=\"propertyConfigurer\"class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n   <property name=\"locations\">\n	 <list>\n		<value>conf/sqlmap/jdbc.properties</value>\n		<value>conf/config/app.properties</value>\n	</list>\n   </property>\n</bean>\n```\n\n在Java代码中使用，例如注入：\n#app.properties\nabc=123\n\n在Bean中注入\n@Value(\"${abc}\")\nprivate String abc;\n需要开启< context:annotation-config />，通过注解来完成配置。否则@Value不起作用\n@Value可以注解一个属性成员变量，或者Setter方法，或者参数。\n\n在属性文件中使用：\n\n```xml\n<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n    <property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/>\n</bean>\n\n<bean id=\"dataSource\" destroy-method=\"close\"\n        class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/>\n    <property name=\"url\" value=\"${jdbc.url}\"/>\n    <property name=\"username\" value=\"${jdbc.username}\"/>\n    <property name=\"password\" value=\"${jdbc.password}\"/>\n</bean>\n```\n\n# spring-controller\n\nspring框架全面支持mvc设计模式。\n\nspring mvc很灵活。\n\nStruts 1的后端控制器侵入性太强，要求必须继承Action或者Action类的某个派生类。\n\n从请求(HttpServletRequest)中获取参数也使用了类型（ActionForm），所以使用起来需要记住很多类，需要封装。\n\nStrtus2 的后端控制器尽管比较灵活，但是也需要些繁琐的配置文件。后端控制器到路径的映射也是很麻烦。\n\n无论Struts哪个版本，对视图技术（view）的支持都不够强。\n\nspring 前端控制器是org.springframework.web.servlet.DispatcherServlet，导入它很简单，在web.xml中配置\n\n复习一下，web.xml中导入spring framework\n\n```xml\n<web-app>\n	<listener>\n		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n	</listener>\n\n	<context-param>\n		<param-name>contextConfigLocation</param-name>\n		<param-value>/WEB-INF/app-context.xml</param-value>\n	</context-param>\n</web-app>\n```\n\n\nweb.xml中导入前端控制器\n\n```xml\n<!-- 这个子元素必须有，Servlet容器新增加的特性，支持多模块开发 -->\n<absolute-ordering /> \n<servlet>\n	<servlet-name>app</servlet-name>\n	<servlet-class>org.springframework.web.servlet.DispatcherServlet\n	</servlet-class>\n	<init-param>\n		<param-name>contextConfigLocation</param-name>\n		<param-value></param-value>\n	</init-param>\n	<load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n	<servlet-name>app</servlet-name>\n	<url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\nurl-pattern可以写成很多形式，例如*.action, * .do，或者/app/* \n不管是什么形式，只要是访问后端控制器，那么前端控制器一定要映射到。这个url-pattern路径一定要映射到包括所有的后端控制器，当然，除了映射到后端所有的控制器，也可以映射到某些静态资源文件。\n\n先讲一下servlet组件的映射规则\na.html\n/*\n/*.html\n/\n\n如果有四个Servlet，对应的url-pattern是上面的四种形式，那么客户端任何URL，那么执行哪个Servlet?\n大家一定要把这个映射的优先级记下来。\n\n由于tomcat安装文件夹下的子文件夹conf下有一个全局的配置文件web.xml，它提供了几个Servlet组件，也配置了/和*.jsp路径。\n请记住：如果应用的web.xml文件的配置路径和tomcat的web.xml中的路径一致，那么应用程序优先，如果没有配置，那么会继承tomcat的web.xml中的配置。\n\n建议配置成拦截所有资源，但是不包括jsp文件。用户发送过来的任何请求，都视作用户动作，用户动作当然要由控制器来进行处理!!!\n!!!所以前端控制器的url-pattern应该是/，而不是/*\n\n另外，这个前端控制器DispatcherServlet也可以通过init-param加载ApplicationContext的配置文件。\n那么问题来了，ContextLoaderListener和DispatcherServlet都会创建ApplicationContext，前面创建的\n是后面创建的AppicationContext的parent，这个可以调用ApplicationContext的getParent函数获取。\n\n这个真是人为制造麻烦啊！！！\n当然有区别，DispatcherServlet和MVC有关，所以，MVC的组件可以配置在DispatcherServlet对应的配置文件中。\n而ContextLoaderListener尽量是业务逻辑对应的组件。\n不过，还是使用一个ApplicationContext吧！！！\nhttps://blog.csdn.net/zollty/article/details/86137225\n\n```xml\n<web-app>\n\n	<absolute-ordering /> \n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/root-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app1</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/app1-context.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>app1</servlet-name>\n        <url-pattern>/app1/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n\n上面的配置文件也可以，不过，不建议使用。配置文件可以有多个，可以使用*做适配符，也可以使用逗号分隔符。\n\n好了，导入了前端控制器，前端控制器收到客户端发送过来的url，它如何处理呢？\n\n可以把静态资源和后端控制器逻辑分开。例如，在配置文件中声明：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xmlns:p=\"http://www.springframework.org/schema/p\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/mvc\n	    http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n	\n	<mvc:resources mapping=\"/js/**\" location=\"/WEB-INF/js/\" />\n	<mvc:resources mapping=\"/css/**\" location=\"/WEB-INF/css/\" />\n\n</bean>\n```\n\n上面映射中的**表示支持子文件夹\n\n下面说一下，后端控制器。\nhttps://www.jianshu.com/p/84d85081c65a\nhttps://www.jianshu.com/p/0f981efdfbbd\n\nSpring的后端控制器可以使用xml配置，也可以使用注解来声明。都很简单。\n配置过程比struts1, struts2都容易一些。\n\n使用注解来定义后端控制器非常方便，后端控制器也不需要继承声明。\n\n```java\npakcage com.abc.project.controller;\n\n@Controller\npublic class MyController {\n\n}\n```\n\n在配置文件中开启mvc\n< mvc:annotation-driven />\n\n在配置文件中启动扫描组件，注意是包的名字，别写其他的，也别写适配符*\n<context:component-scan	base-package=\"com.abc.project.controller\" />\n\n那么路径到处理函数的映射？\n\n```java\n@Controller\npublic class MyController {\n	@RequestMapping(\"/calc/add\")\n	public String add(@RequestParam(value=\"v1\") String v1, @RequestParam(value=\"v2\") String v2) {\n	\n	}\n	\n	@RequestMapping(\"/calc/subtract\")\n	public String subtract(@RequestParam(value=\"v1\") String v1, @RequestParam(value=\"v2\") String v2) {\n	\n	}\n}\n```\n\n也可以是这种形式，支持模块开发\n\n```java\n@Controller\n@RequestMapping(\"/calc\")\npublic class MyController {\n	@RequestMapping(\"/add\")\n	public String add(String v1, String v2) {\n	\n	}\n	\n	@RequestMapping(\"/subtract\")\n	public String subtract(String v1, String v2) {\n	\n	}\n}\n```\n\n也支持区分不同的请求方法\n@RequestMapping(value=\"/add\", method = RequestMethod.GET)\n或者直接使用不同的注解\n@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, ...\n	\n后端控制器的函数名称没有任何要求，不过参数当然不能随意的写。\n后端控制器支持的常见参数类型列表\nHttpServletRequest, HttpServletResponse,javax.servlet.http.HttpSession\njava.util.Locale\n@PathVariable\n@RequestParam\n@RequestHeader\n@CookieValue\n@RequestBody\n@RequestPart\n\njava.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap\n\n@ModelAttribute, @SessionAttributes, @SessionAttribute, @RequestAttribute\n\n例如，常用的@RequestParam\n\n```java\npublic String add(@RequestParam(\"v1\") String v1, @RequestParam(\"v2\") String v2)\npublic String add(@RequestParam Map<String, Object> params)\n\npublic String add(@RequestBody Account account)	//直接处理JSON格式的数据，转换为Account对象了。\n                                                //如果是form表单，那么也可以是Map集合。\n```\n\nSpring对路径的支持非常灵活，支持带参数的路径，或者说模板路径\n\n```java\n@RequestMapping(\"/student/{studentid}/modify\");\n//或者下面的声明\n@RequestMapping(\"/student/modify/{studentid}\") \npublic String modify(@PathVariable String studentid) {\n\n}\n//或者下面的声明\n@RequestMapping(\"/student/modify/{studentid}\") \npublic String modify(@PathVariable(\"studentid\") String studentid) {\n\n}\n```\n\n\n\n接下来说一下controller处理函数的返回数据\n1.ModelAndView（重要）\n2.Model\n3.ModelMap\n4.Map\n5.View\n6.String\n7.void			\n8.@ResponseBody Object\n\n7返回void，那么在后端控制器处理函数中，可以直接使用重定向技术，如果没有重定向，那么\n\n6返回String，那么字符串描述的视图的逻辑名字，通过视图解析器解析为物理视图地址。\n例如 return \"index\"; return \"forward:index\"; return \"redirect: index\";\nredirect（resp，慢，session保持，两次web请求）\n和forward(req，快)有何区别？!!!\n\n5直接返回视图。\n\n4返回json数据。\n\n```java\npublic @ResponseBody Map<String, Object> add(@RequestParam String id) {\n Map<String,Object> map = new HashMap<String,Object>();\n map.put(.........);\n ......;\n return map;\n}\n```\n\nSping支持RESTful服务，对4的返回形式，可以更简单！\n\n```java\n//不用@Controller，而使用@RestController\n@RestController\npublic class MyController {\n  @RequestMapping(value=\"/add\", produces = \"application/json; charset=utf-8\")\n  public Map /* 或者其他格式的数据，只要能转JSON就可以*/ add(@RequestBody Student s) {\n\n  }\n  @RequestMapping(\"/retrieve\")\n  public Student retrieve(String id) {\n\n  }\n}\n```\n\n处理JSON编码，有更方便的办法\n\n```xml\n   <mvc:annotation-driven>\n        <mvc:message-converters> \n			<bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n				<constructor-arg value=\"UTF-8\"/>\n			</bean>\n			<bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"/>\n		</mvc:message-converters>\n	</mvc:annotation-driven>\n```\n\nModel, ModelAndView, View以后再说。\n'),(28,'List Comprehension 列表推导式',15,'2022-01-03 07:29:16','啥是函数式编程','# 引言：函数式编程\n\n[函数式编程指引](https://docs.python.org/zh-cn/3.7/howto/functional.html?highlight=list%20comprehension)\n\n编程方式：\n\n- 过程式：程序就是一连串告诉计算机怎样处理程序输入的指令。如C、Pascal、 Unix shells。\n- 声明式：编写一个用来描述待解决问题的说明，并且这个语言的具体实现会指明怎样高效的进行计算。如SQL。\n- 面向对象：程序会操作一组对象。 对象拥有内部状态，并能够以某种方式支持请求和修改这个内部状态的方法。\n- 函数式：编程则将一个问题分解成一系列函数。 理想情况下，函数只接受输入并输出结果，对一个给定的输入也不会有影响输出的内部状态。 如ML 家族（Standard ML，Ocaml 以及其他变种）和 Haskell。\n\n多范式语言：支持几种不同的编程方式。如Lisp，C++ 和 Python。\n\n带有副作用的函数：修改内部状态或引起一些无法体现在函数的返回值中的变化：\n\n- 赋值表达式：a=3 或 c = a + b\n- 显示在屏幕上：print()\n- 写到磁盘文件中\n- time.sleep()\n\n完全不产生副作用的函数被称作“纯函数”，函数式风格反对使用带有副作用的函数。\n\n函数式编程可以被认为是面向对象编程的对立面：\n\n- 面向对象编程，对象就像是颗小胶囊，包裹着内部状态和随之而来的能让你修改这个内部状态的一组调用方法，以及由正确的状态变化所构成的程序。\n- 函数式编程希望尽可能地消除状态变化，只和流经函数的数据打交道。\n\n# 生成器表达式和列表推导式\n\nGenerator expression&List Comprehension\n\n## 举例\n\n给定一个字符串列表，你可能想去掉每个字符串尾部的空白字符\n\n```python\nline_list = [\'  line 1\\n\', \'line 2  \\n\', ...]\n\n# Generator expression -- returns iterator\nstripped_iter = (line.strip() for line in line_list)\n\n# List comprehension -- returns list\nstripped_list = [line.strip() for line in line_list]\n\n#你可以加上条件语句 \"if\" 来选取特定的元素\nstripped_list = [line.strip() for line in line_list if line != \"\"]\n```\n\n## 形式\n\n```python\nexpression for expr in sequence1\n             if condition1\n             for expr2 in sequence2\n             if condition2\n             for expr3 in sequence3 ...\n             if condition3\n             for exprN in sequenceN\n             if conditionN\n              \n# 等价于\nfor expr1 in sequence1:\n    if not (condition1):\n        continue   # Skip this element\n    for expr2 in sequence2:\n        if not (condition2):\n            continue   # Skip this element\n        ...\n        for exprN in sequenceN:\n            if not (conditionN):\n                continue   # Skip this element\n\n            # Output the value of\n            # the expression.\n```\n\n这说明，如果有多个 `for...in` 语句而没有 `if` 语句，输出结果的长度就是所有序列长度的乘积。如果你的两个列表长度为3，那么输出的列表长度就是9:\n\n```python\n>>> seq1 = \'abc\'\n>>> seq2 = (1, 2, 3)\n>>> [(x, y) for x in seq1 for y in seq2]  \n[(\'a\', 1), (\'a\', 2), (\'a\', 3),\n (\'b\', 1), (\'b\', 2), (\'b\', 3),\n (\'c\', 1), (\'c\', 2), (\'c\', 3)]\n```\n\n为了不让 Python 语法变得含糊，如果 `expression` 会生成元组，那这个元组必须要用括号括起来。下面第一个列表推导式语法错误，第二个则是正确的:\n\n```\n# Syntax error\n[x, y for x in seq1 for y in seq2]\n# Correct\n[(x, y) for x in seq1 for y in seq2]\n```\n\n## 区别\n\n列表推导式：\n\n- 返回一个列表。\n- 两边使用方括号 (\"[]\")\n\n生成器表达式：\n\n- 返回一个迭代器，它在必要的时候计算结果，避免一次性生成所有的值。 这意味着，如果迭代器返回一个无限数据流或者大量的数据，列表推导式就不太好用了。 这种情况下生成器表达式会更受青睐。\n- 两边使用圆括号 (\"()\") \n\n\n'),(29,'二分查找',25,'2022-01-10 14:51:14','> 思路很简单，细节是魔鬼 																						——Knuth','## 1. 寻找一个数\n\n```Java\nint binarySearch(int[] nums, int target) {\n    int left = 0; \n    int right = nums.length - 1; // 注意\n\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(nums[mid] == target)\n            return mid; \n        else if (nums[mid] < target)\n            left = mid + 1; // 注意\n        else if (nums[mid] > target)\n            right = mid - 1; // 注意\n    }\n    return -1;\n}\n```\n\n### 搜索区间\n\n两端都闭 `[]`，故决定初始`left`、`right`的值和更新策略 \n\n### 终止条件\n\n闭区间中无元素，即left超过right ，故循环条件为`left<=right`\n\n## 2.寻找左侧边界\n\n```Java\nint left_bound(int[] nums, int target) {\n    if (nums.length == 0) return -1;\n    int left = 0;\n    int right = nums.length; // 注意\n    \n    while (left < right) { // 注意\n        int mid = (left + right) / 2;\n        if (nums[mid] == target) {\n            right = mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid; // 注意\n        }\n    }\n    return left;\n}\n```\n\n### 何为左侧边界？\n\n已经找到符合条件的值，还要继续向左找，找第一个符合条件的值。\n\n### 搜索区间\n\n左闭右开 `[ )`，若使初始区间为整个数组，`right`必须多取一位\n\n### 终止条件\n\n`left==right` ，故循环条件为`left<right`\n\n### 合并\n\n`nums[mid]>=target`\n\n### 数组中不存在target？\n\n三种情况\n\n 1. `target`比所有数都大\n\n   最终`left==right==nums.length`\n\n 2. `target`比所有数都小\n\n   最终`left==right==0`\n\n 3. `target`在数组中两数之间\n\n   最终`left==right==右边的数`\n\n当需要处理`target`不存在的情况特殊返回`-1`时，判断这三种情况：\n\n```Java\nwhile (left < right) {\n    //...\n}\n// target 比所有数都大\nif (left == nums.length) return -1;\n// target 比所有数都小\nif (left == 0) return -1;\n// target 在数组中两数之间\nif (nums[left] != target) return -1;\nreturn left;\n```\n\n报错：\n\n![image-20210613105717885](http://cdn.moyusoldier.cn/image-20210613105717885.png)\n\n很明显，此时`left==right==0`，走了第二个`if`返回`-1`，报错的原因在于\n\n`target 比所有数都小` 是 `left == 0`的充分不必要条件，如何修改？\n\n```Java	\nwhile (left < right) {\n    //...\n}\nif (left == nums.length) return -1;\nreturn nums[left] == target ? left : -1;\n```\n\n## 3.寻找右侧边界\n\n```Java\nint right_bound(int[] nums, int target) {\n    if (nums.length == 0) return -1;\n    int left = 0, right = nums.length;\n    \n    while (left < right) {\n        int mid = (left + right) / 2;\n        if (nums[mid] == target) {\n            left = mid + 1; // 注意\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid;\n        }\n    }\n    return left - 1; // 注意\n}\n```\n\n### 返回值\n\n`left-1`，最后一次判断时`left=mid+1`，`mid`为要返回的值，而`left==right`在`mid`的右边一位，故返回值减去1\n\n### 数组中不存在target？\n\n```java\nwhile (left < right) {\n    // ...\n}\nif (left == 0) return -1;\nreturn nums[left-1] == target ? (left-1) : -1;\n```\n\n'),(30,'QQ自动续火花脚本[完结版]',33,'2022-01-27 12:41:30','为了「聊的燚燚 N」而努力！','# 一、背景\n\n## 1. 现状\n\n在QQ上，只要好友间连续互发信息超过七天，即可擦出「火花」标识，以此**象征友情升温**。\n\n火花的最终形态是与好友互发消息连续超过200天后获得「聊的燚燚」，进而以「粉色火花+N」标识的「聊的燚燚N」样式。\n\n<p align=\"center\" >\n<img src=\"http://cdn.moyusoldier.cn/image-20220127202307558.png\" height=400px/>\n</p>\n\n\n猪猪与我从恋爱开始的最高记录为「聊的燚燚14」，之后由于转用微信，相约每天以互相发送“花花”字段的方式续火花，但由于猪猪总忘记，目前的火花等级已经降到「聊的燚燚」，大危机！！！\n\n## 2. 机会\n\n思路：编写跑在服务器上的互相发送消息脚本，实现每日都能自动续上火花\n\n# 二、目标\n\n「聊的燚燚N」从代码跑起来的那天开始一直续火花到腾讯倒闭那天\n\n#  三、方案\n\n## 1. 调研\n\n[QQ机器人的前世今生](https://zhuanlan.zhihu.com/p/348381026)\n\n## 2. 方案\n\n拟基于目前QQ机器人的主流框架的[go-cqhttp](https://github.com/Mrs4s/go-cqhttp)+[NoneBot2](https://github.com/nonebot/nonebot2) 实现\n\n## 3.使用方法及源码\n\n戳此[github链接查看详情](https://github.com/25252www/nonebot_plugin_fire)\n\n同时，可以在Nonebot2插件商店一键下载\n\n<p align=\"center\" >\n<img src=\"http://cdn.moyusoldier.cn/image-20220307203837671.png\" height=400px/>\n</p>\n\n\n\n# 四、效果\n\n\n<p align=\"center\" >\n<img src=\"http://cdn.moyusoldier.cn/%E6%88%AA%E5%B1%8F2022-03-07%20%E4%B8%8A%E5%8D%8810.38.56.png\" height=150px/>\n</p>\n\n\n'),(31,'rpc&grpc',26,'2022-02-02 06:08:23','远程过程调用','# 1. [rpc](https://en.wikipedia.org/wiki/Remote_procedure_call)\n\n## 1.1 简介\n\nrpc是remote procedure call简称，既远程过程调用。远程就是指跨机器而非本机，那么就需要用到网络编程才能实现。那么是不是只要通过网络通信访问另外一台机器的应用程序，就可以称为RPC调用了？显然并不够。\n\n我理解的rpc是帮我们屏蔽网络编程细节，实现调用远程方法如调用本地方法一样简单，不需要因为这个方法是远程调用而编写很多和业务无关的代码。\n\n## 1.2 rpc与http？\n\n广义：rpc是一种思想，http是实现rpc的一种方式，grpc的传输就是使用了rpc协议。\n\n狭义：gRPC、dubbo、Thrift等rpc框架。\n\n## 1.3 rpc与微服务？\n\n在微服务的设计中，一个服务A如果访问另一个Module下的服务B，通过网络传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。\n\n![img](http://cdn.moyusoldier.cn/webp)\n\n## 1.4 序列化与反序列化\n\n内存<=>传输（文本，byte[]）\n\n序列化方式：[JSON](https://www.json.org/json-en.html)，XML（文本化效率较低），Java 自带序列化，Protocol Buffer等\n\n## 1.5 网络IO\n\ndubbo使用netty作为网络传输框架，netty基于java NIO，NIO操作系统调用\n\n# 2. [grpc](https://grpc.io/)\n\n## 2.1 简介\n\n在 gRPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一样，使您更容易创建分布式应用程序和服务。\n\n与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以远程调用的方法及其参数和返回类型。\n\n在Server端实现这个接口并运行一个 gRPC 服务来处理Client端调用。\n\n在Client端有一个桩（在某些语言中仅有客户端），它提供与服务器相同的方法。\n\n![landing-2](http://cdn.moyusoldier.cn/landing-2.svg)\n\n\n\n\n\n## 2.1 [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview)\n\n默认情况下，gRPC 使用Protocol Buffers, 这是谷歌的结构化数据序列化开源机制（它可以与其他数据格式如 JSON 一起使用）。\n\n### 1.定义message\n\n使用protocol buffers的第一步是定义要在`.proto`文件中序列化的数据结构：这是一个带有`.proto`扩展名的普通文本文件。语言版本一般采用proto3。\n\nprotocol buffers的数据被构造为 `message`，包含一系列字段(`key-value`对)。\n\n```protobuf\nmessage Person {\n  string name = 1;\n  int32 id = 2;\n  bool has_ponycopter = 3;\n}\n```\n\n然后，使用protocol buffers的编译器`protoc`从`.proto`文件中以你喜欢的语言生成代码。\n\n对于 Golang，编译器生成一个 `.pb.go` 文件， 文件中对于每个message都生成对应的结构体。\n\n### 2. 定义service\n\n通常，在`.proto`文件中将服务定义为 gRPC service，将 rpc 方法参数和返回值类型定义为protocol buffer messages：\n\n```protobuf\n// The greeter service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user\'s name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n'),(32,'使用cv2&PIL.Image&gdal图像读写记录',14,'2022-04-24 04:50:14','注意shape和channel顺序','# 0. 基本原则\n\n- (h,w,c) 叫image\n- (c,h,w) 叫tensor\n\n# 1. cv2\n\n- import cv2\n\n## read\n\ncv2.imread()  得到(h,w c) 其中c的顺序为BGR 返回类型为np.array\n\n## write\n\ncv2.imwrite() 得到(h,w,c) 其中c的顺序为RGB \n\n## 通道转换\n\ncv2读的图像想用Image/gdal保存\n\n```\n# 从BGR通道转成RGB，便于之后保存成tiff格式\nim_B=cv2.cvtColor(im_B,cv2.COLOR_BGR2RGB)\n```\n\n# 2. Image\n\n- from PIL import Image\n\n## read\n\nImage.open() 得到(h,w,c) 其中c的顺序为RGB 返回类型为Image对象\n\n## write\n\nImage.save()  得到(h,w,c) 其中c的顺序为RGB \n\n\n\n# 3. gdal\n\n- import gdal\n\n## read\n\n```python\nsarimg = gdal.Open(image)\nproj = sarimg.GetProjection()\ngeo = sarimg.GetGeoTransform()\nsarimg = sarimg.ReadAsArray().astype(np.float32)\n# shape = (c,h,w)\nsarimg = np.swapaxes(sarimg,0,2)\nsarimg = np.swapaxes(sarimg,0,1)\n# sarimg shape变为(h, w, c)\n```\n\nReadAsArray返回(c,h,w)\n\n```python\ndef raster2array(rasterfn):\n    raster = gdal.Open(rasterfn)\n    band = raster.GetRasterBand(1)\n    array = band.ReadAsArray()\n    # array = band.ReadAsArray().astype(numpy.float)\n    return array\n```\n\n遍历所有band\n\n```python\nfrom osgeo import gdal\nimport sys\n\nsrc_ds = gdal.Open( \"INPUT.tif\" )\nif src_ds is None:\n    print \'Unable to open INPUT.tif\'\n    sys.exit(1)\n\nprint \"[ RASTER BAND COUNT ]: \", src_ds.RasterCount\nfor band in range( src_ds.RasterCount ):\n    band += 1\n    print \"[ GETTING BAND ]: \", band\n    srcband = src_ds.GetRasterBand(band)\n    if srcband is None:\n        continue\n\n    stats = srcband.GetStatistics( True, True )\n    if stats is None:\n        continue\n\n    print \"[ STATS ] =  Minimum=%.3f, Maximum=%.3f, Mean=%.3f, StdDev=%.3f\" % ( \\\n                stats[0], stats[1], stats[2], stats[3] )\n```\n\n## write\n\n```python\ndef create_multiband_geotiff(array, out_name, proj, geo, nodata=0, out_format=gdal.GDT_Byte, verbose=False):\n    \"\"\"Convert an array to an output georegistered geotiff.\n    Arguments\n    ---------\n    array : numpy array\n        A numpy array with a the shape: [Channels, X, Y] or [X, Y]\n    out_name : str\n        The output name and path for your image\n    proj : gdal projection\n        A projection, can be extracted from an image opened with gdal with image.GetProjection().  Can be set to None if no georeferencing is required.\n    geo : gdal geotransform\n        A gdal geotransform which indicates the position of the image on the earth in projection units. Can be set to None if no georeferencing is required.\n        Can be extracted from an image opened with gdal with image.GetGeoTransform()\n    nodata : int, default - 0\n        A value to set transparent for GIS systems. Can be set to None if the nodata value is not required.\n    out_format : gdalconst\n        https://gdal.org/python/osgeo.gdalconst-module.html\n        Must be one of the variables listed in the docs above\n    verbose : bool\n        A verbose output, printing all inputs and outputs to the function.  Useful for debugging.\n    \"\"\"\n    driver = gdal.GetDriverByName(\'GTiff\')\n    # 如果shape为(900,900),则转换为(1,900,900)\n    if len(array.shape) == 2:\n        array = array[np.newaxis, ...]\n        # print(\"np.shape==2\")\n        # print(\"shape after shape \", np.shape(array))\n        # print(\"array after shape\",array)\n    os.makedirs(os.path.dirname(os.path.abspath(out_name)), exist_ok=True)\n    # 这步只是创建图像（存储空间已经被分配到硬盘上了），之后才往图像里写数据\n    # GDALDataType的默认类型为GDT_Byte\n    dataset = driver.Create(out_name, array.shape[2], array.shape[1], array.shape[0], out_format)\n    if verbose is True:\n        print(\"Array Shape, should be [Channels, X, Y] or [X,Y]:\", array.shape)\n        print(\"Output Name:\", out_name)\n        print(\"Projection:\", proj)\n        print(\"GeoTransform:\", geo)\n        print(\"NoData Value:\", nodata)\n        print(\"Bit Depth:\", out_format)\n    if proj is not None:\n        dataset.SetProjection(proj)\n    if geo is not None:\n        dataset.SetGeoTransform(geo)\n    if nodata is None:\n        for i, image in enumerate(array, 1):\n            dataset.GetRasterBand(i).WriteArray(image)\n        del dataset\n    else:\n        for i, image in enumerate(array, 1):  # 下标从 1 开始\n            # print(\"i\",i)\n            # print(type(image))\n            dataset.GetRasterBand(i).WriteArray(image)\n            dataset.GetRasterBand(i).SetNoDataValue(nodata)\n        del dataset\n```\n\n```python\n# 保存Fused图像\ncreate_multiband_geotiff(eo_sar_fusion, output_image, proj, geo, nodata=nodata)\n# 保存SPAN图像\ncreate_multiband_geotiff(span_img_origin, span_output_image, proj, geo, nodata=nodata, out_format=gdal.GDT_Float32)\n```\n\ncreate_multiband_geotiff的array输入(c,h,w)'),(33,'定期备份MySQL到 github',11,'2022-04-25 03:52:26','mysqldump+cron','\n\n## 备份\n\n进入docker容器\n\n```bash\n# 899为CONTAINER ID, moyublog_mysql_1为NAMES\ndocker exec -it 899 /bin/bash\n# 或者\ndocker exec -it moyublog_mysql_1 /bin/bash\n```\n\n备份数据库\n\n```bash\nmysqldump -u root -pyourpwd --all-databases >  backupsql_`date +%F`.sql\n```\n\n退出docker容器\n\n```bash\nexit\n```\n\ncopy到容器外\n\n```bash\ndocker cp moyublog_mysql_1:emp_`date +%F`.sql ./\n```\n\n## 合成一句话\n\n```\ndocker exec moyublog_mysql_1 sh -c \'exec mysqldump --all-databases -u root -pyourpwd --all-databases\' > ~/MoyuBlog-DataBase-BackUp/backupsql_`date +%F`.sql\n```\n\n## 创建github仓库\n\n```\nssh-keygen -t ed25519 -C \"1433221642@qq.com\"\n```\n\n```\ngit clone git@github.com:25252www/MoyuBlog-DataBase-BackUp.git\n```\n\n## 写成shell\n\n~/moyublog/backupsql.sh\n\n```shell\n#!/bin/bash\ndocker exec moyublog_mysql_1 sh -c \'exec mysqldump -u root -pyourpwd --all-databases\' > ~/MoyuBlog-DataBase-BackUp/backupsql_`date +%F`.sql\ncd ~/MoyuBlog-DataBase-BackUp\nfind ./ -mtime +30 -name \"*.sql\" -exec git rm {} \\;\ngit add backupsql_`date +%F`.sql\ngit commit -m \"backupsql_`date +%F`\"\ngit push\n```\n\n赋予脚本执行权限\n\n```\nchmod 777 backupsql.sh\n```\n\n## crontab定时执行\n\n```shell\ncrontab -e\n#进入编辑界面\n0 2 * * * ~/moyublog/backupsql.sh\n```\n\n\n\n\n\n\n\n\n\n'),(34,'HRNet',5,'2022-07-14 03:39:35','一份不简洁也不详细的HRNet阅读笔记\n（Deep High-Resolution Representation Learning for Visual Recognition）','论文地址：https://arxiv.org/pdf/1908.07919.pdf\n\n视频讲解：https://www.bilibili.com/video/BV1ZZ4y1R7m6?spm_id_from=333.337.search-card.all.click\n\n论文复现：https://www.bilibili.com/video/BV1vL411H78u?spm_id_from=333.337.search-card.all.click&vd_source=7654ff6123e699d77f03256112271e3f\n\n# 1 Introduction&Related work\n\n该论文拟解决视觉任务中的高分辨率**表征学习**问题。\n\n该论文是会议论文：（https://readpaper.com/paper/2916798096，仅仅做了姿态估计的实验）的推广。\n\n![image-20220713215255520](https://cdn.moyusoldier.cn/image-20220713215255520.png)\n\n表征学习分为高分辨率表征学习和低分辨率表征学习。\n\n对于分类问题，位置不敏感，不需要高分辨率表征。\n\n对于检测、分割、面部对齐、姿态估计等问题，位置敏感，需要高分辨率表征。\n\n![image-20220713215813142](https://cdn.moyusoldier.cn/image-20220713215813142.png)\n\n经典的神经网络学习的都是低分辨率表征。\n\n结构特点：一系列从高分辨率卷积到低分辨率卷积的卷积层串联起来\n\n例如：AlexNet, VGGNet, GoogLeNet, ResNet, DenseNet\n\n![image-20220713220225465](https://cdn.moyusoldier.cn/image-20220713220225465.png)\n\n怎么把分类的网络推广到高分辨率表征学习的问题里面？两大类方法\n\n第一类方法：\n\n把最后一个stage里面的下采样和卷积换成空洞卷积，这样最后一个stage不用下采样，保持分辨率不变，问题在于计算量大。\n\n![image-20220713220600911](https://cdn.moyusoldier.cn/image-20220713220600911.png)\n\n第二类方法：\n\n上采样。如U-Net, SegNet, DeConvNet, Hourglass。\n\n问题：位置敏感度不够，毕竟下采样过程丢失了位置敏感度。\n\n# 2 Method\n\n![image-20220713220953178](https://cdn.moyusoldier.cn/image-20220713220953178.png)\n\n## 2.1 Idea\n\n- 通过更强的位置敏感度学习高分辨率表征\n- 整个过程都维护高分辨率表征，而不是从低分辨率表征恢复\n- 从零开始设计网络，而不是延用经典网络\n\n\n\n## 2.2 网络结构\n\n![1](https://cdn.moyusoldier.cn/1.png)\n\n我们将图片输入一个Stem（由两个s=2 的3*3卷积构成），将分辨率降到1/4，输入到main body，main body以相同分辨率（1/4）输出表征。\n\nmain body由三个部分组成：并行多分辨率卷积流、重复地多分辨率交互、表征头。\n\n### 2.2.1 并行多分辨率卷积流\n\n（也称并行多分辨率子网络）\n\n将高分辨率子网络作为第一个阶段（1 branch），逐步将高分辨率子网络添加到低分辨率子网络，形成新的阶段。\n\n后一阶段的分辨率由前一阶段的分辨率和一个较低（1/2）的分辨率组成。\n\n如上图`stage传播流程示意`。Nsr代表一个子网络，s代表阶段，r为分辨率索引，代表分辨率为第一个阶段的1/2^(r-1)。\n\n### 2.2.2 重复地多分辨率交互\n\n交互的目的是跨分辨率交换表征信息。\n\n如上图`多尺度融合流程示意`。以从阶段3到阶段4为例：\n\n输入由三个表征组成 {Rir, r = 1, 2, 3}，其中r为分辨率索引。相关的输出为 {Ror, r = 1, 2, 3}。每个输出表征是三个转换后的输入表征的总和Ror = f1r(Ri1)+f2r(Ri2)+f3r(Ri3)。\n\n跨多个stage的融合还有一个额外的输出Ro4 = f14(Ri1) + f24(Ri2) + f34(Ri3)。转换函数fxr(·)的选择有输入分辨率索引x和输入分辨率索引r决定，\n\n- 当x = r时，fxr(R) = R\n- 当x<r时，fxr(R)对表征R进行下采样，通过r-s个s=2的3*3卷积\n- 当x>r时，fxr(R)对表征R进行双线性上采样，然后通过1*1卷积对其通道数\n\n### 2.2.3 表征头\n![2](https://cdn.moyusoldier.cn/2.png)\n\n有三种表征头，分别称为HRNetV1、HRNetV2和HRNetV2p。\n\n- HRNetV1：输出仅来自高分辨率卷积流，忽略其它三种表征。\n- HRNetV2：通过双线性上采样重新缩放低分辨率表征，而不将通道数更改为高分辨率流的通道数，并连接四种表征，然后进行1*1卷积以混合四种表征。\n- HRNetV2P： 通过将HRNetV2的高分辨率表征输出降采样到多个级别来构造多级表示。\n\n## 2.3 小结\n\n![image-20220714112736421](https://cdn.moyusoldier.cn/image-20220714112736421.png)\n\n- 并联结构\n- 保持高分辨率表征\n- 重复地多分辨率融合\n\n![image-20220714112820969](https://cdn.moyusoldier.cn/image-20220714112820969.png)\n\n出发点不同：针对更为广泛的视觉任务，比较universal\n\n# 3 实验\n\n![image-20220714112902421](https://cdn.moyusoldier.cn/image-20220714112902421.png)'),(35,'STL源码剖析1-STL概论与版本简介',3,'2022-10-22 12:39:17','STL源码剖析','# 1 历史\n\n1994年，Alexander Stepanov和Meng Lee带着他们创造的STL获得了C++标准委员会80%的赞成，STL进入了C++标准化的正式流程。\n\n1998年，STL成为1998年9月定案的C++标准规格中C++标准程序库的一部分。\n\n更多有趣的故事请搜索《STL之父访问录》。\n\n# 2 STL六大组件\n\n1. 容器（container）：各种用来存放数据的数据结构，分为序列式容器和关联式容器。从实现的角度来看，STL容器是一种class template（类模板）。\n2. 算法（algorithm）：是一种function template（函数模板）。\n3. 迭代器（iterator）：容器和算法之间的桥梁，是一种泛化的指针。共分为五类。从实现的角度来看，迭代器是一种将`operator*`, `operator->`, `operator++`, `operator--`等指针操作进行运算符重载的class template。所有的STL容器都有自己专属的迭代器，只有容器设计者才知道如何遍历自己的元素。原生指针也是一种迭代器。\n4. 仿函数（functor）：行为类似函数。从实现的角度，是一种重载了`operator()`的class或class template，一般函数指针可视为侠义的仿函数。 \n5. 适配器（adapter）：一种用来修饰容器、迭代器、仿函数接口的东西。思想属于设计模式中的“适配器模式“。如stack只是包含一个deque，并转调用deque的接口，属于容器适配器（container adapter）。\n6. 空间配置器（allocator）：负责空间配置和管理。从实现角度，是一种实现了动态空间配置、空间管理、空间释放的class template。\n\n![img](https://cdn.moyusoldier.cn/f515e3ab95c9f5c4f039da3b726de9ea.png)\n\n# 3 GNU源代码开放精神\n\n## 3.1 GNU\n\nGNU是一个类UNIX的自由软件操作系统—用户可以自由地运行，拷贝，分发，学习，修改并改进该软件。\n\nGNU操作系统包括GNU软件包（专门由GNU工程发布的程序）和由第三方发布的自由软件。\n\n“GNU”这个名字是“GNU\'s Not Unix”的递归首字母缩写词。\n\n## 3.2 GCC\n\nGCC是GNU早期最著名的软件，是一个C/C++编译器。\n\n# 4 STL版本\n\n## 4.1 版本概述\n\n自 1998 年 ANSI/ISO C++ 标准正式定案，C++ STL规范版本正式通过以后，由于其开源特性，各个 C++ 编译器厂商在此标准的基础上，实现了满足自己需求的 C++ STL 泛型库，主要包括 HP STL、SGI STL、STLport、PJ STL、Rouge Wave STL 等。\n\nSGI STL实现版本：由Silicon Graphics Computer Systems.Inc公司发展，继承HP版本。该版本被GCC采用，可以在GCC编译器的“include”子目录下（例如C:\\cygnus\\cygwin-b20\\include\\g++）找到所有STL头文件。\n\n## 4.2 本书分析的STL版本\n\n本书分析的是**GCC编译器**所采用的SGI STL版本，具体版本为 Cygnus C++ 2.9.1 for Windows。\n\n现在已经不能在网上找到该版本对应的编译器（至少我没找到），想要学习的小伙伴可以从我的[github仓库](https://github.com/25252www/Cygnus-Cplusplus-2.91-for-Windows)直接下载源码。\n\n# 5 stl_config.h\n\n## 5.1 C++的不同编译器\n\n目前的主流编译器信息（从[这里](https://isocpp.org/get-started)获取）：\n\n- ***[Gnu Compiler Collection](http://gcc.gnu.org/)***: Includes g++, a popular C++ compiler. A build for Windows is available [here](http://nuwen.net/mingw.html), builds for other platforms are likely available via your platform’s package manager, or you can build it yourself using instructions [here](http://gcc.gnu.org/install/).\n- [***Clang***](http://clang.llvm.org/get_started.html): A new open-source C++ compiler for various platforms.\n- ***[Visual C++ 2017 Community](https://www.visualstudio.com/vs/cplusplus/)***: A free Windows C++ compiler by Microsoft.\n- *[**Embarcadero:**](https://www.embarcadero.com/free-tools/ccompiler)* A free Clang-based C++ compiler by Embarcadero.\n- [***Oracle Solaris Studio C++ Compiler***](http://www.oracle.com/technetwork/server-storage/solarisstudio/overview/index.html): A C++ compiler for Solaris and some distributions of Linux, free for all commercial and non-commercial use.\n- ***[IBM XL C/C++ Compiler](https://www.ibm.com/us-en/marketplace/xl-cpp-linux-compiler-power)***: A Clang-based Community Edition is available for Linux on Power, free for production use.\n\n此外，还有本书经常被提到的VC6编译器。\n\n## 5.2 配置文件\n\n由于不同编译器对C++语言的支持程度不同，作为一个希望被广泛移植的程序库，SGI STL准备了一个配置文件<stl_config.h>用来适配不同的编译器环境。\n\n源码（stl_config.h）\n\n```c++\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * Copyright (c) 1997\n * Silicon Graphics\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n */\n\n#ifndef __STL_CONFIG_H\n# define __STL_CONFIG_H\n\n// What this file does.\n//  (1)  Defines bool, true, and false if the compiler doesn\'t do so already.\n//  (2)  Defines __STL_NO_DRAND48 if the compiler\'s standard library does\n//       not support the drand48() function.\n//  (3)  Defines __STL_STATIC_TEMPLATE_MEMBER_BUG if the compiler can\'t \n//       handle static members of template classes.\n//  (4)  Defines \'typename\' as a null macro if the compiler does not support\n//       the typename keyword.\n//  (5)  Defines __STL_CLASS_PARTIAL_SPECIALIZATION if the compiler \n//       supports partial specialization of class templates.\n//  (6)  Defines __STL_FUNCTION_TMPL_PARTIAL_ORDER if the compiler supports\n//       partial ordering of function templates (a.k.a partial specialization\n//       of function templates.\n//  (7)  Defines __STL_EXPLICIT_FUNCTION_TMPL_ARGS if the compiler\n//       supports calling a function template by providing its template\n//       arguments explicitly.\n//  (8)  Defines __STL_MEMBER_TEMPLATES if the compiler supports\n//       template members of classes.\n//  (9)  Defines \'explicit\' as a null macro if the compiler does not support\n//       the explicit keyword.    \n//  (10) Defines __STL_LIMITED_DEFAULT_TEMPLATES if the compiler is\n//       unable to handle default template parameters that depend on\n//       previous template parameters.\n//  (11) Defines __STL_NON_TYPE_TMPL_PARAM_BUG if the compiler has \n//       trouble performing function template argument deduction for\n//       non-type template parameters.\n//  (12) Defines __SGI_STL_NO_ARROW_OPERATOR if the compiler is unable\n//       to support the -> operator for iterators.\n//  (13) Defines __STL_USE_EXCEPTIONS if the compiler (in the current\n//       compilation mode) supports exceptions.\n//  (14) Define __STL_USE_NAMESPACES if we\'re putting the STL into a \n//       namespace.  \n//  (15) Defines __STL_SGI_THREADS if this is being compiled on an SGI\n//       compiler, and if the user hasn\'t selected pthreads or no threads\n//       instead.\n//  (16) Defines __STL_WIN32THREADS if this is being compiled on a \n//       WIN32 compiler in multithreaded mode.\n//  (17) Define namespace-related macros (__STD, __STL_BEGIN_NAMESPACE, etc.)\n//       apropriately.\n//  (18) Define exception-related macros (__STL_TRY, __STL_UNWIND, etc.)\n//       appropriately.\n//  (19) Defines __stl_assert either as a test or as a null macro,\n//       depending on whether or not __STL_ASSERTIONS is defined.\n\n#ifdef _PTHREADS\n#   define __STL_PTHREADS\n#endif\n\n# if defined(__sgi) && !defined(__GNUC__)\n// 使用SCI STL 但却不使用GNU C++\n#   if !defined(_BOOL)\n#     define __STL_NEED_BOOL\n#   endif\n#   if !defined(_TYPENAME_IS_KEYWORD)\n#     define __STL_NEED_TYPENAME\n#   endif\n#   ifdef _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES\n#     define __STL_CLASS_PARTIAL_SPECIALIZATION\n#   endif\n#   ifdef _MEMBER_TEMPLATES\n#     define __STL_MEMBER_TEMPLATES\n#   endif\n#   if !defined(_EXPLICIT_IS_KEYWORD)\n#     define __STL_NEED_EXPLICIT\n#   endif\n#   ifdef __EXCEPTIONS\n#     define __STL_USE_EXCEPTIONS\n#   endif\n#   if (_COMPILER_VERSION >= 721) && defined(_NAMESPACES)\n#     define __STL_USE_NAMESPACES\n#   endif \n#   if !defined(_NOTHREADS) && !defined(__STL_PTHREADS)\n#     define __STL_SGI_THREADS\n#   endif\n# endif\n\n# ifdef __GNUC__\n#   include <_G_config.h>\n#   if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8)\n#     define __STL_STATIC_TEMPLATE_MEMBER_BUG\n#     define __STL_NEED_TYPENAME\n#     define __STL_NEED_EXPLICIT\n#   else\n#     define __STL_CLASS_PARTIAL_SPECIALIZATION\n#     define __STL_FUNCTION_TMPL_PARTIAL_ORDER\n#     define __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n#     define __STL_MEMBER_TEMPLATES\n#   endif\n    /* glibc pre 2.0 is very buggy. We have to disable thread for it.\n       It should be upgraded to glibc 2.0 or later. */\n#   if !defined(_NOTHREADS) && __GLIBC__ >= 2 && defined(_G_USING_THUNKS)\n#     define __STL_PTHREADS\n#   endif\n#   ifdef __EXCEPTIONS\n#     define __STL_USE_EXCEPTIONS\n#   endif\n# endif\n\n# if defined(__SUNPRO_CC) \n#   define __STL_NEED_BOOL\n#   define __STL_NEED_TYPENAME\n#   define __STL_NEED_EXPLICIT\n#   define __STL_USE_EXCEPTIONS\n# endif\n\n# if defined(__COMO__)\n#   define __STL_MEMBER_TEMPLATES\n#   define __STL_CLASS_PARTIAL_SPECIALIZATION\n#   define __STL_USE_EXCEPTIONS\n#   define __STL_USE_NAMESPACES\n# endif\n\n# if defined(_MSC_VER)\n#   if _MSC_VER > 1000\n#     include <yvals.h>\n#   else\n#     define __STL_NEED_BOOL\n#   endif\n#   define __STL_NO_DRAND48\n#   define __STL_NEED_TYPENAME\n#   if _MSC_VER < 1100\n#     define __STL_NEED_EXPLICIT\n#   endif\n#   define __STL_NON_TYPE_TMPL_PARAM_BUG\n#   define __SGI_STL_NO_ARROW_OPERATOR\n#   ifdef _CPPUNWIND\n#     define __STL_USE_EXCEPTIONS\n#   endif\n#   ifdef _MT\n#     define __STL_WIN32THREADS\n#   endif\n# endif\n\n# if defined(__BORLANDC__)\n#   define __STL_NO_DRAND48\n#   define __STL_NEED_TYPENAME\n#   define __STL_LIMITED_DEFAULT_TEMPLATES\n#   define __SGI_STL_NO_ARROW_OPERATOR\n#   define __STL_NON_TYPE_TMPL_PARAM_BUG\n#   ifdef _CPPUNWIND\n#     define __STL_USE_EXCEPTIONS\n#   endif\n#   ifdef __MT__\n#     define __STL_WIN32THREADS\n#   endif\n# endif\n\n\n# if defined(__STL_NEED_BOOL)\n    typedef int bool;\n#   define true 1\n#   define false 0\n# endif\n\n# ifdef __STL_NEED_TYPENAME\n#   define typename\n# endif\n\n# ifdef __STL_NEED_EXPLICIT\n#   define explicit\n# endif\n\n# ifdef __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n#   define __STL_NULL_TMPL_ARGS <>\n# else\n#   define __STL_NULL_TMPL_ARGS\n# endif\n\n# ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n#   define __STL_TEMPLATE_NULL template<>\n# else\n#   define __STL_TEMPLATE_NULL\n# endif\n\n// __STL_NO_NAMESPACES is a hook so that users can disable namespaces\n// without having to edit library headers.\n# if defined(__STL_USE_NAMESPACES) && !defined(__STL_NO_NAMESPACES)\n#   define __STD std\n#   define __STL_BEGIN_NAMESPACE namespace std {\n#   define __STL_END_NAMESPACE }\n#   define  __STL_USE_NAMESPACE_FOR_RELOPS\n#   define __STL_BEGIN_RELOPS_NAMESPACE namespace std {\n#   define __STL_END_RELOPS_NAMESPACE }\n#   define __STD_RELOPS std\n# else\n#   define __STD \n#   define __STL_BEGIN_NAMESPACE \n#   define __STL_END_NAMESPACE \n#   undef  __STL_USE_NAMESPACE_FOR_RELOPS\n#   define __STL_BEGIN_RELOPS_NAMESPACE \n#   define __STL_END_RELOPS_NAMESPACE \n#   define __STD_RELOPS \n# endif\n\n# ifdef __STL_USE_EXCEPTIONS\n#   define __STL_TRY try\n#   define __STL_CATCH_ALL catch(...)\n#   define __STL_RETHROW throw\n#   define __STL_NOTHROW throw()\n#   define __STL_UNWIND(action) catch(...) { action; throw; }\n# else\n#   define __STL_TRY \n#   define __STL_CATCH_ALL if (false)\n#   define __STL_RETHROW \n#   define __STL_NOTHROW \n#   define __STL_UNWIND(action) \n# endif\n\n#ifdef __STL_ASSERTIONS\n# include <stdio.h>\n# define __stl_assert(expr) \\\n    if (!(expr)) { fprintf(stderr, \"%s:%d STL assertion failure: %s\\n\", \\\n			  __FILE__, __LINE__, # expr); abort(); }\n#else\n# define __stl_assert(expr)\n#endif\n\n#endif /* __STL_CONFIG_H */\n\n// Local Variables:\n// mode:C++\n// End:\n\n```\n\n'),(36,'STL源码剖析2-空间配置器',1,'2022-10-22 12:40:00','STL源码剖析','\n\n# 1 概述\n\n空间配置器（allocator）是隐藏在容器背后默默付出的组件，在使用容器时感受不到空间配置器的存在，但其是实现容器的基础。\n\n本节主要讨论：\n\n- 构造和析构\n- 内存申请和释放（通过空间配置器进行内存管理）\n\n## 1.1 new expression\n\n一般而言，我们所熟知的内存操作是这样的\n\n```c++\nclass Foo{};\n\nint main() {\n    Foo *p = new Foo; \n    delete p;\n}\n```\n\n执行一个new expression有两个步骤：\n\n1. 调用`operator new`申请内存\n2. 调用`Foo::Foo()`构造对象\n\n执行一个delete expression有两个步骤：\n\n1. 调用`Foo::~Foo()`析构对象\n2. 调用`operator delete`释放内存\n\n## 1.2 相关文件\n\n三个文件，均包含于`<memory>`中：\n\n- `<stl_construct.h>`：定义了全局的`construct()`和`destroy()`函数，负责对象的构造和析构。\n- `<stl_alloc.h>`：定义了空间配置器，用于内存管理。\n- `<stl_unitialized.h>`：定义了一些全局函数，用来填充（fill）或复制（copy）大块内存数据，如`un_initialized_copy()`、`un_initialized_fill()`、`un_initialized_fill_n()`\n\n## 1.3 容器和“构造和析构”、“内存申请和释放”\n\nSTL将容器的这两个任务清晰地分隔开：\n\n- 由空间配置器负责“内存的申请和释放”任务，提升内存管理的效率。\n- 由“5个全局构造和析构函数”负责“内存申请和释放”的前后对象的构造和析构任务，全局构造函数（`construct()`、`un_initialized_copy()`、`un_initialized_fill()`、`un_initialized_fill_n()`）不参与内存配置，全局析构函数（`destroy()`）可能参与。\n\n如list：\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\nprotected:\n  // 根据传入的参数Alloc定义一个allocator  \n  typedef simple_alloc<list_node, Alloc> list_node_allocator;\n    \nprotected:\n  // 通过allocator申请内存  \n  link_type get_node() { return list_node_allocator::allocate(); }\n  // 通过allocator释放内存  \n  void put_node(link_type p) { list_node_allocator::deallocate(p); }\n\n  link_type create_node(const T& x) {\n    // 1. 申请内存  \n    // 申请一块list_node大小的内存，并返回指针  \n    link_type p = get_node();\n    __STL_TRY {\n      // 2. 构造  \n      // 调用placement new，把x放置到list_node->data的位置\n      construct(&p->data, x);\n    }\n    __STL_UNWIND(put_node(p));\n    return p;\n  }\n  void destroy_node(link_type p) {\n    // 1. 析构 \n    destroy(&p->data);\n    // 2. 释放内存  \n    put_node(p);\n  }\n    \nprotected:\n  void empty_initialize() { \n    node = get_node();\n    node->next = node;\n    node->prev = node;\n  }    \n    \npublic:\n  // list的构造函数\n  list() { empty_initialize(); }    \n  void clear();\n  iterator insert(iterator position, const T& x) {\n    link_type tmp = create_node(x);\n    tmp->next = position.node;\n    tmp->prev = position.node->prev;\n    (link_type(position.node->prev))->next = tmp;\n    position.node->prev = tmp;\n    return tmp;\n  }\n    \n  // list的析构函数  \n  ~list() {\n    clear();\n    put_node(node);\n  }\n};\n\ntemplate <class T, class Alloc> \nvoid list<T, Alloc>::clear()\n{\n  link_type cur = (link_type) node->next;\n  while (cur != node) {\n    link_type tmp = cur;\n    cur = (link_type) cur->next;\n    destroy_node(tmp);\n  }\n  node->next = node;\n  node->prev = node;\n}\n```\n\n# 2 全局构造和析构函数\n\nSTL定义了五个全局函数构造析构函数，包括`construct`和`destroy`，以及用于批量构造的三个函数`uninitialized_copy`、`uninitialized_fill`、`uninitialized_fill_n`。\n\n其中，`construct`需要借助`placement new`实现，而这五个函数又根据trivial/non-trivial有着不同的泛化与特化版本。\n\n## 2.1 placement new\n\nplacement new 就等同于调用构造函数。\n\nplacement new 是c++中对`operator new` 的一个标准、全局的**重载版本**。\n\nplacement new 并不分配内存，它允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。\n\n源码（new）\n\n```c++\n// Default placement versions of operator new.\ninline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT\n{ return __p; }\ninline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT\n{ return __p; }\n\n// Default placement versions of operator delete.\ninline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }\ninline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }\n```\n\ndemo\n\n```c++\n#include <new>\n\nclass Foo{};\n\nint main() {\n    char *buf = new char[sizeof(Foo)]; // 在堆上申请一块内存\n    Foo *p = new(buf)Foo(); //new expression执行的两个步骤1.调用重载的operator new 即 placement new 2. 调用构造函数Foo::Foo()\n    p->~Foo(); // 析构不释放内存\n    delete [] buf; // 释放内存\n}\n```\n\n## 2.2 trivial和non-trivial\n\n属于traits编程技法的部分，SGI STL中有一个__type_traits，为了萃取类型（内置类型、自定义class）的5种特性。\n\n对于内置类型，见源码（type_traits.h）\n\n```c++\n/*\n *\n * Copyright (c) 1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n#ifndef __TYPE_TRAITS_H\n#define __TYPE_TRAITS_H\n\n#ifndef __STL_CONFIG_H\n#include <stl_config.h>\n#endif\n\n/*\nThis header file provides a framework for allowing compile time dispatch\nbased on type attributes. This is useful when writing template code.\nFor example, when making a copy of an array of an unknown type, it helps\nto know if the type has a trivial copy constructor or not, to help decide\nif a memcpy can be used.\n\nThe class template __type_traits provides a series of typedefs each of\nwhich is either __true_type or __false_type. The argument to\n__type_traits can be any type. The typedefs within this template will\nattain their correct values by one of these means:\n    1. The general instantiation contain conservative values which work\n       for all types.\n    2. Specializations may be declared to make distinctions between types.\n    3. Some compilers (such as the Silicon Graphics N32 and N64 compilers)\n       will automatically provide the appropriate specializations for all\n       types.\n\nEXAMPLE:\n\n//Copy an array of elements which have non-trivial copy constructors\ntemplate <class T> void copy(T* source,T* destination,int n,__false_type);\n//Copy an array of elements which have trivial copy constructors. Use memcpy.\ntemplate <class T> void copy(T* source,T* destination,int n,__true_type);\n\n//Copy an array of any type by using the most efficient copy mechanism\ntemplate <class T> inline void copy(T* source,T* destination,int n) {\n   copy(source,destination,n,typename __type_traits<T>::has_trivial_copy_constructor());\n}\n*/\n\n\nstruct __true_type {\n};\n\nstruct __false_type {\n};\n\ntemplate <class type>\nstruct __type_traits { \n   typedef __true_type     this_dummy_member_must_be_first;\n                   /* Do not remove this member. It informs a compiler which\n                      automatically specializes __type_traits that this\n                      __type_traits template is special. It just makes sure that\n                      things work if an implementation is using a template\n                      called __type_traits for something unrelated. */\n\n   /* The following restrictions should be observed for the sake of\n      compilers which automatically produce type specific specializations \n      of this class:\n          - You may reorder the members below if you wish\n          - You may remove any of the members below if you wish\n          - You must not rename members without making the corresponding\n            name change in the compiler\n          - Members you add will be treated like regular members unless\n            you add the appropriate support in the compiler. */\n \n\n   typedef __false_type    has_trivial_default_constructor;\n   typedef __false_type    has_trivial_copy_constructor;\n   typedef __false_type    has_trivial_assignment_operator;\n   typedef __false_type    has_trivial_destructor;\n   typedef __false_type    is_POD_type;\n};\n\n\n\n// Provide some specializations.  This is harmless for compilers that\n//  have built-in __types_traits support, and essential for compilers\n//  that don\'t.\n\n__STL_TEMPLATE_NULL struct __type_traits<char> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<signed char> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<unsigned char> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<short> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<unsigned short> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<int> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<unsigned int> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<long> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<unsigned long> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<float> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<double> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n__STL_TEMPLATE_NULL struct __type_traits<long double> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n\ntemplate <class T>\nstruct __type_traits<T*> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n\nstruct __type_traits<char*> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\nstruct __type_traits<signed char*> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\nstruct __type_traits<unsigned char*> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __true_type    has_trivial_copy_constructor;\n   typedef __true_type    has_trivial_assignment_operator;\n   typedef __true_type    has_trivial_destructor;\n   typedef __true_type    is_POD_type;\n};\n\n#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n\n\n#endif /* __TYPE_TRAITS_H */\n\n// Local Variables:\n// mode:C++\n// End:\n\n```\n\n自定义class：\n\n当class内含指针成员，并且对它进行动态内存配置，那么这个class就需要实现从自己的non-trivial-xxx。就不能使用内存底层操作加速`construct`和`destroy`。\n\n如\n\n```c++\ntemplate struct __type_traits<Shape> {\n   typedef __true_type    has_trivial_default_constructor;\n   typedef __false_type    has_trivial_copy_constructor;\n   typedef __false_type    has_trivial_assignment_operator;\n   typedef __false_type    has_trivial_destructor;\n   typedef __false_type    is_POD_type;\n};\n```\n\n## 2.3 construct和destroy\n\n源码（stl_construct.h）\n\n```c++\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/* NOTE: This is an internal header file, included by other STL headers.\n *   You should not attempt to use it directly.\n */\n\n#ifndef __SGI_STL_INTERNAL_CONSTRUCT_H\n#define __SGI_STL_INTERNAL_CONSTRUCT_H\n\n#include <new.h> //使用placement new需要包含此文件\n\n__STL_BEGIN_NAMESPACE\n\ntemplate <class T1, class T2>\ninline void construct(T1* p, const T2& value) {\n  // placement new语法  \n  new (p) T1(value);\n}\n\n// destroy第一个版本，接受一个指针，直接调用析构函数    \ntemplate <class T>\ninline void destroy(T* pointer) {\n    pointer->~T();\n}\n\n// destroy第二个版本，接受两个迭代器，将[first,last)之间的所有对象析构掉\n// 如果范围很大，且析构函数是trival destructor，那么没必要一次次调用析构函数，因此\n// 1. 先通过value_type()获得迭代器所指对象的类型T \n// 2. 利用__type_traits<T> 判断析构函数是否为trival destructor，若是，则什么也不做就结束；否则遍历并调用destroy的第一个版本\ntemplate <class ForwardIterator>\ninline void destroy(ForwardIterator first, ForwardIterator last) {\n  __destroy(first, last, value_type(first));\n}\n\ntemplate <class ForwardIterator, class T>\ninline void __destroy(ForwardIterator first, ForwardIterator last, T*) {\n  typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;\n  __destroy_aux(first, last, trivial_destructor());\n}\n\ntemplate <class ForwardIterator>\ninline void\n__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {\n  for ( ; first < last; ++first)\n    destroy(&*first);\n}\n\ntemplate <class ForwardIterator> \ninline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}\n\n//destroy第二个版本针对迭代器为char*和wchar_t*的特化版\ninline void destroy(char*, char*) {}\ninline void destroy(wchar_t*, wchar_t*) {}\n\n__STL_END_NAMESPACE\n\n#endif /* __SGI_STL_INTERNAL_CONSTRUCT_H */\n\n// Local Variables:\n// mode:C++\n// End:\n\n```\n\n![image-20221016114044853](https://cdn.moyusoldier.cn/image-20221016114044853.png)\n\n## 2.4 uninitialized_copy\n\n将[first, last)范围内的值拷贝到[result, result+(last-first))范围，函数声明如下\n\n```c++\ntemplate <class InputIterator, class ForwardIterator>\ninline ForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last,\n                     ForwardIterator result);\n```\n\n![img](https://cdn.moyusoldier.cn/20210730153142283.png)\n\n## 2.5 uninitialized_fill\n\n将x填充到[first, last)范围内，函数声明如下\n\n```c++\ntemplate <class ForwardIterator, class T>\ninline void uninitialized_fill(ForwardIterator first, ForwardIterator last, \n                               const T& x);\n```\n\n![img](https://cdn.moyusoldier.cn/20210730153154835.png)\n\n\n\n## 2.6 uninitialized_fill_n\n\n将n个x填充到[first, first+n)范围内，函数声明如下\n\n```c++\ntemplate <class ForwardIterator, class Size, class T>\ninline ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n,\n                                            const T& x);\n```\n\n![image-20221021195045892](https://cdn.moyusoldier.cn/image-20221021195045892.png)\n\n`un_initialized_copy()`、`un_initialized_fill()`、`un_initialized_fill_n()`的源码\n\n```c++\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/* NOTE: This is an internal header file, included by other STL headers.\n *   You should not attempt to use it directly.\n */\n\n#ifndef __SGI_STL_INTERNAL_UNINITIALIZED_H\n#define __SGI_STL_INTERNAL_UNINITIALIZED_H\n\n#include \"stl_config.h\"\n#include \"type_traits.h\"\n#include \"cstring\"\n#include \"stl_iterator.h\"\n#include \"stl_pair.h\"\n\n__STL_BEGIN_NAMESPACE\n\n// Valid if copy construction is equivalent to assignment, and if the\n//  destructor is trivial.\ntemplate <class InputIterator, class ForwardIterator>\ninline ForwardIterator \n__uninitialized_copy_aux(InputIterator first, InputIterator last,\n                         ForwardIterator result,\n                         __true_type) {\n  return copy(first, last, result);\n}\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator \n__uninitialized_copy_aux(InputIterator first, InputIterator last,\n                         ForwardIterator result,\n                         __false_type) {\n  ForwardIterator cur = result;\n  __STL_TRY {\n    for ( ; first != last; ++first, ++cur)\n      construct(&*cur, *first);\n    return cur;\n  }\n  __STL_UNWIND(destroy(result, cur));\n}\n\n\ntemplate <class InputIterator, class ForwardIterator, class T>\ninline ForwardIterator\n__uninitialized_copy(InputIterator first, InputIterator last,\n                     ForwardIterator result, T*) {\n  typedef typename __type_traits<T>::is_POD_type is_POD;\n  return __uninitialized_copy_aux(first, last, result, is_POD());\n}\n\ntemplate <class InputIterator, class ForwardIterator>\ninline ForwardIterator\n  uninitialized_copy(InputIterator first, InputIterator last,\n                     ForwardIterator result) {\n  return __uninitialized_copy(first, last, result, value_type(result));\n}\n\ninline char* uninitialized_copy(const char* first, const char* last,\n                                char* result) {\n  memmove(result, first, last - first);\n  return result + (last - first);\n}\n\ninline wchar_t* uninitialized_copy(const wchar_t* first, const wchar_t* last,\n                                   wchar_t* result) {\n  memmove(result, first, sizeof(wchar_t) * (last - first));\n  return result + (last - first);\n}\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\npair<InputIterator, ForwardIterator>\n__uninitialized_copy_n(InputIterator first, Size count,\n                       ForwardIterator result,\n                       input_iterator_tag) {\n  ForwardIterator cur = result;\n  __STL_TRY {\n    for ( ; count > 0 ; --count, ++first, ++cur) \n      construct(&*cur, *first);\n    return pair<InputIterator, ForwardIterator>(first, cur);\n  }\n  __STL_UNWIND(destroy(result, cur));\n}\n\ntemplate <class RandomAccessIterator, class Size, class ForwardIterator>\ninline pair<RandomAccessIterator, ForwardIterator>\n__uninitialized_copy_n(RandomAccessIterator first, Size count,\n                       ForwardIterator result,\n                       random_access_iterator_tag) {\n  RandomAccessIterator last = first + count;\n  return make_pair(last, uninitialized_copy(first, last, result));\n}\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\ninline pair<InputIterator, ForwardIterator>\nuninitialized_copy_n(InputIterator first, Size count,\n                     ForwardIterator result) {\n  return __uninitialized_copy_n(first, count, result,\n                                iterator_category(first));\n}\n\n// Valid if copy construction is equivalent to assignment, and if the\n//  destructor is trivial.\ntemplate <class ForwardIterator, class T>\ninline void\n__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, \n                         const T& x, __true_type)\n{\n  fill(first, last, x);\n}\n\ntemplate <class ForwardIterator, class T>\nvoid\n__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, \n                         const T& x, __false_type)\n{\n  ForwardIterator cur = first;\n  __STL_TRY {\n    for ( ; cur != last; ++cur)\n      construct(&*cur, x);\n  }\n  __STL_UNWIND(destroy(first, cur));\n}\n\ntemplate <class ForwardIterator, class T, class T1>\ninline void __uninitialized_fill(ForwardIterator first, ForwardIterator last, \n                                 const T& x, T1*) {\n  typedef typename __type_traits<T1>::is_POD_type is_POD;\n  __uninitialized_fill_aux(first, last, x, is_POD());\n                   \n}\n\ntemplate <class ForwardIterator, class T>\ninline void uninitialized_fill(ForwardIterator first, ForwardIterator last, \n                               const T& x) {\n  __uninitialized_fill(first, last, x, value_type(first));\n}\n\n// Valid if copy construction is equivalent to assignment, and if the\n//  destructor is trivial.\ntemplate <class ForwardIterator, class Size, class T>\ninline ForwardIterator\n__uninitialized_fill_n_aux(ForwardIterator first, Size n,\n                           const T& x, __true_type) {\n  return fill_n(first, n, x);\n}\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\n__uninitialized_fill_n_aux(ForwardIterator first, Size n,\n                           const T& x, __false_type) {\n  ForwardIterator cur = first;\n  __STL_TRY {\n    for ( ; n > 0; --n, ++cur)\n      construct(&*cur, x);\n    return cur;\n  }\n  __STL_UNWIND(destroy(first, cur));\n}\n\ntemplate <class ForwardIterator, class Size, class T, class T1>\ninline ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,\n                                              const T& x, T1*) {\n  typedef typename __type_traits<T1>::is_POD_type is_POD;\n  return __uninitialized_fill_n_aux(first, n, x, is_POD());\n                                    \n}\n\ntemplate <class ForwardIterator, class Size, class T>\ninline ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n,\n                                            const T& x) {\n  return __uninitialized_fill_n(first, n, x, value_type(first));\n}\n\n// Copies [first1, last1) into [result, result + (last1 - first1)), and\n//  copies [first2, last2) into\n//  [result, result + (last1 - first1) + (last2 - first2)).\n\ntemplate <class InputIterator1, class InputIterator2, class ForwardIterator>\ninline ForwardIterator\n__uninitialized_copy_copy(InputIterator1 first1, InputIterator1 last1,\n                          InputIterator2 first2, InputIterator2 last2,\n                          ForwardIterator result) {\n  ForwardIterator mid = uninitialized_copy(first1, last1, result);\n  __STL_TRY {\n    return uninitialized_copy(first2, last2, mid);\n  }\n  __STL_UNWIND(destroy(result, mid));\n}\n\n// Fills [result, mid) with x, and copies [first, last) into\n//  [mid, mid + (last - first)).\ntemplate <class ForwardIterator, class T, class InputIterator>\ninline ForwardIterator \n__uninitialized_fill_copy(ForwardIterator result, ForwardIterator mid,\n                          const T& x,\n                          InputIterator first, InputIterator last) {\n  uninitialized_fill(result, mid, x);\n  __STL_TRY {\n    return uninitialized_copy(first, last, mid);\n  }\n  __STL_UNWIND(destroy(result, mid));\n}\n\n// Copies [first1, last1) into [first2, first2 + (last1 - first1)), and\n//  fills [first2 + (last1 - first1), last2) with x.\ntemplate <class InputIterator, class ForwardIterator, class T>\ninline void\n__uninitialized_copy_fill(InputIterator first1, InputIterator last1,\n                          ForwardIterator first2, ForwardIterator last2,\n                          const T& x) {\n  ForwardIterator mid2 = uninitialized_copy(first1, last1, first2);\n  __STL_TRY {\n    uninitialized_fill(mid2, last2, x);\n  }\n  __STL_UNWIND(destroy(first2, mid2));\n}\n\n__STL_END_NAMESPACE\n\n#endif /* __SGI_STL_INTERNAL_UNINITIALIZED_H */\n\n// Local Variables:\n// mode:C++\n// End:\n\n```\n\n\n\n# 3 内存申请和释放（通过空间配置器进行内存管理）\n\n## 3.1 内存管理\n\n**内存管理管理的都是堆（Heap）内存**\n\nC++内存申请的动作是`operator new`，最终调用`malloc`，之后交由不同的操作系统处理；\n\nC++内存释放的动作是`operator delete`，最终调用`free`，之后交由不同的操作系统处理。\n\n容器申请内存时，调用allocator的allocate，进而调用operator new，进而调用malloc；\n\n容器释放内存时，调用allocator的deallocate，进而调用operator delete，进而调用free。\n\n**空间配置器可以在allocate调用operator new的过程中做优化，提高效率。**\n\n![img](https://cdn.moyusoldier.cn/20160722093242640)\n\n图为 Linux 内核 v2.6.7 之后，32 位模式下的虚拟内存布局方式\n\n## 3.2 operator new\n\n`operator new`最终会调用`malloc`方法。\n\n`operator new`和`operator delete`是C++中全局的内存申请和释放函数，可以被重载。\n\n源码（new）\n\n```c++\nvoid* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)\n  __attribute__((__externally_visible__));\nvoid* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)\n  __attribute__((__externally_visible__));\nvoid operator delete(void*) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__));\nvoid operator delete[](void*) _GLIBCXX_USE_NOEXCEPT\n  __attribute__((__externally_visible__));\n```\n\n对于`operator new`，各种编译器的实现方法不同，但最终都会落到`malloc`方法。图为在两种不同编译器上的具体实现。\n\n![image-20221020194140537](https://cdn.moyusoldier.cn/image-20221020194140537.png)\n\n## 3.3 额外开销及空间配置器的效率\n\n![image-20221020214530595](https://cdn.moyusoldier.cn/image-20221020214530595.png)\n\n如图所示为”你申请的内存\" vs \"malloc给你的内存“。malloc给你的内存由两部分构成：\n\n- cookie，用以记录内存大小，是一块固定大小的额外开销（overhead）\n\n- object所需内存\n\n额外开销越大，效率越低。\n\n>  free的时候怎么知道malloc申请的大小？malloc申请的额外开销中的cookie部分\n\n## 3.4 空间配置器的标准接口\n\n各STL各版本的具体实现之间存在差别，但都遵循同一个STL规范，以下为[STL规范中空间配置器的必要接口](http://www.angelikalanger.com/Articles/C++Report/Allocators/Allocators.html)：\n\n```c++\ntemplate <class T> class allocator_type {\npublic:\n// constructors, destructors, and the like\n// 构造和析构函数\nallocator() throw();\nallocator(const allocator&) throw();\ntemplate <class U> allocator(const allocator<U>&) throw();\n~allocator() throw();\n// types and functions for alternative pointer types\n// 代替指针类型的类型和方法\ntypedef allocator-specific pointer;\ntypedef allocator-specific const_pointer;\ntypedef allocator-specific reference;\ntypedef allocator-specific const_reference;\ntypedef allocator-specific value_type;\ntypedef allocator-specific size_type;\ntypedef allocator-specific difference_type;\npointer address(reference x) const;\nconst_pointer address(const_reference x) const;\n// types and functions for alternative memory allocation strategies\n// 代替内存分配策略的类型和方法    \npointer allocate(size_type, allocator<void>::const_pointer hint = 0);\nvoid deallocate(pointer p, size_type n);\nvoid construct(pointer p, const T& val);\nvoid destroy(pointer p);\nsize_type max_size() const throw();\ntemplate <class U> struct rebind { typedef allocator<U> other; };\n};\n```\n\n## 3.5 SGI标准的空间配置器 std::allocator\n\n（空间配置器最基础的实现方法，必须掌握！是之后介绍内存池的基础）\n\nSGI STL有一个符合标准接口的空间配置器，名为allocator，但SGI自己从未用过它，也不建议我们使用。主要原因是效率不佳，只把C++的`opetator new`和`operator delete`做浅封装。\n\n**未实现construct和destroy！**\n\n源码（defalloc.h）\n\n```c++\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n */\n\n// Inclusion of this file is DEPRECATED.  This is the original HP\n// default allocator.  It is provided only for backward compatibility.\n// \n// DO NOT USE THIS FILE unless you have an old container implementation\n// that requires an allocator with the HP-style interface.  SGI STL\n// uses a different allocator interface.  SGI-style allocators are not\n// parametrized with respect to the object type; they traffic in void *\n// pointers.  This file is not included by any other SGI STL header.\n\n#ifndef DEFALLOC_H\n#define DEFALLOC_H\n\n#include <new.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <iostream.h>\n#include <algobase.h>\n\n\ntemplate <class T>\ninline T* allocate(ptrdiff_t size, T*) {\n    set_new_handler(0); \n    T* tmp = (T*)(::operator new((size_t)(size * sizeof(T))));\n    if (tmp == 0) {\n	cerr << \"out of memory\" << endl; \n	exit(1);\n    }\n    return tmp;\n}\n\n\ntemplate <class T>\ninline void deallocate(T* buffer) {\n    ::operator delete(buffer);\n}\n\ntemplate <class T>\nclass allocator {\npublic:\n    // 关联类型 7associated type\n    typedef T value_type;\n    typedef T* pointer;\n    typedef const T* const_pointer;\n    typedef T& reference;\n    typedef const T& const_reference;\n    typedef size_t size_type;\n    typedef ptrdiff_t difference_type;\n    \n    pointer allocate(size_type n) { \n	return ::allocate((difference_type)n, (pointer)0);\n    }\n    \n    void deallocate(pointer p) { ::deallocate(p); }\n    \n    pointer address(reference x) { return (pointer)&x; }\n    \n    const_pointer const_address(const_reference x) { \n	return (const_pointer)&x; \n    }\n    \n    size_type init_page_size() { \n	return max(size_type(1), size_type(4096/sizeof(T))); \n    }\n    \n    size_type max_size() const { \n	return max(size_type(1), size_type(UINT_MAX/sizeof(T))); \n    }\n};\n\nclass allocator<void> {\npublic:\n    typedef void* pointer;\n};\n\n\n\n#endif\n\n```\n\n可以看出，该allocator并没有实现construct和destroy方法。\n\n## 3.6 SGI特殊的空间配置器 std::alloc\n\nSGI标准的空间配置器在频繁分配小块内存时效率不佳，因此，SGI使用的是特殊的空间配置器 std::alloc。\n\n实现方案：\n\n使用freelist构造内存池，从而减少malloc的次数，从而减少额外开销。（该部分不介绍具体实现，感兴趣的小伙伴可以研究下[TCMalloc](https://github.com/google/tcmalloc)内存池）\n\n![image-20221020203720800](https://cdn.moyusoldier.cn/image-20221020203720800.png)'),(37,'STL源码剖析3-迭代器',0,'2022-10-22 12:40:39','STL源码剖析','## 1.1 思想\n\nSTL的中心思想在于：将容器和算法分开，彼此独立设计（通过类模板和函数模板），最后再以迭代器连接在一起。\n\n## 1.2 设计\n\n迭代器是一种智能指针（smart pointer），指针最重要的两个操作`*`（解引用 dereference）和`->`，因此迭代器最重要的编程工作就是重载`operator*`和`operator->`。\n\n一个简单的迭代器设计：\n\n```c++\ntemplate<typename T>\nclass ListItem {\nprivate:\n    T _value;\n    ListItem *_next;\npublic:\n    T value() const {\n        return _value;\n    }\n    ListItem *next() const {\n        return _next;\n    }\n    //...\n};\n\ntemplate<typename T>\nclass List {\nprivate:\n    ListItem<T> *_end;\n    ListItem<T> *_front;\n    long _size;\npublic:\n    void insert_front(T value) {}\n    void insert_end(T value);\n    void display(std::ostream &os = std::cout) const;\n    //...\n};\n\ntemplate<class Item>\nstruct ListIter {\n    Item *ptr;\n    ListIter(Item *p = 0) : ptr(p) {}\n    Item &operator*() const { return *ptr; }\n    Item *operator->() const { return ptr; }\n\n    //以下两个operator++遵循标准做法\n    //++iter\n    ListIter &operator++() {\n        ptr = ptr->next();\n        return *this;\n    }\n    \n	//iter++\n    ListIter operator++(int) {\n        ListIter old = *this;\n        operator++();\n        return old;\n    }\n\n    bool operator==(const ListIter &i) const {\n        return ptr == i.ptr;\n    }\n    bool operator!=(const ListIter &i) const {\n        return ptr != i.ptr;\n    }\n\n};\n\nint main(){\n    List<int> mylist;\n    ListIter<ListItem<int>> begin(mylist.front());\n}\n```\n\n\n\n# 2 Traits 编程\n\ntraits，又被叫做特性萃取技术，用来获得迭代器所指对象的类型。因为STL的算法和容器是分离的，两者通过迭代器连接。算法的实现并不知道自己被传进来什么。萃取器相当于在接口和实现之间加**一层封装**，来隐藏一些细节并协助调用合适的方法，这需要一些技巧（例如，偏特化）。让我们一点点抛出问题，然后一点点深入。\n\n在分析`traits`编程之前, 我们需要对模板参数类型`tempname`和`class`有一定的了解，详见[此博文](https://blog.csdn.net/Function_Dou/article/details/84644963)。\n\n## 2.1 Question 1\n\n需求：在算法中运用迭代器时，需要知道迭代器所指对象的类型（即**关联类型**，associated types）。以实现C++中不支持的typeof()函数的功能。\n\n方法：利用函数模板的**参数推导**（argument deducation）机制实现。\n\n```c++\ntemplate<class I, class T>\nvoid func_impl(I iter, T t) {\n    T tmp;// 2. 参数推导，从传来的参数T t，获取了迭代器关联类型，T为int\n    //...这里实现原本func实现的工作\n}\n\ntemplate<class I>\ninline\nvoid func(I iter) {\n    func_impl(iter, *iter); //1. 迭代器的模板参数I iter是一个int*（或MyIter<int>），对其进行解引用，获得的是一个int值 \n}\n\nint main() {\n    int i;\n    func(&i);\n}\n```\n\n## 2.2 Question 2\n\n函数模板的参数推导机制推导的只是参数，无法推导函数的返回值类型。万一需要推导函数的返回值，就无能为力了。\n\n方法：声明**内嵌类型**\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntemplate<class T>\nstruct MyIter {\n    typedef T value_type; //声明内嵌类型，value_type就是迭代器的关联类型\n    T *ptr;\n    MyIter(T *p = 0) : ptr(p) {}\n    T &operator*() const { return *ptr; }\n    //...\n};\n\ntemplate<class I>//class type，通过定义内嵌类型把这个迭代器的关联类型表示出来，表示成typename I::value_type\ntypename I::value_type func(I iter) {//typename告诉编译器 MyIter<T>::vaule_type是一个类型，这样才能顺利通过编译\n    return *iter;\n}\n\nint main() {\n    MyIter<int> iter(new int(8));\n    cout << func(iter);\n}\n```\n\n## 2.3 Question 3\n\n并不是所有迭代器都是class type，**原生指针就不行！**如果不是class type，就无法为它定义内嵌类型（例子如下）。\n\n> 原生指针：T *。T既可以为基础类型，如int、double等，也可以是一个自己定义的Class类\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\ntemplate<class I>//传一个原生指针\n??? func(I iter) { //这里行不通，迭代器是原生指针，无法通过定义内嵌类型把关联类型表示出来\n    return *iter;\n}\n\nint main() {\n    int *p = new int(8);\n    cout << func(p);\n}\n```\n\n方法：没有什么是加一层解决不了的，加一个**特性萃取**层，该层基于模板类的**偏特化**构造。\n\n最终实现的效果：\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntemplate<class T>\nstruct MyIter {\n    typedef T value_type; //声明内嵌类型，value_type就是迭代器的关联类型\n    T *ptr;\n    MyIter(T *p = 0) : ptr(p) {}\n    T &operator*() const { return *ptr; }\n    //...\n};\n\n//特性萃取层，包括泛化和两种偏特化版本\ntemplate<class I>\nstruct my_iterator_traits {\n    typedef typename I::value_type value_type;//泛化版，迭代器的关联类型是class-type iterators，MyIter<int>\n};\n\ntemplate<class T>\nstruct my_iterator_traits<T *> {\n    typedef T value_type;//偏特化版，迭代器的关联类型是一个原生指针\n};\n\ntemplate<class T>\nstruct my_iterator_traits<const T *> {\n    typedef T value_type;//偏特化版，迭代器的关联类型是const原生指针\n};\n\ntemplate<class I>\ntypename my_iterator_traits<I>::value_type func(I iter) {\n    return *iter;\n}\n\nint main() {\n    MyIter<int> iter(new int(8));\n    cout << func(iter)<<endl; //8\n    int *p = new int(8);\n    cout << func(p)<<endl; //8\n}\n```\n\n## 2.4 traits\n\n![img](https://cdn.moyusoldier.cn/1092165-20170226202119929-679463344.png)\n\n最常用的关联类型有5种，STL容器的迭代器都定义了这5种关联类型。“特性萃取机”traits会将它们萃取出来。\n\n源码（stl_iterator.h）\n\n```c++\n//泛化版本的特性萃取机\ntemplate <class Iterator>\nstruct iterator_traits {\n  typedef typename Iterator::iterator_category iterator_category;\n  typedef typename Iterator::value_type        value_type;\n  typedef typename Iterator::difference_type   difference_type;\n  typedef typename Iterator::pointer           pointer;\n  typedef typename Iterator::reference         reference;\n};\n//偏特化：传入类型为原生指针\ntemplate <class T>\nstruct iterator_traits<T*> {\n  typedef random_access_iterator_tag iterator_category;\n  typedef T                          value_type;\n  typedef ptrdiff_t                  difference_type;\n  typedef T*                         pointer;\n  typedef T&                         reference;\n};\n//偏特化：传入类型为const原生指针\ntemplate <class T>\nstruct iterator_traits<const T*> {\n  typedef random_access_iterator_tag iterator_category;\n  typedef T                          value_type;\n  typedef ptrdiff_t                  difference_type;\n  typedef const T*                   pointer;\n  typedef const T&                   reference;\n};\n```\n\n## 2.5 5种关联类型（5 associated type）\n\n### 2.5.1 value_type\n\nvalue_type表示迭代器所指对象的类型（容器内元素类型）。\n\n### 2.5.2 difference_type\n\ndifference_type表示两个迭代器之间的距离的类型（ptrdiff_t），也可以用来表示容器的最大容量，即头尾之间的距离。\n\n例子：实现STL的count()，其返回值就必须使用difference_type\n\n```c++\ntemplate<class I, class T>\ntypename iterator_traits<I>::difference_type \ncount(I first, I last, const T& value){\n    typename iterator_traits<I>::difference_type n = 0;\n    for(;first!=last;++first){\n        if(*first == value){\n            ++n;\n        }\n    }\n    return n;\n}\n```\n\n### 2.5.3 reference\n\n### 2.5.4 pointer\n\nreference和pointer是一对密切联系的概念。reference表示“迭代器所指对象”，pointer表示“迭代器所指对象的地址”。\n\n```c++\ntemplate<class Item>\nstruct ListIter {\n    Item &operator*() const { return *ptr; } //Item& 是reference\n    Item *operator->() const { return ptr; } //Item* 是pointer\n	//...\n};\n```\n\n迭代器根据所指对象内容是否允许改变分为两种：\n\n- mutable iterators，如`int *q`，对其解引用获得的是一个左值。\n- constant iterators，如`const int *p`，对其解引用获得的是一个右值\n\n(左值与右值这两个概念是从 C 中传承而来的，左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。)\n\n```c++\nint main() {\n    int *p = new int(5);\n    const int *q = new int(9);\n    *p = 7;\n    *q = 1; // 报错，右值不能出现在等号左边\n}\n```\n\nreference表示“迭代器所指对象” ，是一个左值，C++中传回左值用by reference的方式进行。所以：\n\n- 如果迭代器为mutable iterators，解引用后的类型应为`int &`\n- 如果迭代器为constant iterators，解引用后的类型应为`const int &`\n\n### 2.5.5 iterator_category\n\n迭代器的类别：\n\n1. Input Iterator：只读    \n2. Output Iterator：只写    \n3. Forward Iterator：可读可写，只能前进，每次前进一个单位    \n4. Bidirectional Iterator：可读可写，双向移动，每次移动一个单位    \n5. Random Access Iterator：可读可写，双向移动，每次移动多个单位\n\n\n\n'),(38,'STL源码剖析4-list',1,'2022-10-22 12:41:13','STL源码剖析','> 胸中自有丘壑：你完全清楚，在使用STL的时候，它里面的细节是什么\n\n# 导言： 容器大观\n\n![img](https://cdn.moyusoldier.cn/v2-cf1c25e00f50708d86742aa750ffe672_720w.jpg)\n\n这个图以缩进的方式表达基层与衍生层之间的关系，他们是组合(compostion)关系，即heap中包含一个vector，priority-queue包含一个heap。\n\n序列式容器：所有容器都可以排序，但未必有序。\n\n关联式容器：每个数据都有key和value。\n\n# 1. 双向环形链表\n\n![img](https://cdn.moyusoldier.cn/779368-20161024142655859-1522277497.png)\n\n- 为什么是双向链表？\n\n方便反向遍历，prev和next指针会比只有next指针在一些操作上更方便（也许）。\n\n```c++\nfor(auto it = collection.rbegin(); it != collection.rend(); ++it) {\n	std::cout << *it << \' \';\n}\n```\n\n- 为什么是环形链表？只需要一个node指针就可以完整表现整个链表，而不是begin和end两个指针。\n\n# 2. 如何设计双向环形链表？\n\n三个类/结构体\n\n## 2.1 struct __list_node\n\n```c++\ntemplate <class T>\nstruct __list_node {\n  typedef void* void_pointer;\n  void_pointer next;\n  void_pointer prev;\n  T data;\n};\n```\n\n## 2.2 struct __list_iterator\n\nlist的迭代器是封装的指针，vector的迭代器就是普通指针\n\n```c++\ntemplate<class T, class Ref, class Ptr>\nstruct __list_iterator {\n  typedef __list_iterator<T, T&, T*>             iterator;\n  typedef __list_iterator<T, const T&, const T*> const_iterator;\n  typedef __list_iterator<T, Ref, Ptr>           self;\n\n  // 声明5种关联类型\n  typedef bidirectional_iterator_tag iterator_category;\n  typedef T value_type;\n  typedef Ptr pointer;\n  typedef Ref reference;\n  typedef __list_node<T>* link_type;\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\n    \n  //唯一的属性，指向__list_node的普通指针，指向当前迭代器想要指向的节点\n  link_type node;\n    \n  //方法：构造函数/拷贝构造\n  __list_iterator(link_type x) : node(x) {}\n  __list_iterator() {}\n  __list_iterator(const iterator& x) : node(x.node) {}\n  \n  bool operator==(const self& x) const { return node == x.node; }\n  bool operator!=(const self& x) const { return node != x.node; }\n    \n  //方法:*,->,++,--\n  reference operator*() const { return (*node).data; }\n  pointer operator->() const { return &(operator*()); }\n  \n  // prefix increment ++i\n  self& operator++() { \n    node = (link_type)((*node).next);\n    return *this;\n  }\n    \n  // postfix increment i++\n  self operator++(int) { \n    self tmp = *this;\n    ++*this;\n    return tmp;\n  }\n  self& operator--() { \n    node = (link_type)((*node).prev);\n    return *this;\n  }\n  self operator--(int) { \n    self tmp = *this;\n    --*this;\n    return tmp;\n  }\n};\n```\n\n## 2.3 class list\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\nprotected:\n  // 节点，空间配置器\n  typedef void* void_pointer;\n  typedef __list_node<T> list_node;\n  typedef simple_alloc<list_node, Alloc> list_node_allocator;\npublic:\n  // \n  typedef T value_type;\n  typedef value_type* pointer;\n  typedef const value_type* const_pointer;\n  typedef value_type& reference;\n  typedef const value_type& const_reference;\n  typedef list_node* link_type;\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\n\npublic:\n  // 各种迭代器\n  typedef __list_iterator<T, T&, T*>             iterator;\n  typedef __list_iterator<T, const T&, const T*> const_iterator;\n    \n  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;  \n    \nprotected:\n  // 唯一属性，__list_node类型的普通指针，指向尾端的一个空白节点（固定不动），构成环形双向链表\n  link_type node;\n  // 各种方法...\n};\n```\n\n注: 定义一个iterator， 因为iterator是声明在list中的类型，所以定义一个iterator时要加作用域运算符::\n\n（所有容器，itetator的声明都是在容器类中）\n\n```c++\nlist<int>::iterator iter1 = l1.begin();\nlist<int>::const_iterator iter2 = l1.begin();\n```\n\n### 构造和析构\n\n有关list_node的构造析构\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\nprotected:\n  // 申请一个节点的空间\n  link_type get_node() { return list_node_allocator::allocate(); }\n  // 释放一个节点的空间  \n  void put_node(link_type p) { list_node_allocator::deallocate(p); }\n  // 申请一个节点的空间，并使用construct函数将其构造为x\n  link_type create_node(const T& x) {\n    link_type p = get_node();\n    __STL_TRY {  \n      construct(&p->data, x);\n    }\n    __STL_UNWIND(put_node(p));\n    return p;\n  }\n  // 调用destroy函数，并释放这个节点的空间  \n  void destroy_node(link_type p) {\n    destroy(&p->data); \n    put_node(p);\n  }\n  //...  \n};\n\n```\n\n有关list的构造析构\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  // 构造  \n  list() { empty_initialize(); }\n  // 析构  \n  ~list() {\n    clear();\n    put_node(node);\n  }\n  void clear();  \n    \nprotected:\n  // 配置一个节点空间（get_node），令node指针指向它\n  void empty_initialize() { \n    node = get_node();\n    node->next = node;\n    node->prev = node;\n  }\n};\n\ntemplate <class T, class Alloc> \nvoid list<T, Alloc>::clear()\n{\n  link_type cur = (link_type) node->next;\n  while (cur != node) {\n    link_type tmp = cur;\n    cur = (link_type) cur->next;\n    destroy_node(tmp);\n  }\n  node->next = node;\n  node->prev = node;\n}\n```\n\n### 迭代器相关\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  typedef __list_iterator<T, T&, T*>             iterator;\n  typedef __list_iterator<T, const T&, const T*> const_iterator;\n  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;  \n    \npublic:\n  iterator begin() { return (link_type)((*node).next); }\n  const_iterator begin() const { return (link_type)((*node).next); }\n  iterator end() { return node; }\n  const_iterator end() const { return node; }\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const { \n    return const_reverse_iterator(end()); \n  }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { \n    return const_reverse_iterator(begin());\n  } \n  bool empty() const { return node->next == node; }\n  size_type size() const {\n    size_type result = 0;\n    distance(begin(), end(), result);\n    return result;\n  }\n  size_type max_size() const { return size_type(-1); }\n  reference front() { return *begin(); }\n  const_reference front() const { return *begin(); }\n  reference back() { return *(--end()); }\n  const_reference back() const { return *(--end()); }\n  void swap(list<T, Alloc>& x) { __STD::swap(node, x.node); }    \n};\n```\n\n### erase、insert\n\nerase：在迭代器所指位置之前\n\ninsert：该迭代器所指节点\n\n都有多个重载\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  //insert1\n  iterator insert(iterator position, const T& x) {\n    link_type tmp = create_node(x);\n    tmp->next = position.node;\n    tmp->prev = position.node->prev;\n    (link_type(position.node->prev))->next = tmp;\n    position.node->prev = tmp;\n    return tmp;\n  }\n  //insert2  \n  iterator insert(iterator position) { return insert(position, T()); }\n  //insert3  \n  void insert(iterator position, InputIterator first, InputIterator last);\n  //insert4  \n  void insert(iterator pos, size_type n, const T& x);\n  //insert5  \n  void insert(iterator pos, int n, const T& x) {\n    insert(pos, (size_type)n, x);\n  }\n  //insert6  \n  void insert(iterator pos, long n, const T& x) {\n    insert(pos, (size_type)n, x);\n  }\n  //erase1  \n  iterator erase(iterator position) {\n    link_type next_node = link_type(position.node->next);\n    link_type prev_node = link_type(position.node->prev);\n    prev_node->next = next_node;\n    next_node->prev = prev_node;\n    destroy_node(position.node);\n    return iterator(next_node);\n  }    \n  //erase2\n  iterator erase(iterator first, iterator last);    \n  //...  \n};\n\ntemplate <class T, class Alloc> template <class InputIterator>\nvoid list<T, Alloc>::insert(iterator position,\n                            InputIterator first, InputIterator last) {\n  for ( ; first != last; ++first)\n    insert(position, *first);\n}\n\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::insert(iterator position, size_type n, const T& x) {\n  for ( ; n > 0; --n)\n    insert(position, x);\n}\n\ntemplate <class T, class Alloc>\nlist<T,Alloc>::iterator list<T, Alloc>::erase(iterator first, iterator last) {\n  while (first != last) erase(first++);\n  return last;\n}\n```\n\n### push_back、push_front、pop_front、pop_back、remove\n\n基于insert和erase两个方法，实现push_back, push_front, pop_front, pop_back, remove\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  void push_front(const T& x) { insert(begin(), x); }\n  void push_back(const T& x) { insert(end(), x); }\n  void pop_front() { erase(begin()); }\n  void pop_back() { \n    iterator tmp = end();\n    erase(--tmp);\n  }\n  void remove(const T& value);    \n  //...  \n};\n\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::remove(const T& value) {\n  iterator first = begin();\n  iterator last = end();\n  while (first != last) {\n    iterator next = first;\n    ++next;\n    if (*first == value) erase(first);\n    first = next;\n  }\n}\n```\n\n### transfer\n\n双向链表如何移动一段数据？使用transfer方法，包含8个步骤\n\ntransfer方法是splice, sort, merge的基础\n\n可以是同一list中，也可以是两个不同的list\n\n![img](https://cdn.moyusoldier.cn/779368-20161024144543531-1559152815.png)\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\nprotected:\n  void transfer(iterator position, iterator first, iterator last) {\n    if (position != last) {\n      (*(link_type((*last.node).prev))).next = position.node;\n      (*(link_type((*first.node).prev))).next = last.node;\n      (*(link_type((*position.node).prev))).next = first.node;  \n      link_type tmp = link_type((*position.node).prev);\n      (*position.node).prev = (*last.node).prev;\n      (*last.node).prev = (*first.node).prev; \n      (*first.node).prev = tmp;\n    }\n  }\n  //...  \n};\n```\n\n### splice\n\n即transfer的public方法，有多个重载\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  void splice(iterator position, list& x) {\n    if (!x.empty()) \n      transfer(position, x.begin(), x.end());\n  }\n  void splice(iterator position, list&, iterator i) {\n    iterator j = i;\n    ++j;\n    if (position == i || position == j) return;\n    transfer(position, i, j);\n  }\n  void splice(iterator position, list&, iterator first, iterator last) {\n    if (first != last) \n      transfer(position, first, last);\n  }\n  //...  \n};\n```\n\n### merge\n\n合并两个有序list， 调用single element版本的splice，逐个节点合并（学学别人怎么写的代码）。\n\nmerge之后，this包含所有节点，x为空链表。\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  void merge(list& x);\n  //...  \n};\n\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::merge(list<T, Alloc>& x) {\n  iterator first1 = begin();\n  iterator last1 = end();\n  iterator first2 = x.begin();\n  iterator last2 = x.end();\n  while (first1 != last1 && first2 != last2)\n    if (*first2 < *first1) {\n      iterator next = first2;\n      transfer(first1, first2, ++next);\n      first2 = next;\n    }\n    else\n      ++first1;\n  if (first2 != last2) transfer(last1, first2, last2);//这句在while之外\n}\n```\n\n### reverse\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  void reverse();\n  //...  \n};\n\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::reverse() {\n  // 判断空链表或只有一个元素，等价于size() == 0 || size() == 1，但速度更快\n  if (node->next == node || link_type(node->next)->next == node) return;\n  iterator first = begin();\n  ++first;\n  while (first != end()) {\n    iterator old = first;\n    ++first;\n    transfer(begin(), old, first);//把old放到begin前\n  }\n}    \n```\n\n### sort\n\n> 注：本处的sort，C语言中<stdlib.h>中qsort，STL&lt;algorithm>中的sort......所有的排序都默认是升序。\n\nqsort只能对数组排序，list的iterator类型不是RandomAccessIterator，而是Bidirectional Iterator，不能用algorithm中的sort，故只能使用list的成员函数sort进行排序。\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  void sort();\n  //...  \n};\n\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::sort() {\n  //if size() == 0 || size() == 1 \n  if (node->next == node || link_type(node->next)->next == node) return;\n  list<T, Alloc> carry;\n  list<T, Alloc> counter[64];\n  int fill = 0;\n  while (!empty()) {\n    carry.splice(carry.begin(), *this, begin());\n    int i = 0;\n    while(i < fill && !counter[i].empty()) {\n      counter[i].merge(carry);\n      carry.swap(counter[i++]);\n    }\n    carry.swap(counter[i]);         \n    if (i == fill) ++fill;\n  } \n\n  for (int i = 1; i < fill; ++i) counter[i].merge(counter[i-1]);\n  swap(counter[fill-1]);\n}\n\n//sort用到的swap方法，交换this和x两个链表的全部节点\nvoid swap(list<T, Alloc>& x) { __STD::swap(node, x.node); }\n```\n\n排序方法：归并排序（merge sort）\n\n具体步骤：[清晰讲解](https://blog.csdn.net/return_cc/article/details/79604923?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1-79604923-blog-111267883.pc_relevant_sortByAnswer&spm=1001.2101.3001.4242.2&utm_relevant_index=4), [图解](https://blog.csdn.net/qq_31720329/article/details/85535787?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-85535787-blog-111267883.pc_relevant_sortByAnswer&spm=1001.2101.3001.4242.1&utm_relevant_index=3)\n\n太神奇了！整个函数没有一次比较，就排好序了（其实在merge里排序了）\n\n\n\n\n\n\n\n'),(39,'STL源码剖析5-vector',0,'2022-10-22 12:41:52','STL源码剖析','# 1 vector概述\n\nvector：自动增长的数组(2倍增长)，设计关键在扩容（1.配置新空间2.数据移动3.释放旧空间）。\n\narray：定长数组\n\n# 2 vector定义摘要\n\n空vector的大小：12byte，3个指针的大小（start, finish, end_of_storage）\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass vector {\npublic:\n  // 类型定义  \n  typedef T value_type;\n  typedef value_type* pointer;\n  // 声明迭代器  \n  typedef value_type* iterator;\n  typedef value_type& reference;\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\nprotected:\n  // simple_alloc是SGI STL的默认空间配置器\n  typedef simple_alloc<value_type, Alloc> data_allocator;\n  // 三个指针（vector的迭代器就是普通指针），很重要！vector创建之后大小：12byte 3个指针的大小\n  iterator start;\n  iterator finish;\n  iterator end_of_storage;\n  // 声明插入函数（带扩容）\n  void insert_aux(iterator position, const T& x);\n  // 释放整个vector的内存\n  void deallocate() {\n    if (start) data_allocator::deallocate(start, end_of_storage - start);\n  }\n  // 直接被构造函数调用的方法\n  void fill_initialize(size_type n, const T& value) {\n    start = allocate_and_fill(n, value);\n    finish = start + n;\n    end_of_storage = finish;\n  }\npublic:\n  // 迭代器相关方法，注意怎么使用三个指针的\n  iterator begin() { return start; }\n  iterator end() { return finish; }\n  size_type size() const { return size_type(end() - begin()); }\n  size_type capacity() const { return size_type(end_of_storage - begin()); }\n  bool empty() const { return begin() == end(); }\n  reference operator[](size_type n) { return *(begin() + n); }\n  // 构造函数  \n  vector() : start(0), finish(0), end_of_storage(0) {}\n  vector(size_type n, const T& value) { fill_initialize(n, value); }\n  vector(int n, const T& value) { fill_initialize(n, value); }\n  vector(long n, const T& value) { fill_initialize(n, value); }\n  explicit vector(size_type n) { fill_initialize(n, T()); }\n  // 拷贝构造  \n  vector(const vector<T, Alloc>& x) {\n    start = allocate_and_copy(x.end() - x.begin(), x.begin(), x.end());\n    finish = start + (x.end() - x.begin());\n    end_of_storage = finish;\n  }\n\n  vector(const_iterator first, const_iterator last) {\n    size_type n = 0;\n    distance(first, last, n);\n    start = allocate_and_copy(n, first, last);\n    finish = start + n;\n    end_of_storage = finish;\n  }\n  // 析构函数\n  ~vector() { \n    destroy(start, finish); // 全局函数\n    deallocate();\n  }\n  reference front() { return *begin(); }\n  reference back() { return *(end() - 1); }\n  void push_back(const T& x) {\n    if (finish != end_of_storage) {\n      construct(finish, x); // 全局函数\n      ++finish;\n    }\n    else\n      insert_aux(end(), x);\n  }\n  void pop_back() {\n    --finish;\n    destroy(finish);// 全局函数\n  }\n  //删除元素  \n  iterator erase(iterator position) {\n    if (position + 1 != end())\n      copy(position + 1, finish, position);//后续元素往前移动\n    --finish;\n    destroy(finish);//全局函数\n    return position;//返回的迭代器指向原来的位置（其实就指向了下一个）\n  }\n  //resize不仅可以将size变大，还可以将size变小\n  void resize(size_type new_size, const T& x) {\n    //将size变小，erase掉后边所有元素  \n    if (new_size < size()) \n      erase(begin() + new_size, end());\n    //将size变大\n    else\n      insert(end(), new_size - size(), x);\n  }\n  void resize(size_type new_size) { resize(new_size, T()); }\n  void clear() { erase(begin(), end()); } \n    \nprotected:\n  //用于构造函数  \n  iterator allocate_and_fill(size_type n, const T& x) {\n    iterator result = data_allocator::allocate(n);\n    __STL_TRY {\n      uninitialized_fill_n(result, n, x);// 全局函数\n      return result;\n    }\n    __STL_UNWIND(data_allocator::deallocate(result, n));\n  }\n  //用于拷贝构造  \n  iterator allocate_and_copy(size_type n,\n                             const_iterator first, const_iterator last) {\n    iterator result = data_allocator::allocate(n);\n    __STL_TRY {\n      uninitialized_copy(first, last, result);\n      return result;\n    }\n    __STL_UNWIND(data_allocator::deallocate(result, n));\n  }\n  //...\n};\n```\n\n# 4 vector的迭代器\n\n（本文基于GNU2.9版本，GNU4.9版本的迭代器单独出类，侯杰的评价的“乱七八糟，舍近求远，何必如此！！”）\n\n因为vector是连续空间，迭代器不必设计太复杂。\n\n迭代器直接在vector类里定义，就是普通指针，没有再封装（不像list的迭代器单独封装成一个类，因为其指向的是node，不是原始的data），属于RandomAccess Iterators。\n\n`*`、`->`、`++`、`--`、 `+`、`-`、 `+- `、`-=`等运算普通指针天生就具备，就没有运算符重载。\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass vector {\npublic:\n  typedef T value_type;\n  typedef value_type* iterator;\n  typedef const value_type* const_iterator;\n  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;\n    \n  iterator begin() { return start; }\n  const_iterator begin() const { return start; }\n  iterator end() { return finish; }\n  const_iterator end() const { return finish; }\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const { \n    return const_reverse_iterator(end()); \n  }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { \n    return const_reverse_iterator(begin()); \n  }\n  //...  \n    \n};\n```\n\n例子：通过萃取traits获得iterator关联类型\n\n```c++\ntemplate<class I>\ntypename iterator_traits<I>::value_type func(I iter) {\n    return *iter;\n}\n\nint main(void) {\n    vector<int> vec = {1, 2, 3};\n    vector<int>::iterator iter = vec.begin();\n    int x = func(iter);\n}\n```\n\n由于vector的iterator是普通指针，匹配偏特化的traits类，即\n\n```c++\n//偏特化：传入类型为原生指针\ntemplate <class T>\nstruct iterator_traits<T*> {\n  typedef random_access_iterator_tag iterator_category;\n  typedef T                          value_type;\n  typedef ptrdiff_t                  difference_type;\n  typedef T*                         pointer;\n  typedef T&                         reference;\n};\n```\n\n# 3 insert\n\n- list新增一个元素是先申请一个node的空间再construct（可以原地扩容）\n- vector新增一个元素是提前把一段空间申请出来，直接construct（不能原地扩容），在扩容的过程中调用的拷贝构造函数和析构函数。多次拷贝会构成性能瓶颈。\n\n```c++\n//在position插入一个元素，如果没有备用空间就扩容\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert_aux(iterator position, const T& x) {\n  //尚有备用空间\n  if (finish != end_of_storage) {\n    //在备用空间起始处创建一个元素，并以vector最后一个元素值为其初值\n    construct(finish, *(finish - 1));\n    //调整水位  \n    ++finish;\n    T x_copy = x;\n    copy_backward(position, finish - 2, finish - 1); //全局方法，像 copy() 那样复制元素，但是从最后一个元素开始直到第一个元素。把从finish-2到position的元素复制到finish-1的位置\n    *position = x_copy;\n  }\n  //已无备用空间  \n  else {\n    const size_type old_size = size();\n    //新创建的vector old_size为0，扩容为1；否则二倍扩容  \n    const size_type len = old_size != 0 ? 2 * old_size : 1;\n    //1. 配置新空间  \n    iterator new_start = data_allocator::allocate(len);\n    iterator new_finish = new_start;\n    __STL_TRY {\n      //2. 数据移动   \n      //2.1拷贝position之前的内容\n      new_finish = uninitialized_copy(start, position, new_start);\n      //2.2为新元素设置初值x\n      construct(new_finish, x);\n      ++new_finish;\n      //2.3拷贝positon之后的内容  \n      new_finish = uninitialized_copy(position, finish, new_finish);\n    }\n\n#       ifdef  __STL_USE_EXCEPTIONS \n    catch(...) {\n      destroy(new_start, new_finish); \n      data_allocator::deallocate(new_start, len);\n      throw;\n    }\n#       endif /* __STL_USE_EXCEPTIONS */\n    //3. 释放旧空间  \n    destroy(begin(), end());//析构\n    deallocate();//释放旧空间\n    start = new_start;\n    finish = new_finish;\n    end_of_storage = new_start + len;\n  }\n}\n```\n\n- vector新增多个元素\n\n```c++\n//在position插入n个元素，如果没有备用空间就扩容\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert(iterator position, size_type n, const T& x) {\n  if (n != 0) {\n    if (size_type(end_of_storage - finish) >= n) {\n      T x_copy = x;\n      const size_type elems_after = finish - position;\n      iterator old_finish = finish;\n      if (elems_after > n) {\n        uninitialized_copy(finish - n, finish, finish);\n        finish += n;\n        copy_backward(position, old_finish - n, old_finish);\n        fill(position, position + n, x_copy);\n      }\n      else {\n        uninitialized_fill_n(finish, n - elems_after, x_copy);\n        finish += n - elems_after;\n        uninitialized_copy(position, old_finish, finish);\n        finish += elems_after;\n        fill(position, old_finish, x_copy);\n      }\n    }\n    else {\n      const size_type old_size = size();        \n      const size_type len = old_size + max(old_size, n);\n      iterator new_start = data_allocator::allocate(len);\n      iterator new_finish = new_start;\n      __STL_TRY {\n        new_finish = uninitialized_copy(start, position, new_start);\n        new_finish = uninitialized_fill_n(new_finish, n, x);\n        new_finish = uninitialized_copy(position, finish, new_finish);\n      }\n#         ifdef  __STL_USE_EXCEPTIONS \n      catch(...) {\n        destroy(new_start, new_finish);\n        data_allocator::deallocate(new_start, len);\n        throw;\n      }\n#         endif /* __STL_USE_EXCEPTIONS */\n      destroy(start, finish);\n      deallocate();\n      start = new_start;\n      finish = new_finish;\n      end_of_storage = new_start + len;\n    }\n  }\n}\n```\n\n'),(40,'STL源码剖析6-deque',0,'2022-10-22 12:42:28','STL源码剖析','# 1 概述\n\n为什么不基于vector实现？vector头部操作效率奇差（这也是vector不提供push_front、pop_front的原因）。\n\ndeque较之于vector：\n\n1. deque可以常数时间内对头部进行元素增删操作\n2. deque没有容量capacity观念（就像list一样），因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。\n\n# 2 数据结构\n\n（全新的数据结构，从未设想的道路！）\n\ndeque由一个中控区和多个缓冲区构成。\n\n中控区是一个map（不是STL的map），这个map是一块小连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。\n\n缓冲区buffer是存储主体，可以指定缓冲区大小，默认512bytes。\n\n![img](https://cdn.moyusoldier.cn/2019121914592048.png)\n\n# 3 __deque_iterator\n\n![img](https://cdn.moyusoldier.cn/20191219150654134.png)\n\n（这个图有点误导，first指向第一个元素，last应该指向下一个缓冲区头，cur指向当前迭代器想要指向的元素）\n\n迭代器单独出类。\n\ndeque是分段连续空间，为实现对外表现出的“整体连续”，需要重载各种指针运算操作，最关键的就是当指针行进时遇到缓冲区边缘的处理。\n\n```c++\n//获得缓冲区大小\ninline size_t __deque_buf_size(size_t n, size_t sz)\n{\n  return n != 0 ? n : (sz < 512 ? size_t(512 / sz) : size_t(1));\n}\n\ntemplate <class T, class Ref, class Ptr>\nstruct __deque_iterator {\n   \n  typedef __deque_iterator<T, T&, T*>             iterator;\n  typedef __deque_iterator<T, const T&, const T*> const_iterator;\n  static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }\n  //未继承std::iterator，所以必须自己声明5 associated types\n  typedef random_access_iterator_tag iterator_category;\n  typedef T value_type;\n  typedef Ptr pointer;\n  typedef Ref reference;\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\n  typedef T** map_pointer;\n\n  typedef __deque_iterator self;\n  //iterator中的四个指针，保持与容器的联系，一共 4 * 4 = 16 bytes\n  T* cur; //指向缓冲区中当前指向元素\n  T* first;//指向缓冲区头\n  T* last;//指向缓冲区尾的下一个位置，即下一个缓冲区头\n  map_pointer node;//指向中控区的node\n\n  __deque_iterator(T* x, map_pointer y) \n    : cur(x), first(*y), last(*y + buffer_size()), node(y) {}\n  __deque_iterator() : cur(0), first(0), last(0), node(0) {}\n  __deque_iterator(const iterator& x)\n    : cur(x.cur), first(x.first), last(x.last), node(x.node) {}\n\n  //跳过一个缓冲区，是各种运算符重载的基础\n  void set_node(map_pointer new_node) {\n    node = new_node;\n    first = *new_node;\n    last = first + difference_type(buffer_size());\n  }  \n    \n  reference operator*() const { return *cur; }\n  pointer operator->() const { return &(operator*()); }\n  //两个迭代器之间的距离  \n  difference_type operator-(const self& x) const {\n    return difference_type(buffer_size()) * (node - x.node - 1) +\n      (cur - first) + (x.last - x.cur);\n  }\n  //prefix increment ++i\n  self& operator++() {\n    ++cur;\n    if (cur == last) {\n      set_node(node + 1);\n      cur = first;\n    }\n    return *this; \n  }\n  //postfix increment i++  \n  self operator++(int)  {\n    self tmp = *this;\n    ++*this;\n    return tmp;\n  }\n\n  self& operator--() {\n    if (cur == first) {\n      set_node(node - 1);\n      cur = last;\n    }\n    --cur;\n    return *this;\n  }\n  self operator--(int) {\n    self tmp = *this;\n    --*this;\n    return tmp;\n  }\n  \n  self& operator+=(difference_type n) {\n    difference_type offset = n + (cur - first);\n    //目标位置在同一缓冲区内  \n    if (offset >= 0 && offset < difference_type(buffer_size()))\n      cur += n;\n    //目标位置不在同一缓冲区  \n    else {\n      //目标node\n      difference_type node_offset =\n        offset > 0 ? offset / difference_type(buffer_size())\n                   : -difference_type((-offset - 1) / buffer_size()) - 1;\n      set_node(node + node_offset);\n      //目标元素  \n      cur = first + (offset - node_offset * difference_type(buffer_size()));\n    }\n    return *this;\n  }\n\n  self operator+(difference_type n) const {\n    self tmp = *this;\n    return tmp += n; //调用operator+=\n  }\n\n  self& operator-=(difference_type n) { return *this += -n; }\n \n  self operator-(difference_type n) const {\n    self tmp = *this;\n    return tmp -= n;//调用operator-=\n  }\n    \n  // 以下实现随机存取，迭代器可以直接跳跃n个距离  \n  reference operator[](difference_type n) const { return *(*this + n); }\n\n  bool operator==(const self& x) const { return cur == x.cur; }\n  bool operator!=(const self& x) const { return !(*this == x); }\n  bool operator<(const self& x) const {\n    return (node == x.node) ? (cur < x.cur) : (node < x.node);\n  }\n};\n```\n\n# 4 deque\n\n```c++\ntemplate <class T, class Alloc = alloc, size_t BufSiz = 0> \nclass deque {\npublic:                         \n  // Basic types\n  typedef T value_type;\n  typedef value_type* pointer;\n  typedef const value_type* const_pointer;\n  typedef value_type& reference;\n  typedef const value_type& const_reference;\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\n\npublic:                         \n  // Iterators\n  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;\n  typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;\n    \n  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;    \n\nprotected:                      \n  // Internal typedefs\n  // 元素指针的指针  \n  typedef pointer* map_pointer;\n  // deque专属的空间配置器，每次配置一个元素大小  \n  typedef simple_alloc<value_type, Alloc> data_allocator;\n  // deque专属的空间配置器，每次配置一个指针大小  \n  typedef simple_alloc<pointer, Alloc> map_allocator;\n\n  static size_type buffer_size() {\n    return __deque_buf_size(BufSiz, sizeof(value_type));\n  }\n  static size_type initial_map_size() { return 8; }\n\nprotected:                      \n  // Data members iterator每个16bytes，map_pointer是指针4bytes，size_type是size_t 4bytes，共40bytes\n  iterator start; //指向deque的头节点的迭代器\n  iterator finish; //指向deque的尾节点的迭代器\n  map_pointer map; //中控区map，连续空间，map中每个node都是指向buffer的指针\n  size_type map_size; //map内有多少指针\n    \npublic:                        \n  iterator begin() { return start; }\n  iterator end() { return finish; }\n  const_iterator begin() const { return start; }\n  const_iterator end() const { return finish; }\n\n  reverse_iterator rbegin() { return reverse_iterator(finish); }\n  reverse_iterator rend() { return reverse_iterator(start); }\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator(finish);\n  }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(start);\n  }\n  reference operator[](size_type n) { return start[difference_type(n)]; }\n  reference operator[](size_type n) { return start[difference_type(n)]; }\n  const_reference operator[](size_type n) const {\n    return start[difference_type(n)];\n  }\n    \n  reference front() { return *start; }\n  reference back() {\n    iterator tmp = finish;\n    --tmp;\n    return *tmp;\n    //为啥不是return *(finish-1);???我觉得行\n  }\n  //两个; 合法但有病  \n  size_type size() const { return finish - start;; }\n  size_type max_size() const { return size_type(-1); }\n  bool empty() const { return finish == start; }\n  \npublic:\n  //constructor1     \n  deque()\n    : start(), finish(), map(0), map_size(0)\n  {\n    create_map_and_nodes(0);\n  }\n  //constructor2 \n  deque(const deque& x)\n    : start(), finish(), map(0), map_size(0)\n  {\n    create_map_and_nodes(x.size());\n    __STL_TRY {\n      uninitialized_copy(x.begin(), x.end(), start);\n    }\n    __STL_UNWIND(destroy_map_and_nodes());\n  }    \n  //constructor3  \n  deque(size_type n, const value_type& value)\n    : start(), finish(), map(0), map_size(0)\n  {\n    fill_initialize(n, value);\n  }\n  //constructor4  \n  deque(int n, const value_type& value)\n    : start(), finish(), map(0), map_size(0)\n  {\n    fill_initialize(n, value);\n  }  \n  //constructor5  \n  deque(long n, const value_type& value)\n    : start(), finish(), map(0), map_size(0)\n  {\n    fill_initialize(n, value);\n  }\n  //constructor6\n  explicit deque(size_type n)\n    : start(), finish(), map(0), map_size(0)\n  {\n    fill_initialize(n, value_type());\n  }\n  //constructor7  \n  template <class InputIterator>\n  deque(InputIterator first, InputIterator last)\n    : start(), finish(), map(0), map_size(0)\n  {\n    range_initialize(first, last, iterator_category(first));\n  }\n  //destructor  \n  ~deque() {\n    destroy(start, finish);\n    destroy_map_and_nodes();\n  }    \n  deque& operator= (const deque& x) {\n    const size_type len = size();\n    if (&x != this) {\n      if (len >= x.size())\n        erase(copy(x.begin(), x.end(), start), finish);\n      else {\n        const_iterator mid = x.begin() + difference_type(len);\n        copy(x.begin(), mid, start);\n        insert(finish, mid, x.end());\n      }\n    }\n    return *this;\n  }        \n\n  void swap(deque& x) {\n    __STD::swap(start, x.start);\n    __STD::swap(finish, x.finish);\n    __STD::swap(map, x.map);\n    __STD::swap(map_size, x.map_size);\n  }    \npublic:                         // push_* and pop_*                        \n    \n  void push_back(const value_type& t) {\n    if (finish.cur != finish.last - 1) {\n      construct(finish.cur, t);\n      ++finish.cur;\n    }\n    // 缓冲区只剩最后面一个空位，扩容\n    // 为啥不是没有空位时候是特判？？？  \n    else\n      push_back_aux(t);\n  }\n\n  void push_front(const value_type& t) {\n    if (start.cur != start.first) {\n      construct(start.cur - 1, t);\n      --start.cur;\n    }\n    // 缓冲区只剩最前面一个空位，扩容\n    else\n      push_front_aux(t);\n  }\n\n  void pop_back() {\n    if (finish.cur != finish.first) {\n      --finish.cur;\n      destroy(finish.cur);\n    }\n    else\n      pop_back_aux();\n  }\n\n  void pop_front() {\n    if (start.cur != start.last - 1) {\n      destroy(start.cur);\n      ++start.cur;\n    }\n    else \n      pop_front_aux();\n  }\n    \n  //map的治理，类似于vector扩容\n  void reserve_map_at_back (size_type nodes_to_add = 1) {\n    // 如果map尾端的节点备用空间不足，必须重新换一个map（配置更大的，拷贝原来的，释放原来的）  \n    if (nodes_to_add + 1 > map_size - (finish.node - map))\n      reallocate_map(nodes_to_add, false);\n  }\n    \n  //map的治理  \n  void reserve_map_at_front (size_type nodes_to_add = 1) {\n	// 如果map前端的节点备用空间不足，必须重新换一个map（配置更大的，拷贝原来的，释放原来的）  \n    if (nodes_to_add > start.node - map)\n      reallocate_map(nodes_to_add, true);\n  }\n    \n  \n//初始化方法，负责产生并安排好deque的结构，并将元素的初值设定妥当    \ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>::fill_initialize(size_type n,\n                                               const value_type& value) {\n  //把deque的结构都产生并安排好  \n  create_map_and_nodes(n);\n  map_pointer cur;\n  __STL_TRY {\n    //未每个节点的缓冲区设定初值  \n    for (cur = start.node; cur < finish.node; ++cur)\n      uninitialized_fill(*cur, *cur + buffer_size(), value);\n    //最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值）  \n    uninitialized_fill(finish.first, finish.cur, value);\n  }\n  catch(...) {\n    //...\n  }\n}  \n  //deque的元素操作  \n  void pop_back() {\n    if (finish.cur != finish.first) {\n      --finish.cur;\n      destroy(finish.cur);\n    }\n    // 最后缓冲区只一个元素，释放缓冲区\n    else\n      pop_back_aux();\n  }\n\n  void pop_front() {\n    if (start.cur != start.last - 1) {\n      destroy(start.cur);\n      ++start.cur;\n    }\n    // 第一个缓冲区只一个元素，释放缓冲区  \n    else \n      pop_front_aux();\n  }\n    \npublic:                        \n  // Erase\n  iterator erase(iterator pos) {\n    iterator next = pos;\n    ++next;\n    difference_type index = pos - start;\n    if (index < (size() >> 1)) {\n      copy_backward(start, pos, next);\n      pop_front();\n    }\n    else {\n      copy(next, finish, pos);\n      pop_back();\n    }\n    return start + index;\n  }\n  //...  \n};\n\n//负责产生并安排好deque的结构\ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) { \n  // 需要节点数=（元素个数/每个缓冲区可容纳的元素个数）+1\n  // 如果刚好整除，会多配一个节点\n  size_type num_nodes = num_elements / buffer_size() + 1;\n  \n  // 一个map要管理几个节点。最少8个，最多是“所需节点数+2”（前后各预留一个，扩充时可用）  \n  map_size = max(initial_map_size(), num_nodes + 2);\n  map = map_allocator::allocate(map_size);\n  // 以上配置出一个“具有map_size个节点”的map\n    \n  // 以下令nstart和nfinish指向map所拥有的全部节点的最中央区段\n  // 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区  \n  map_pointer nstart = map + (map_size - num_nodes) / 2;\n  map_pointer nfinish = nstart + num_nodes - 1;\n    \n  map_pointer cur;\n  __STL_TRY {\n    // 为map内的每个现用节点配置缓冲区。所有缓冲区加起来就是deque的可用空间（最后一个缓冲区可能留有一些余裕）  \n    for (cur = nstart; cur <= nfinish; ++cur)\n      *cur = allocate_node();//cur是指针数组的指针，*cur是数组里该位置的指针的值\n  }\n  catch(...) {\n    //...\n  }\n  // 为deque内的两个迭代器start和end设定正确内容1.node2.cur\n  start.set_node(nstart); //设定node first last\n  finish.set_node(nfinish);\n  start.cur = start.first; //设定cur,至此，迭代器的四个指针都设置完毕\n  finish.cur = finish.first + num_elements % buffer_size(); // 前面说过，如果刚好整除，会多配一个节点，此时即令cur指向多配的这一个节点（所对应的缓冲区）的起始处\n}\n    \n// Called only if finish.cur == finish.last - 1.\n// 只有当缓冲区只剩一个空位才会被调用，先配置一整块新的缓冲区，再设置新元素内容\ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>::push_back_aux(const value_type& t) {\n  value_type t_copy = t;\n  reserve_map_at_back(); // 若符合某种条件则必须重换一个map\n  *(finish.node + 1) = allocate_node(); // 配置一个新的缓冲区\n  __STL_TRY { \n    construct(finish.cur, t_copy); // 在原来缓冲区的空位构造新元素\n    finish.set_node(finish.node + 1); // 设置finish迭代器指向下一个缓冲区\n    finish.cur = finish.first; // 更新finish的first指针\n  }\n  __STL_UNWIND(deallocate_node(*(finish.node + 1)));\n}\n    \n// Called only if start.cur == start.first.\ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>::push_front_aux(const value_type& t) {\n  value_type t_copy = t;\n  reserve_map_at_front();\n  *(start.node - 1) = allocate_node();\n  __STL_TRY {\n    start.set_node(start.node - 1);\n    start.cur = start.last - 1;\n    construct(start.cur, t_copy);\n  }\n  catch(...) {\n    //...\n  }\n} \n 	\n//map的治理\ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add,\n                                              bool add_at_front) {\n  size_type old_num_nodes = finish.node - start.node + 1;\n  size_type new_num_nodes = old_num_nodes + nodes_to_add;\n\n  map_pointer new_nstart;\n  if (map_size > 2 * new_num_nodes) {\n    new_nstart = map + (map_size - new_num_nodes) / 2 \n                     + (add_at_front ? nodes_to_add : 0);\n    if (new_nstart < start.node)\n      copy(start.node, finish.node + 1, new_nstart);\n    else\n      copy_backward(start.node, finish.node + 1, new_nstart + old_num_nodes);\n  }\n  else {\n    size_type new_map_size = map_size + max(map_size, nodes_to_add) + 2;\n\n    map_pointer new_map = map_allocator::allocate(new_map_size);\n    new_nstart = new_map + (new_map_size - new_num_nodes) / 2\n                         + (add_at_front ? nodes_to_add : 0);\n    copy(start.node, finish.node + 1, new_nstart);\n    map_allocator::deallocate(map, map_size);\n\n    map = new_map;\n    map_size = new_map_size;\n  }\n\n  start.set_node(new_nstart);\n  finish.set_node(new_nstart + old_num_nodes - 1);\n}\n\n// Called only if finish.cur == finish.first.\ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>:: pop_back_aux() {\n  deallocate_node(finish.first);\n  finish.set_node(finish.node - 1);\n  finish.cur = finish.last - 1;\n  destroy(finish.cur);\n}\n\n// Called only if start.cur == start.last - 1.  Note that if the deque\n//  has at least one element (a necessary precondition for this member\n//  function), and if start.cur == start.last, then the deque must have\n//  at least two nodes.\ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>::pop_front_aux() {\n  destroy(start.cur);\n  deallocate_node(start.first);\n  start.set_node(start.node + 1);\n  start.cur = start.first;\n}\n\n// 清除整个deque，保有一个缓冲区\ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>::clear() {\n  for (map_pointer node = start.node + 1; node < finish.node; ++node) {\n    destroy(*node, *node + buffer_size());\n    data_allocator::deallocate(*node, buffer_size());\n  }\n\n  if (start.node != finish.node) {\n    destroy(start.cur, start.last);\n    destroy(finish.first, finish.cur);\n    data_allocator::deallocate(finish.first, buffer_size());\n  }\n  else\n    destroy(start.cur, finish.cur);\n\n  finish = start;\n}\n\n//清除[first,last)内的所有元素\ntemplate <class T, class Alloc, size_t BufSize>\ndeque<T, Alloc, BufSize>::iterator \ndeque<T, Alloc, BufSize>::erase(iterator first, iterator last) {\n  if (first == start && last == finish) {\n    clear();\n    return finish;\n  }\n  else {\n    difference_type n = last - first;\n    difference_type elems_before = first - start;\n    if (elems_before < (size() - n) / 2) {\n      copy_backward(start, first, last);\n      iterator new_start = start + n;\n      destroy(start, new_start);\n      for (map_pointer cur = start.node; cur < new_start.node; ++cur)\n        data_allocator::deallocate(*cur, buffer_size());\n      start = new_start;\n    }\n    else {\n      copy(last, finish, first);\n      iterator new_finish = finish - n;\n      destroy(new_finish, finish);\n      for (map_pointer cur = new_finish.node + 1; cur <= finish.node; ++cur)\n        data_allocator::deallocate(*cur, buffer_size());\n      finish = new_finish;\n    }\n    return start + elems_before;\n  }\n}\n\n// 最重要最基础的insert\ntemplate <class T, class Alloc, size_t BufSize>\nvoid deque<T, Alloc, BufSize>::insert(iterator pos,\n                                      size_type n, const value_type& x) {\n  if (pos.cur == start.cur) { \n    iterator new_start = reserve_elements_at_front(n);\n    uninitialized_fill(new_start, start, x);\n    start = new_start;\n  }\n  else if (pos.cur == finish.cur) { // 如果安插点是deque的尾端，交给push_back\n    iterator new_finish = reserve_elements_at_back(n);\n    uninitialized_fill(finish, new_finish, x);\n    finish = new_finish;\n  }\n  else \n    insert_aux(pos, n, x);\n}\n\n// 厉害的地方在于，可以判断安插点离头端近还是离尾端近，从而选择向不同方向“推”元素\ntemplate <class T, class Alloc, size_t BufSize>\ntypename deque<T, Alloc, BufSize>::iterator\ndeque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type& x) {\n  difference_type index = pos - start;// 插入点之前元素个数  \n  value_type x_copy = x;\n  if (index < size() / 2) { // 如果插入点之前的元素个数比较少，向头端“推”元素\n    push_front(front()); // 在最前端加入与第一元素相同值的元素\n    iterator front1 = start; // 移动元素\n    ++front1;\n    iterator front2 = front1;\n    ++front2;\n    pos = start + index;\n    iterator pos1 = pos;\n    ++pos1;\n    copy(front2, pos1, front1);\n  }\n  else {\n    push_back(back());\n    iterator back1 = finish;\n    --back1;\n    iterator back2 = back1;\n    --back2;\n    pos = start + index;\n    copy_backward(pos, back2, back1);\n  }\n  *pos = x_copy;\n  return pos;\n}\n```\n\n'),(41,'STL源码剖析7-queue&stack',1,'2022-10-22 12:43:01','STL源码剖析','# 1 概述\n\nqueue和stack：\n\n- 都是基于deque（包含一个deque），并且封锁一些deque的方法，转调用deque的一些方法，具有这种“修改某物接口，形成另一种风貌”性质者，称为adapter（配接器）。\n\n- 都不允许遍历，也不提供iterator。\n\n- 除了可以基于deque外（默认），还可以基于list，只是性能上要差。\n\n# 2 queue\n\n实现非常简单，以下就是stl_queue.h的全部代码。包含了queue和priority_queue的全部实现。\n\n```c++\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/* NOTE: This is an internal header file, included by other STL headers.\n *   You should not attempt to use it directly.\n */\n\n#ifndef __SGI_STL_INTERNAL_QUEUE_H\n#define __SGI_STL_INTERNAL_QUEUE_H\n\n__STL_BEGIN_NAMESPACE\n\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\ntemplate <class T, class Sequence = deque<T> >\n#else\ntemplate <class T, class Sequence>\n#endif\nclass queue {\n  friend bool operator== __STL_NULL_TMPL_ARGS (const queue& x, const queue& y);\n  friend bool operator< __STL_NULL_TMPL_ARGS (const queue& x, const queue& y);\npublic:\n  typedef typename Sequence::value_type value_type;\n  typedef typename Sequence::size_type size_type;\n  typedef typename Sequence::reference reference;\n  typedef typename Sequence::const_reference const_reference;\nprotected:\n  Sequence c;\npublic:\n  bool empty() const { return c.empty(); }\n  size_type size() const { return c.size(); }\n  reference front() { return c.front(); }\n  const_reference front() const { return c.front(); }\n  reference back() { return c.back(); }\n  const_reference back() const { return c.back(); }\n  void push(const value_type& x) { c.push_back(x); }\n  void pop() { c.pop_front(); }\n};\n\ntemplate <class T, class Sequence>\nbool operator==(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {\n  return x.c == y.c;\n}\n\ntemplate <class T, class Sequence>\nbool operator<(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {\n  return x.c < y.c;\n}\n\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\ntemplate <class T, class Sequence = vector<T>, \n          class Compare = less<typename Sequence::value_type> >\n#else\ntemplate <class T, class Sequence, class Compare>\n#endif\nclass  priority_queue {\npublic:\n  typedef typename Sequence::value_type value_type;\n  typedef typename Sequence::size_type size_type;\n  typedef typename Sequence::reference reference;\n  typedef typename Sequence::const_reference const_reference;\nprotected:\n  Sequence c;\n  Compare comp;\npublic:\n  priority_queue() : c() {}\n  explicit priority_queue(const Compare& x) :  c(), comp(x) {}\n\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  priority_queue(InputIterator first, InputIterator last, const Compare& x)\n    : c(first, last), comp(x) { make_heap(c.begin(), c.end(), comp); }\n  template <class InputIterator>\n  priority_queue(InputIterator first, InputIterator last) \n    : c(first, last) { make_heap(c.begin(), c.end(), comp); }\n#else /* __STL_MEMBER_TEMPLATES */\n  priority_queue(const value_type* first, const value_type* last, \n                 const Compare& x) : c(first, last), comp(x) {\n    make_heap(c.begin(), c.end(), comp);\n  }\n  priority_queue(const value_type* first, const value_type* last) \n    : c(first, last) { make_heap(c.begin(), c.end(), comp); }\n#endif /* __STL_MEMBER_TEMPLATES */\n\n  bool empty() const { return c.empty(); }\n  size_type size() const { return c.size(); }\n  const_reference top() const { return c.front(); }\n  void push(const value_type& x) {\n    __STL_TRY {\n      c.push_back(x); \n      push_heap(c.begin(), c.end(), comp);\n    }\n    __STL_UNWIND(c.clear());\n  }\n  void pop() {\n    __STL_TRY {\n      pop_heap(c.begin(), c.end(), comp);\n      c.pop_back();\n    }\n    __STL_UNWIND(c.clear());\n  }\n};\n\n// no equality is provided\n\n__STL_END_NAMESPACE\n\n#endif /* __SGI_STL_INTERNAL_QUEUE_H */\n\n// Local Variables:\n// mode:C++\n// End:\n\n```\n\n# 3 priority_queue\n\n## 3.1 heap\n\n优先队列是堆heap的一种应用，堆是一颗完全二叉树，涉及到堆操作的函数有（在algorithm中定义）：\n\n- make_heap() 将一段现有的数据转化成一个堆。（默认为大顶堆）\n\npush_heap和pop_heap做的都是调整工作，并不增加或删除数据。\n\n- push_heap() 向堆中插入一个元素。但是，它的默认前提是这个区间 [first,last) 已经满足堆结构，并且要插入的数据已经插入到堆的最后即区间的最后一个位置。即仅仅完成上浮操作。\n- pop_heap() 弹出堆顶元素。这里需要注意的是，pop_heap()并没有删除元素，而是将堆顶元素和vector最后一个元素进行了替换，如果要删除这个元素，还需要对vector进行pop_back()操作。\n\n## 3.2 priority_queue\n\n优先队列是一个以vector表现的完全二叉树。缺省情况下以vector为底部容器。\n\n- 在初始化优先队列时\n  - 为类属性中的vector赋值 \n  - 使用make_heap根据comp规则生成一个堆。\n\n- 在向优先队列插入元素时\n  - c.push_back(x);  //先插入\n  - push_heap(c.begin(), c.end(), comp); //上浮\n- 在弹出优先队列元素时\n  -  pop_heap(c.begin(), c.end(), comp); //堆顶元素和最后一个元素交换 下沉\n  -  c.pop_back();\n\n# 4 stack\n\n实现非常简单，以下就是stl_stack.h的全部代码。包含了stack的全部实现。\n\n```c++\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n */\n\n/* NOTE: This is an internal header file, included by other STL headers.\n *   You should not attempt to use it directly.\n */\n\n#ifndef __SGI_STL_INTERNAL_STACK_H\n#define __SGI_STL_INTERNAL_STACK_H\n\n__STL_BEGIN_NAMESPACE\n\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\ntemplate <class T, class Sequence = deque<T> >\n#else\ntemplate <class T, class Sequence>\n#endif\nclass stack {\n  friend bool operator== __STL_NULL_TMPL_ARGS (const stack&, const stack&);\n  friend bool operator< __STL_NULL_TMPL_ARGS (const stack&, const stack&);\npublic:\n  typedef typename Sequence::value_type value_type;\n  typedef typename Sequence::size_type size_type;\n  typedef typename Sequence::reference reference;\n  typedef typename Sequence::const_reference const_reference;\nprotected:\n  Sequence c;\npublic:\n  bool empty() const { return c.empty(); }\n  size_type size() const { return c.size(); }\n  reference top() { return c.back(); }\n  const_reference top() const { return c.back(); }\n  void push(const value_type& x) { c.push_back(x); }\n  void pop() { c.pop_back(); }\n};\n\ntemplate <class T, class Sequence>\nbool operator==(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {\n  return x.c == y.c;\n}\n\ntemplate <class T, class Sequence>\nbool operator<(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {\n  return x.c < y.c;\n}\n\n__STL_END_NAMESPACE\n\n#endif /* __SGI_STL_INTERNAL_STACK_H */\n\n// Local Variables:\n// mode:C++\n// End:\n\n```\n\n'),(42,'STL源码剖析8-rb tree',0,'2022-10-22 12:43:48','STL源码剖析','从 RB tree开始正式进入关联式容器的学习。\n\n关联式容器基本数据结构：RB tree、hash_table\n\n序列式容器基本数据结构：（array）、vector、list、（slist）、deque\n\n# 1 定义\n\nRB tree是一颗 平衡二叉搜索树，平衡性比AVL树（任何节点的左右子树高度$\\leq$1）弱。\n\n一种提供高效search和insert的数据结构。\n\n定义：\n\n1. 节点是红色或者黑色\n2. 根节点是黑色\n3. 所有叶子都是黑色（叶子是NIL节点）\n4. 每个红色节点的两个子节点都是黑色（从每个叶子到跟的所有路径上不能有两个连续的红色节点）\n5. 从任一节点至其叶子节点的任何路径，包含相同数目的黑色节点\n\n# 2 性质\n\n根据规则4和5，从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。\n\n# 3 插入\n\n分两步：\n\n1. 当作一颗BST（二叉搜索树）去插入\n2. 维护RB tree \n\n ## 3.1 被插入的节点是根节点\n\n直接把此节点设为黑色\n\n## 3.2 被插入的节点的父节点是黑色\n\n直接把此节点设为红色\n\n## 3.3 被插入的节点的父节点是红色\n\n### 3.3.1 叔父节点是红色\n\n1. 父节点设为黑色\n2. 叔父节点设为黑色\n3. 祖父节点设为红色\n4. 将祖父节点设为当前节点（红色节点），即，之后继续对“当前节点”进行操作。（最上面出现连续两个红色节点，即曾祖父节点也是红色，需向上递归。）\n\n![image-20220822203711675](https://cdn.moyusoldier.cn/image-20220822203711675.png)\n\n### 3.3.2 叔父节点是黑色，且当前节点是其父节点的右孩子\n\n1. 将父节点作为新的当前节点\n2. 以新的当前节点为支点进行左旋\n\n![image-20220823105449524](https://cdn.moyusoldier.cn/image-20220823105449524.png)\n\n \n\n### 3.3.3 叔父节点是黑色，且当前节点是其父节点的左孩子\n\n1. 将父节点设为黑色\n2. 将祖父节点设为红色\n3. 以祖父节点为支点进行右旋\n\n![image-20220823110032098](https://cdn.moyusoldier.cn/image-20220823110032098.png)\n\n注：上图看似不符合红黑树的第五条定义，但叔父节点其实是NIL节点，NIL节点被视作黑色。\n\n![image-20220823122258260](https://cdn.moyusoldier.cn/image-20220823122258260.png)\n\n# 4 删除\n\n分两步：\n\n1. 当作一颗BST（二叉搜索树）去删除\n2. 维护RB tree \n\n复习BST的删除：\n\n1. 若该节点无左右孩子，直接删除\n2. 若该节点只有左孩子或只有右孩子，删除后直接将左孩子/右孩子移至该节点\n3. 若该节点同时有左孩子和右孩子，则删除后，将后继节点（右子树的最小值）移至该节点，若后继节点有右孩子，按2处理\n\n## 4.1 被删除的节点是红色点\n\n删除后无需其它操作\n\n## 4.2 被删除的节点是黑色点\n\n删除后X在原本颜色的基础上加上一个黑色（为了满足定义5），变为“红+黑”或“黑+黑”双色，拥有两份权重。\n\n### 4.2.1 x指向一个“红+黑”节点\n\n将x设为一个“黑”节点即可。\n\n### 4.2.2 x指向一个“黑+黑”节点\n\n若x指向根，则将x设为一个“黑”节点即可。（所有路径都要经过根节点，删除一个黑色依然满足定义5）\n\n否则， \n\n（1）x的兄弟节点是红色\n\n1. 将x的兄弟节点设为\"黑色”\n\n2. 将x的父节点设为”红色”\n\n3. 对x的父节点进行左旋\n4. 左旋后，重新设置x的兄弟节点\n\n以上操作的目的是转为情况2 3 4，一旦执行，只会执行一次。\n\n![image-20220823225230377](https://cdn.moyusoldier.cn/image-20220823225230377.png)\n\n（2）x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。\n\n1. 将x的兄弟节点设为\"红色”。\n2. 设置\"x的父节点\"为\"新的x节点”。\n\n以上操作的目的是将要处理的节点向上递归一层，最多执行$log(n)$次。\n\n![image-20220823225337881](https://cdn.moyusoldier.cn/image-20220823225337881.png)\n\n（3）x的兄弟节点是黑色;x的兄弟节点的左孩子是红色，右孩子是黑色的。\n\n1. 将x兄弟节点的左孩子设为\"黑色\"\n2. 将x兄弟节点设为”红色\"。\n3. 对x的兄弟节点进行右旋。\n4. 右旋后，重新设置x的兄弟节点。\n\n以上操作的目的是转为情况4，一旦执行，只会执行一次。\n\n![image-20220823230111117](https://cdn.moyusoldier.cn/image-20220823230111117.png)\n\n（4）x的兄弟节点是黑色; x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。\n\n1. 将x父节点颜色赋值给x的兄弟节点。\n2. 将x父节点设置为“黑色”\n3. 将x兄弟节点的右节点设为“黑色”\n4. 对x的父节点进行左旋\n\n以上操作完成后可以直接解决，“黑+黑”变为“黑”。执行一次就结束了。\n\n![qk4](https://cdn.moyusoldier.cn/qk4.png)\n\n# 5 STL实现\n\n迭代器：\n\n1. rb tree 提供迭代器，按照正常规则（++）遍历，得到的是排序后的状态（即中序遍历）。\n\n![image-20220830212137465](https://cdn.moyusoldier.cn/image-20220830212137465.png)\n\n2. **不应该**使用rb tree的迭代器改变元素的值（因为元素有其严谨的排序规则）。编程层面没有禁止这个事情，因为rb tree即将为set和map服务，而map按照key排序，允许data改变，不允许key改变。\n\n> 在本书中，map的键称为key，值称为data，键值对key+data称为value。\n\n3. rb tree的元素能不能重复？rb tree提供了两种插入方式：insert_unique()和insert_equal()。插入相同的元素，insert_unique()不会做任何操作，insert_equal()会在相同元素旁边安插（具体细节对程序员透明）。\n\n以下为stl_tree.h中rb_tree类的实现\n\n```c++\n// 5个模板参数\n// Key-键值对的键key\n// Value-键值对的键和值key+data=value\n// keyOfValue-如何取出key\n// Compare-key按照什么规则比大小\n// Alloc-空间配置器\ntemplate <class Key, class Value, class KeyOfValue, class Compare,\n          class Alloc = alloc>\nclass rb_tree {\nprotected:\n  typedef void* void_pointer;\n  typedef __rb_tree_node_base* base_ptr;\n  typedef __rb_tree_node<Value> rb_tree_node;\n  typedef simple_alloc<rb_tree_node, Alloc> rb_tree_node_allocator;\n  typedef __rb_tree_color_type color_type;\npublic:\n  typedef Key key_type; \n  typedef Value value_type; \n  typedef value_type* pointer;\n  typedef const value_type* const_pointer;\n  typedef value_type& reference;\n  typedef const value_type& const_reference;\n  typedef rb_tree_node* link_type;\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\nprotected:\n  link_type get_node() { return rb_tree_node_allocator::allocate(); }\n  void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }\n\n  link_type create_node(const value_type& x) {\n    link_type tmp = get_node();\n    __STL_TRY {\n      construct(&tmp->value_field, x);\n    }\n    __STL_UNWIND(put_node(tmp));\n    return tmp;\n  }\n\n  link_type clone_node(link_type x) {\n    link_type tmp = create_node(x->value_field);\n    tmp->color = x->color;\n    tmp->left = 0;\n    tmp->right = 0;\n    return tmp;\n  }\n\n  void destroy_node(link_type p) {\n    destroy(&p->value_field);\n    put_node(p);\n  }\n\nprotected:\n  // 3个数据 rb tree的初始大小为9bytes->12bytes(内存对齐)\n  size_type node_count; // keeps track of size of tree 有几个节点 （4bytes)\n  link_type header; // 指向根节点的指针，和list中node的设计有异曲同工之妙 (指针4bytes)\n  Compare key_compare; // key按照什么规则比大小 (仿函数，无数据成员，编译器对大小为0的类实例化的对象大小为1bytes)\n\n  link_type& root() const { return (link_type&) header->parent; }\n  link_type& leftmost() const { return (link_type&) header->left; }\n  link_type& rightmost() const { return (link_type&) header->right; }\n\n  static link_type& left(link_type x) { return (link_type&)(x->left); }\n  static link_type& right(link_type x) { return (link_type&)(x->right); }\n  static link_type& parent(link_type x) { return (link_type&)(x->parent); }\n  static reference value(link_type x) { return x->value_field; }\n  static const Key& key(link_type x) { return KeyOfValue()(value(x)); }\n  static color_type& color(link_type x) { return (color_type&)(x->color); }\n\n  static link_type& left(base_ptr x) { return (link_type&)(x->left); }\n  static link_type& right(base_ptr x) { return (link_type&)(x->right); }\n  static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }\n  static reference value(base_ptr x) { return ((link_type)x)->value_field; }\n  static const Key& key(base_ptr x) { return KeyOfValue()(value(link_type(x)));} \n  static color_type& color(base_ptr x) { return (color_type&)(link_type(x)->color); }\n\n  static link_type minimum(link_type x) { \n    return (link_type)  __rb_tree_node_base::minimum(x);\n  }\n  static link_type maximum(link_type x) {\n    return (link_type) __rb_tree_node_base::maximum(x);\n  }\n\npublic:\n  typedef __rb_tree_iterator<value_type, reference, pointer> iterator;\n  typedef __rb_tree_iterator<value_type, const_reference, const_pointer> \n          const_iterator;\n\n#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;\n#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n  typedef reverse_bidirectional_iterator<iterator, value_type, reference,\n                                         difference_type>\n          reverse_iterator; \n  typedef reverse_bidirectional_iterator<const_iterator, value_type,\n                                         const_reference, difference_type>\n          const_reverse_iterator;\n#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \nprivate:\n  iterator __insert(base_ptr x, base_ptr y, const value_type& v);\n  link_type __copy(link_type x, link_type p);\n  void __erase(link_type x);\n  void init() {\n    header = get_node();\n    color(header) = __rb_tree_red; // used to distinguish header from \n                                   // root, in iterator.operator++\n    root() = 0;\n    leftmost() = header;\n    rightmost() = header;\n  }\npublic:\n                                // allocation/deallocation\n  rb_tree(const Compare& comp = Compare())\n    : node_count(0), key_compare(comp) { init(); }\n\n  rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) \n    : node_count(0), key_compare(x.key_compare)\n  { \n    header = get_node();\n    color(header) = __rb_tree_red;\n    if (x.root() == 0) {\n      root() = 0;\n      leftmost() = header;\n      rightmost() = header;\n    }\n    else {\n      __STL_TRY {\n        root() = __copy(x.root(), header);\n      }\n      __STL_UNWIND(put_node(header));\n      leftmost() = minimum(root());\n      rightmost() = maximum(root());\n    }\n    node_count = x.node_count;\n  }\n  ~rb_tree() {\n    clear();\n    put_node(header);\n  }\n  rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& \n  operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x);\n\npublic:    \n                                // accessors:\n  Compare key_comp() const { return key_compare; }\n  iterator begin() { return leftmost(); }\n  const_iterator begin() const { return leftmost(); }\n  iterator end() { return header; }\n  const_iterator end() const { return header; }\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const { \n    return const_reverse_iterator(end()); \n  }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { \n    return const_reverse_iterator(begin());\n  } \n  bool empty() const { return node_count == 0; }\n  size_type size() const { return node_count; }\n  size_type max_size() const { return size_type(-1); }\n\n  void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t) {\n    __STD::swap(header, t.header);\n    __STD::swap(node_count, t.node_count);\n    __STD::swap(key_compare, t.key_compare);\n  }\n    \npublic:\n                                // insert/erase\n  pair<iterator,bool> insert_unique(const value_type& x);\n  iterator insert_equal(const value_type& x);\n\n  iterator insert_unique(iterator position, const value_type& x);\n  iterator insert_equal(iterator position, const value_type& x);\n\n#ifdef __STL_MEMBER_TEMPLATES  \n  template <class InputIterator>\n  void insert_unique(InputIterator first, InputIterator last);\n  template <class InputIterator>\n  void insert_equal(InputIterator first, InputIterator last);\n#else /* __STL_MEMBER_TEMPLATES */\n  void insert_unique(const_iterator first, const_iterator last);\n  void insert_unique(const value_type* first, const value_type* last);\n  void insert_equal(const_iterator first, const_iterator last);\n  void insert_equal(const value_type* first, const value_type* last);\n#endif /* __STL_MEMBER_TEMPLATES */\n\n  void erase(iterator position);\n  size_type erase(const key_type& x);\n  void erase(iterator first, iterator last);\n  void erase(const key_type* first, const key_type* last);\n  void clear() {\n    if (node_count != 0) {\n      __erase(root());\n      leftmost() = header;\n      root() = 0;\n      rightmost() = header;\n      node_count = 0;\n    }\n  }      \n\npublic:\n                                // set operations:\n  iterator find(const key_type& x);\n  const_iterator find(const key_type& x) const;\n  size_type count(const key_type& x) const;\n  iterator lower_bound(const key_type& x);\n  const_iterator lower_bound(const key_type& x) const;\n  iterator upper_bound(const key_type& x);\n  const_iterator upper_bound(const key_type& x) const;\n  pair<iterator,iterator> equal_range(const key_type& x);\n  pair<const_iterator, const_iterator> equal_range(const key_type& x) const;\n\npublic:\n                                // Debugging.\n  bool __rb_verify() const;\n};\n```\n\n以下为完整源码，注意最重要的两个insert函数的实现。\n\n```c++\n/*\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n *\n */\n\n/* NOTE: This is an internal header file, included by other STL headers.\n *   You should not attempt to use it directly.\n */\n\n#ifndef __SGI_STL_INTERNAL_TREE_H\n#define __SGI_STL_INTERNAL_TREE_H\n\n/*\n\nRed-black tree class, designed for use in implementing STL\nassociative containers (set, multiset, map, and multimap). The\ninsertion and deletion algorithms are based on those in Cormen,\nLeiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990),\nexcept that\n\n(1) the header cell is maintained with links not only to the root\nbut also to the leftmost node of the tree, to enable constant time\nbegin(), and to the rightmost node of the tree, to enable linear time\nperformance when used with the generic set algorithms (set_union,\netc.);\n\n(2) when a node being deleted has two children its successor node is\nrelinked into its place, rather than copied, so that the only\niterators invalidated are those referring to the deleted node.\n\n*/\n\n#include <stl_algobase.h>\n#include <stl_alloc.h>\n#include <stl_construct.h>\n#include <stl_function.h>\n\n__STL_BEGIN_NAMESPACE \n\ntypedef bool __rb_tree_color_type;\nconst __rb_tree_color_type __rb_tree_red = false;\nconst __rb_tree_color_type __rb_tree_black = true;\n\nstruct __rb_tree_node_base\n{\n  typedef __rb_tree_color_type color_type;\n  typedef __rb_tree_node_base* base_ptr;\n\n  color_type color; \n  base_ptr parent;\n  base_ptr left;\n  base_ptr right;\n\n  static base_ptr minimum(base_ptr x)\n  {\n    while (x->left != 0) x = x->left;\n    return x;\n  }\n\n  static base_ptr maximum(base_ptr x)\n  {\n    while (x->right != 0) x = x->right;\n    return x;\n  }\n};\n\ntemplate <class Value>\nstruct __rb_tree_node : public __rb_tree_node_base\n{\n  typedef __rb_tree_node<Value>* link_type;\n  Value value_field;\n};\n\n\nstruct __rb_tree_base_iterator\n{\n  typedef __rb_tree_node_base::base_ptr base_ptr;\n  typedef bidirectional_iterator_tag iterator_category;\n  typedef ptrdiff_t difference_type;\n  base_ptr node;\n\n  void increment()\n  {\n    if (node->right != 0) {\n      node = node->right;\n      while (node->left != 0)\n        node = node->left;\n    }\n    else {\n      base_ptr y = node->parent;\n      while (node == y->right) {\n        node = y;\n        y = y->parent;\n      }\n      if (node->right != y)\n        node = y;\n    }\n  }\n\n  void decrement()\n  {\n    if (node->color == __rb_tree_red &&\n        node->parent->parent == node)\n      node = node->right;\n    else if (node->left != 0) {\n      base_ptr y = node->left;\n      while (y->right != 0)\n        y = y->right;\n      node = y;\n    }\n    else {\n      base_ptr y = node->parent;\n      while (node == y->left) {\n        node = y;\n        y = y->parent;\n      }\n      node = y;\n    }\n  }\n};\n\ntemplate <class Value, class Ref, class Ptr>\nstruct __rb_tree_iterator : public __rb_tree_base_iterator\n{\n  typedef Value value_type;\n  typedef Ref reference;\n  typedef Ptr pointer;\n  typedef __rb_tree_iterator<Value, Value&, Value*>             iterator;\n  typedef __rb_tree_iterator<Value, const Value&, const Value*> const_iterator;\n  typedef __rb_tree_iterator<Value, Ref, Ptr>                   self;\n  typedef __rb_tree_node<Value>* link_type;\n\n  __rb_tree_iterator() {}\n  __rb_tree_iterator(link_type x) { node = x; }\n  __rb_tree_iterator(const iterator& it) { node = it.node; }\n\n  reference operator*() const { return link_type(node)->value_field; }\n#ifndef __SGI_STL_NO_ARROW_OPERATOR\n  pointer operator->() const { return &(operator*()); }\n#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n\n  self& operator++() { increment(); return *this; }\n  self operator++(int) {\n    self tmp = *this;\n    increment();\n    return tmp;\n  }\n    \n  self& operator--() { decrement(); return *this; }\n  self operator--(int) {\n    self tmp = *this;\n    decrement();\n    return tmp;\n  }\n};\n\ninline bool operator==(const __rb_tree_base_iterator& x,\n                       const __rb_tree_base_iterator& y) {\n  return x.node == y.node;\n}\n\ninline bool operator!=(const __rb_tree_base_iterator& x,\n                       const __rb_tree_base_iterator& y) {\n  return x.node != y.node;\n}\n\n#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n\ninline bidirectional_iterator_tag\niterator_category(const __rb_tree_base_iterator&) {\n  return bidirectional_iterator_tag();\n}\n\ninline __rb_tree_base_iterator::difference_type*\ndistance_type(const __rb_tree_base_iterator&) {\n  return (__rb_tree_base_iterator::difference_type*) 0;\n}\n\ntemplate <class Value, class Ref, class Ptr>\ninline Value* value_type(const __rb_tree_iterator<Value, Ref, Ptr>&) {\n  return (Value*) 0;\n}\n\n#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n\ninline void \n__rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*& root)\n{\n  __rb_tree_node_base* y = x->right;\n  x->right = y->left;\n  if (y->left !=0)\n    y->left->parent = x;\n  y->parent = x->parent;\n\n  if (x == root)\n    root = y;\n  else if (x == x->parent->left)\n    x->parent->left = y;\n  else\n    x->parent->right = y;\n  y->left = x;\n  x->parent = y;\n}\n\ninline void \n__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*& root)\n{\n  __rb_tree_node_base* y = x->left;\n  x->left = y->right;\n  if (y->right != 0)\n    y->right->parent = x;\n  y->parent = x->parent;\n\n  if (x == root)\n    root = y;\n  else if (x == x->parent->right)\n    x->parent->right = y;\n  else\n    x->parent->left = y;\n  y->right = x;\n  x->parent = y;\n}\n\ninline void \n__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*& root)\n{\n  x->color = __rb_tree_red;\n  while (x != root && x->parent->color == __rb_tree_red) {\n    if (x->parent == x->parent->parent->left) {\n      __rb_tree_node_base* y = x->parent->parent->right;\n      if (y && y->color == __rb_tree_red) {\n        x->parent->color = __rb_tree_black;\n        y->color = __rb_tree_black;\n        x->parent->parent->color = __rb_tree_red;\n        x = x->parent->parent;\n      }\n      else {\n        if (x == x->parent->right) {\n          x = x->parent;\n          __rb_tree_rotate_left(x, root);\n        }\n        x->parent->color = __rb_tree_black;\n        x->parent->parent->color = __rb_tree_red;\n        __rb_tree_rotate_right(x->parent->parent, root);\n      }\n    }\n    else {\n      __rb_tree_node_base* y = x->parent->parent->left;\n      if (y && y->color == __rb_tree_red) {\n        x->parent->color = __rb_tree_black;\n        y->color = __rb_tree_black;\n        x->parent->parent->color = __rb_tree_red;\n        x = x->parent->parent;\n      }\n      else {\n        if (x == x->parent->left) {\n          x = x->parent;\n          __rb_tree_rotate_right(x, root);\n        }\n        x->parent->color = __rb_tree_black;\n        x->parent->parent->color = __rb_tree_red;\n        __rb_tree_rotate_left(x->parent->parent, root);\n      }\n    }\n  }\n  root->color = __rb_tree_black;\n}\n\ninline __rb_tree_node_base*\n__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,\n                              __rb_tree_node_base*& root,\n                              __rb_tree_node_base*& leftmost,\n                              __rb_tree_node_base*& rightmost)\n{\n  __rb_tree_node_base* y = z;\n  __rb_tree_node_base* x = 0;\n  __rb_tree_node_base* x_parent = 0;\n  if (y->left == 0)             // z has at most one non-null child. y == z.\n    x = y->right;               // x might be null.\n  else\n    if (y->right == 0)          // z has exactly one non-null child.  y == z.\n      x = y->left;              // x is not null.\n    else {                      // z has two non-null children.  Set y to\n      y = y->right;             //   z\'s successor.  x might be null.\n      while (y->left != 0)\n        y = y->left;\n      x = y->right;\n    }\n  if (y != z) {                 // relink y in place of z.  y is z\'s successor\n    z->left->parent = y; \n    y->left = z->left;\n    if (y != z->right) {\n      x_parent = y->parent;\n      if (x) x->parent = y->parent;\n      y->parent->left = x;      // y must be a left child\n      y->right = z->right;\n      z->right->parent = y;\n    }\n    else\n      x_parent = y;  \n    if (root == z)\n      root = y;\n    else if (z->parent->left == z)\n      z->parent->left = y;\n    else \n      z->parent->right = y;\n    y->parent = z->parent;\n    __STD::swap(y->color, z->color);\n    y = z;\n    // y now points to node to be actually deleted\n  }\n  else {                        // y == z\n    x_parent = y->parent;\n    if (x) x->parent = y->parent;   \n    if (root == z)\n      root = x;\n    else \n      if (z->parent->left == z)\n        z->parent->left = x;\n      else\n        z->parent->right = x;\n    if (leftmost == z) \n      if (z->right == 0)        // z->left must be null also\n        leftmost = z->parent;\n    // makes leftmost == header if z == root\n      else\n        leftmost = __rb_tree_node_base::minimum(x);\n    if (rightmost == z)  \n      if (z->left == 0)         // z->right must be null also\n        rightmost = z->parent;  \n    // makes rightmost == header if z == root\n      else                      // x == z->left\n        rightmost = __rb_tree_node_base::maximum(x);\n  }\n  if (y->color != __rb_tree_red) { \n    while (x != root && (x == 0 || x->color == __rb_tree_black))\n      if (x == x_parent->left) {\n        __rb_tree_node_base* w = x_parent->right;\n        if (w->color == __rb_tree_red) {\n          w->color = __rb_tree_black;\n          x_parent->color = __rb_tree_red;\n          __rb_tree_rotate_left(x_parent, root);\n          w = x_parent->right;\n        }\n        if ((w->left == 0 || w->left->color == __rb_tree_black) &&\n            (w->right == 0 || w->right->color == __rb_tree_black)) {\n          w->color = __rb_tree_red;\n          x = x_parent;\n          x_parent = x_parent->parent;\n        } else {\n          if (w->right == 0 || w->right->color == __rb_tree_black) {\n            if (w->left) w->left->color = __rb_tree_black;\n            w->color = __rb_tree_red;\n            __rb_tree_rotate_right(w, root);\n            w = x_parent->right;\n          }\n          w->color = x_parent->color;\n          x_parent->color = __rb_tree_black;\n          if (w->right) w->right->color = __rb_tree_black;\n          __rb_tree_rotate_left(x_parent, root);\n          break;\n        }\n      } else {                  // same as above, with right <-> left.\n        __rb_tree_node_base* w = x_parent->left;\n        if (w->color == __rb_tree_red) {\n          w->color = __rb_tree_black;\n          x_parent->color = __rb_tree_red;\n          __rb_tree_rotate_right(x_parent, root);\n          w = x_parent->left;\n        }\n        if ((w->right == 0 || w->right->color == __rb_tree_black) &&\n            (w->left == 0 || w->left->color == __rb_tree_black)) {\n          w->color = __rb_tree_red;\n          x = x_parent;\n          x_parent = x_parent->parent;\n        } else {\n          if (w->left == 0 || w->left->color == __rb_tree_black) {\n            if (w->right) w->right->color = __rb_tree_black;\n            w->color = __rb_tree_red;\n            __rb_tree_rotate_left(w, root);\n            w = x_parent->left;\n          }\n          w->color = x_parent->color;\n          x_parent->color = __rb_tree_black;\n          if (w->left) w->left->color = __rb_tree_black;\n          __rb_tree_rotate_right(x_parent, root);\n          break;\n        }\n      }\n    if (x) x->color = __rb_tree_black;\n  }\n  return y;\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare,\n          class Alloc = alloc>\nclass rb_tree {\nprotected:\n  typedef void* void_pointer;\n  typedef __rb_tree_node_base* base_ptr;\n  typedef __rb_tree_node<Value> rb_tree_node;\n  typedef simple_alloc<rb_tree_node, Alloc> rb_tree_node_allocator;\n  typedef __rb_tree_color_type color_type;\npublic:\n  typedef Key key_type;\n  typedef Value value_type;\n  typedef value_type* pointer;\n  typedef const value_type* const_pointer;\n  typedef value_type& reference;\n  typedef const value_type& const_reference;\n  typedef rb_tree_node* link_type;\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\nprotected:\n  link_type get_node() { return rb_tree_node_allocator::allocate(); }\n  void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }\n\n  link_type create_node(const value_type& x) {\n    link_type tmp = get_node();\n    __STL_TRY {\n      construct(&tmp->value_field, x);\n    }\n    __STL_UNWIND(put_node(tmp));\n    return tmp;\n  }\n\n  link_type clone_node(link_type x) {\n    link_type tmp = create_node(x->value_field);\n    tmp->color = x->color;\n    tmp->left = 0;\n    tmp->right = 0;\n    return tmp;\n  }\n\n  void destroy_node(link_type p) {\n    destroy(&p->value_field);\n    put_node(p);\n  }\n\nprotected:\n  size_type node_count; // keeps track of size of tree\n  link_type header;  \n  Compare key_compare;\n\n  link_type& root() const { return (link_type&) header->parent; }\n  link_type& leftmost() const { return (link_type&) header->left; }\n  link_type& rightmost() const { return (link_type&) header->right; }\n\n  static link_type& left(link_type x) { return (link_type&)(x->left); }\n  static link_type& right(link_type x) { return (link_type&)(x->right); }\n  static link_type& parent(link_type x) { return (link_type&)(x->parent); }\n  static reference value(link_type x) { return x->value_field; }\n  static const Key& key(link_type x) { return KeyOfValue()(value(x)); }\n  static color_type& color(link_type x) { return (color_type&)(x->color); }\n\n  static link_type& left(base_ptr x) { return (link_type&)(x->left); }\n  static link_type& right(base_ptr x) { return (link_type&)(x->right); }\n  static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }\n  static reference value(base_ptr x) { return ((link_type)x)->value_field; }\n  static const Key& key(base_ptr x) { return KeyOfValue()(value(link_type(x)));} \n  static color_type& color(base_ptr x) { return (color_type&)(link_type(x)->color); }\n\n  static link_type minimum(link_type x) { \n    return (link_type)  __rb_tree_node_base::minimum(x);\n  }\n  static link_type maximum(link_type x) {\n    return (link_type) __rb_tree_node_base::maximum(x);\n  }\n\npublic:\n  typedef __rb_tree_iterator<value_type, reference, pointer> iterator;\n  typedef __rb_tree_iterator<value_type, const_reference, const_pointer> \n          const_iterator;\n\n#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;\n#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n  typedef reverse_bidirectional_iterator<iterator, value_type, reference,\n                                         difference_type>\n          reverse_iterator; \n  typedef reverse_bidirectional_iterator<const_iterator, value_type,\n                                         const_reference, difference_type>\n          const_reverse_iterator;\n#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ \nprivate:\n  iterator __insert(base_ptr x, base_ptr y, const value_type& v);\n  link_type __copy(link_type x, link_type p);\n  void __erase(link_type x);\n  void init() {\n    header = get_node();\n    color(header) = __rb_tree_red; // used to distinguish header from \n                                   // root, in iterator.operator++\n    root() = 0;\n    leftmost() = header;\n    rightmost() = header;\n  }\npublic:\n                                // allocation/deallocation\n  rb_tree(const Compare& comp = Compare())\n    : node_count(0), key_compare(comp) { init(); }\n\n  rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) \n    : node_count(0), key_compare(x.key_compare)\n  { \n    header = get_node();\n    color(header) = __rb_tree_red;\n    if (x.root() == 0) {\n      root() = 0;\n      leftmost() = header;\n      rightmost() = header;\n    }\n    else {\n      __STL_TRY {\n        root() = __copy(x.root(), header);\n      }\n      __STL_UNWIND(put_node(header));\n      leftmost() = minimum(root());\n      rightmost() = maximum(root());\n    }\n    node_count = x.node_count;\n  }\n  ~rb_tree() {\n    clear();\n    put_node(header);\n  }\n  rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& \n  operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x);\n\npublic:    \n                                // accessors:\n  Compare key_comp() const { return key_compare; }\n  iterator begin() { return leftmost(); }\n  const_iterator begin() const { return leftmost(); }\n  iterator end() { return header; }\n  const_iterator end() const { return header; }\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const { \n    return const_reverse_iterator(end()); \n  }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { \n    return const_reverse_iterator(begin());\n  } \n  bool empty() const { return node_count == 0; }\n  size_type size() const { return node_count; }\n  size_type max_size() const { return size_type(-1); }\n\n  void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t) {\n    __STD::swap(header, t.header);\n    __STD::swap(node_count, t.node_count);\n    __STD::swap(key_compare, t.key_compare);\n  }\n    \npublic:\n                                // insert/erase\n  pair<iterator,bool> insert_unique(const value_type& x);\n  iterator insert_equal(const value_type& x);\n\n  iterator insert_unique(iterator position, const value_type& x);\n  iterator insert_equal(iterator position, const value_type& x);\n\n#ifdef __STL_MEMBER_TEMPLATES  \n  template <class InputIterator>\n  void insert_unique(InputIterator first, InputIterator last);\n  template <class InputIterator>\n  void insert_equal(InputIterator first, InputIterator last);\n#else /* __STL_MEMBER_TEMPLATES */\n  void insert_unique(const_iterator first, const_iterator last);\n  void insert_unique(const value_type* first, const value_type* last);\n  void insert_equal(const_iterator first, const_iterator last);\n  void insert_equal(const value_type* first, const value_type* last);\n#endif /* __STL_MEMBER_TEMPLATES */\n\n  void erase(iterator position);\n  size_type erase(const key_type& x);\n  void erase(iterator first, iterator last);\n  void erase(const key_type* first, const key_type* last);\n  void clear() {\n    if (node_count != 0) {\n      __erase(root());\n      leftmost() = header;\n      root() = 0;\n      rightmost() = header;\n      node_count = 0;\n    }\n  }      \n\npublic:\n                                // set operations:\n  iterator find(const key_type& x);\n  const_iterator find(const key_type& x) const;\n  size_type count(const key_type& x) const;\n  iterator lower_bound(const key_type& x);\n  const_iterator lower_bound(const key_type& x) const;\n  iterator upper_bound(const key_type& x);\n  const_iterator upper_bound(const key_type& x) const;\n  pair<iterator,iterator> equal_range(const key_type& x);\n  pair<const_iterator, const_iterator> equal_range(const key_type& x) const;\n\npublic:\n                                // Debugging.\n  bool __rb_verify() const;\n};\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ninline bool operator==(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, \n                       const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y) {\n  return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ninline bool operator<(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, \n                      const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y) {\n  return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());\n}\n\n#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ninline void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, \n                 rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& y) {\n  x.swap(y);\n}\n\n#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>& \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::\noperator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) {\n  if (this != &x) {\n                                // Note that Key may be a constant type.\n    clear();\n    node_count = 0;\n    key_compare = x.key_compare;        \n    if (x.root() == 0) {\n      root() = 0;\n      leftmost() = header;\n      rightmost() = header;\n    }\n    else {\n      root() = __copy(x.root(), header);\n      leftmost() = minimum(root());\n      rightmost() = maximum(root());\n      node_count = x.node_count;\n    }\n  }\n  return *this;\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator\nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::\n__insert(base_ptr x_, base_ptr y_, const Value& v) {\n  link_type x = (link_type) x_;\n  link_type y = (link_type) y_;\n  link_type z;\n\n  if (y == header || x != 0 || key_compare(KeyOfValue()(v), key(y))) {\n    z = create_node(v);\n    left(y) = z;                // also makes leftmost() = z when y == header\n    if (y == header) {\n      root() = z;\n      rightmost() = z;\n    }\n    else if (y == leftmost())\n      leftmost() = z;           // maintain leftmost() pointing to min node\n  }\n  else {\n    z = create_node(v);\n    right(y) = z;\n    if (y == rightmost())\n      rightmost() = z;          // maintain rightmost() pointing to max node\n  }\n  parent(z) = y;\n  left(z) = 0;\n  right(z) = 0;\n  __rb_tree_rebalance(z, header->parent);\n  ++node_count;\n  return iterator(z);\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator\nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value& v)\n{\n  link_type y = header;\n  link_type x = root();\n  while (x != 0) {\n    y = x;\n    x = key_compare(KeyOfValue()(v), key(x)) ? left(x) : right(x);\n  }\n  return __insert(x, y, v);\n}\n\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\npair<typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator, bool>\nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value& v)\n{\n  link_type y = header;\n  link_type x = root();\n  bool comp = true;\n  while (x != 0) {\n    y = x;\n    comp = key_compare(KeyOfValue()(v), key(x));\n    x = comp ? left(x) : right(x);\n  }\n  iterator j = iterator(y);   \n  if (comp)\n    if (j == begin())     \n      return pair<iterator,bool>(__insert(x, y, v), true);\n    else\n      --j;\n  if (key_compare(key(j.node), KeyOfValue()(v)))\n    return pair<iterator,bool>(__insert(x, y, v), true);\n  return pair<iterator,bool>(j, false);\n}\n\n\ntemplate <class Key, class Val, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::iterator \nrb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_unique(iterator position,\n                                                             const Val& v) {\n  if (position.node == header->left) // begin()\n    if (size() > 0 && key_compare(KeyOfValue()(v), key(position.node)))\n      return __insert(position.node, position.node, v);\n  // first argument just needs to be non-null \n    else\n      return insert_unique(v).first;\n  else if (position.node == header) // end()\n    if (key_compare(key(rightmost()), KeyOfValue()(v)))\n      return __insert(0, rightmost(), v);\n    else\n      return insert_unique(v).first;\n  else {\n    iterator before = position;\n    --before;\n    if (key_compare(key(before.node), KeyOfValue()(v))\n        && key_compare(KeyOfValue()(v), key(position.node)))\n      if (right(before.node) == 0)\n        return __insert(0, before.node, v); \n      else\n        return __insert(position.node, position.node, v);\n    // first argument just needs to be non-null \n    else\n      return insert_unique(v).first;\n  }\n}\n\ntemplate <class Key, class Val, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::iterator \nrb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_equal(iterator position,\n                                                            const Val& v) {\n  if (position.node == header->left) // begin()\n    if (size() > 0 && key_compare(KeyOfValue()(v), key(position.node)))\n      return __insert(position.node, position.node, v);\n  // first argument just needs to be non-null \n    else\n      return insert_equal(v);\n  else if (position.node == header) // end()\n    if (!key_compare(KeyOfValue()(v), key(rightmost())))\n      return __insert(0, rightmost(), v);\n    else\n      return insert_equal(v);\n  else {\n    iterator before = position;\n    --before;\n    if (!key_compare(KeyOfValue()(v), key(before.node))\n        && !key_compare(key(position.node), KeyOfValue()(v)))\n      if (right(before.node) == 0)\n        return __insert(0, before.node, v); \n      else\n        return __insert(position.node, position.node, v);\n    // first argument just needs to be non-null \n    else\n      return insert_equal(v);\n  }\n}\n\n#ifdef __STL_MEMBER_TEMPLATES  \n\ntemplate <class K, class V, class KoV, class Cmp, class Al> template<class II>\nvoid rb_tree<K, V, KoV, Cmp, Al>::insert_equal(II first, II last) {\n  for ( ; first != last; ++first)\n    insert_equal(*first);\n}\n\ntemplate <class K, class V, class KoV, class Cmp, class Al> template<class II>\nvoid rb_tree<K, V, KoV, Cmp, Al>::insert_unique(II first, II last) {\n  for ( ; first != last; ++first)\n    insert_unique(*first);\n}\n\n#else /* __STL_MEMBER_TEMPLATES */\n\ntemplate <class K, class V, class KoV, class Cmp, class Al>\nvoid\nrb_tree<K, V, KoV, Cmp, Al>::insert_equal(const V* first, const V* last) {\n  for ( ; first != last; ++first)\n    insert_equal(*first);\n}\n\ntemplate <class K, class V, class KoV, class Cmp, class Al>\nvoid\nrb_tree<K, V, KoV, Cmp, Al>::insert_equal(const_iterator first,\n                                          const_iterator last) {\n  for ( ; first != last; ++first)\n    insert_equal(*first);\n}\n\ntemplate <class K, class V, class KoV, class Cmp, class A>\nvoid \nrb_tree<K, V, KoV, Cmp, A>::insert_unique(const V* first, const V* last) {\n  for ( ; first != last; ++first)\n    insert_unique(*first);\n}\n\ntemplate <class K, class V, class KoV, class Cmp, class A>\nvoid \nrb_tree<K, V, KoV, Cmp, A>::insert_unique(const_iterator first,\n                                          const_iterator last) {\n  for ( ; first != last; ++first)\n    insert_unique(*first);\n}\n\n#endif /* __STL_MEMBER_TEMPLATES */\n         \ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ninline void\nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {\n  link_type y = (link_type) __rb_tree_rebalance_for_erase(position.node,\n                                                          header->parent,\n                                                          header->left,\n                                                          header->right);\n  destroy_node(y);\n  --node_count;\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::size_type \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key& x) {\n  pair<iterator,iterator> p = equal_range(x);\n  size_type n = 0;\n  distance(p.first, p.second, n);\n  erase(p.first, p.second);\n  return n;\n}\n\ntemplate <class K, class V, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<K, V, KeyOfValue, Compare, Alloc>::link_type \nrb_tree<K, V, KeyOfValue, Compare, Alloc>::__copy(link_type x, link_type p) {\n                                // structural copy.  x and p must be non-null.\n  link_type top = clone_node(x);\n  top->parent = p;\n \n  __STL_TRY {\n    if (x->right)\n      top->right = __copy(right(x), top);\n    p = top;\n    x = left(x);\n\n    while (x != 0) {\n      link_type y = clone_node(x);\n      p->left = y;\n      y->parent = p;\n      if (x->right)\n        y->right = __copy(right(x), y);\n      p = y;\n      x = left(x);\n    }\n  }\n  __STL_UNWIND(__erase(top));\n\n  return top;\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\nvoid rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__erase(link_type x) {\n                                // erase without rebalancing\n  while (x != 0) {\n    __erase(right(x));\n    link_type y = left(x);\n    destroy_node(x);\n    x = y;\n  }\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\nvoid rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, \n                                                            iterator last) {\n  if (first == begin() && last == end())\n    clear();\n  else\n    while (first != last) erase(first++);\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\nvoid rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key* first, \n                                                            const Key* last) {\n  while (first != last) erase(*first++);\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) {\n  link_type y = header;        // Last node which is not less than k. \n  link_type x = root();        // Current node. \n\n  while (x != 0) \n    if (!key_compare(key(x), k))\n      y = x, x = left(x);\n    else\n      x = right(x);\n\n  iterator j = iterator(y);   \n  return (j == end() || key_compare(k, key(j.node))) ? end() : j;\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::const_iterator \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) const {\n  link_type y = header; /* Last node which is not less than k. */\n  link_type x = root(); /* Current node. */\n\n  while (x != 0) {\n    if (!key_compare(key(x), k))\n      y = x, x = left(x);\n    else\n      x = right(x);\n  }\n  const_iterator j = const_iterator(y);   \n  return (j == end() || key_compare(k, key(j.node))) ? end() : j;\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::size_type \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key& k) const {\n  pair<const_iterator, const_iterator> p = equal_range(k);\n  size_type n = 0;\n  distance(p.first, p.second, n);\n  return n;\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) {\n  link_type y = header; /* Last node which is not less than k. */\n  link_type x = root(); /* Current node. */\n\n  while (x != 0) \n    if (!key_compare(key(x), k))\n      y = x, x = left(x);\n    else\n      x = right(x);\n\n  return iterator(y);\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::const_iterator \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) const {\n  link_type y = header; /* Last node which is not less than k. */\n  link_type x = root(); /* Current node. */\n\n  while (x != 0) \n    if (!key_compare(key(x), k))\n      y = x, x = left(x);\n    else\n      x = right(x);\n\n  return const_iterator(y);\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) {\n  link_type y = header; /* Last node which is greater than k. */\n  link_type x = root(); /* Current node. */\n\n   while (x != 0) \n     if (key_compare(k, key(x)))\n       y = x, x = left(x);\n     else\n       x = right(x);\n\n   return iterator(y);\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ntypename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::const_iterator \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) const {\n  link_type y = header; /* Last node which is greater than k. */\n  link_type x = root(); /* Current node. */\n\n   while (x != 0) \n     if (key_compare(k, key(x)))\n       y = x, x = left(x);\n     else\n       x = right(x);\n\n   return const_iterator(y);\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\ninline pair<typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator,\n            typename rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::iterator>\nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::equal_range(const Key& k) {\n  return pair<iterator, iterator>(lower_bound(k), upper_bound(k));\n}\n\ntemplate <class Key, class Value, class KoV, class Compare, class Alloc>\ninline pair<typename rb_tree<Key, Value, KoV, Compare, Alloc>::const_iterator,\n            typename rb_tree<Key, Value, KoV, Compare, Alloc>::const_iterator>\nrb_tree<Key, Value, KoV, Compare, Alloc>::equal_range(const Key& k) const {\n  return pair<const_iterator,const_iterator>(lower_bound(k), upper_bound(k));\n}\n\ninline int __black_count(__rb_tree_node_base* node, __rb_tree_node_base* root)\n{\n  if (node == 0)\n    return 0;\n  else {\n    int bc = node->color == __rb_tree_black ? 1 : 0;\n    if (node == root)\n      return bc;\n    else\n      return bc + __black_count(node->parent, root);\n  }\n}\n\ntemplate <class Key, class Value, class KeyOfValue, class Compare, class Alloc>\nbool \nrb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_verify() const\n{\n  if (node_count == 0 || begin() == end())\n    return node_count == 0 && begin() == end() &&\n      header->left == header && header->right == header;\n  \n  int len = __black_count(leftmost(), root());\n  for (const_iterator it = begin(); it != end(); ++it) {\n    link_type x = (link_type) it.node;\n    link_type L = left(x);\n    link_type R = right(x);\n\n    if (x->color == __rb_tree_red)\n      if ((L && L->color == __rb_tree_red) ||\n          (R && R->color == __rb_tree_red))\n        return false;\n\n    if (L && key_compare(key(x), key(L)))\n      return false;\n    if (R && key_compare(key(R), key(x)))\n      return false;\n\n    if (!L && !R && __black_count(x, root()) != len)\n      return false;\n  }\n\n  if (leftmost() != __rb_tree_node_base::minimum(root()))\n    return false;\n  if (rightmost() != __rb_tree_node_base::maximum(root()))\n    return false;\n\n  return true;\n}\n\n__STL_END_NAMESPACE \n\n#endif /* __SGI_STL_INTERNAL_TREE_H */\n\n// Local Variables:\n// mode:C++\n// End:\n\n```\n\n'),(43,'STL源码剖析9-set&multiset',1,'2022-10-22 12:44:21','STL源码剖析','# 1 概述\n\n1. set/multiset都是基于rb tree（与queue和stack一样，可以称为container adapter），故都是有序的。排序的依据是key，set/multiset元素的key和value合一，没有data，value就是key。（value = key + data）\n\n2. set/multiset提供遍历操作及迭代器，按照正常规则（++iter）遍历，便能获得排序状态（sorted）。\n3. 我们无法使用set/multiset的迭代器改变元素值（因为key有其严格的排序规则）。set/multiset的iterator是其底层rb tree的const iterator，禁止程序员修改元素。\n4. set元素（key）不可重复，故插入操作使用的是rb tree的insert_unique()；multiset元素（key）可重复，故插入操作使用的是rb tree的insert_equal()。\n\n# 2 set\n\nset内部rb tree中的模板参数identity为定义在stl_function.h中的仿函数\n\n```c++\ntemplate <class T>\nstruct identity : public unary_function<T, T> {\n  const T& operator()(const T& x) const { return x; }\n};\n```\n\n以下为stl_set.h中set类的定义\n\n```c++\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n// 3个模板参数    \ntemplate <class Key, class Compare = less<Key>, class Alloc = alloc>\n#else\ntemplate <class Key, class Compare, class Alloc = alloc>\n#endif\nclass set {\npublic:\n  // typedefs:\n\n  typedef Key key_type;\n  typedef Key value_type;\n  typedef Compare key_compare;\n  typedef Compare value_compare;\nprivate:\n  //set中的rb tree  \n  typedef rb_tree<key_type, value_type, \n                  identity<value_type>, key_compare, Alloc> rep_type;\n  rep_type t;  // red-black tree representing set\npublic:\n  typedef typename rep_type::const_pointer pointer;\n  typedef typename rep_type::const_pointer const_pointer;\n  typedef typename rep_type::const_reference reference;\n  typedef typename rep_type::const_reference const_reference;\n  // set的迭代器是const_iterator，因此不能改变元素\n  typedef typename rep_type::const_iterator iterator;\n  typedef typename rep_type::const_iterator const_iterator;\n  typedef typename rep_type::const_reverse_iterator reverse_iterator;\n  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;\n  typedef typename rep_type::size_type size_type;\n  typedef typename rep_type::difference_type difference_type;\n\n  // allocation/deallocation\n\n  set() : t(Compare()) {}\n  explicit set(const Compare& comp) : t(comp) {}\n\n  //set一定使用rb tree的insert_unique\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  set(InputIterator first, InputIterator last)\n    : t(Compare()) { t.insert_unique(first, last); }\n\n  template <class InputIterator>\n  set(InputIterator first, InputIterator last, const Compare& comp)\n    : t(comp) { t.insert_unique(first, last); }\n#else\n  set(const value_type* first, const value_type* last) \n    : t(Compare()) { t.insert_unique(first, last); }\n  set(const value_type* first, const value_type* last, const Compare& comp)\n    : t(comp) { t.insert_unique(first, last); }\n\n  set(const_iterator first, const_iterator last)\n    : t(Compare()) { t.insert_unique(first, last); }\n  set(const_iterator first, const_iterator last, const Compare& comp)\n    : t(comp) { t.insert_unique(first, last); }\n#endif /* __STL_MEMBER_TEMPLATES */\n\n  set(const set<Key, Compare, Alloc>& x) : t(x.t) {}\n  set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc>& x) { \n    t = x.t; \n    return *this;\n  }\n\n  // accessors:\n\n  key_compare key_comp() const { return t.key_comp(); }\n  value_compare value_comp() const { return t.key_comp(); }\n  iterator begin() const { return t.begin(); }\n  iterator end() const { return t.end(); }\n  reverse_iterator rbegin() const { return t.rbegin(); } \n  reverse_iterator rend() const { return t.rend(); }\n  bool empty() const { return t.empty(); }\n  size_type size() const { return t.size(); }\n  size_type max_size() const { return t.max_size(); }\n  void swap(set<Key, Compare, Alloc>& x) { t.swap(x.t); }\n\n  // insert/erase\n  typedef  pair<iterator, bool> pair_iterator_bool; \n  pair<iterator,bool> insert(const value_type& x) { \n    pair<typename rep_type::iterator, bool> p = t.insert_unique(x); \n    return pair<iterator, bool>(p.first, p.second);\n  }\n  iterator insert(iterator position, const value_type& x) {\n    typedef typename rep_type::iterator rep_iterator;\n    return t.insert_unique((rep_iterator&)position, x);\n  }\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  void insert(InputIterator first, InputIterator last) {\n    t.insert_unique(first, last);\n  }\n#else\n  void insert(const_iterator first, const_iterator last) {\n    t.insert_unique(first, last);\n  }\n  void insert(const value_type* first, const value_type* last) {\n    t.insert_unique(first, last);\n  }\n#endif /* __STL_MEMBER_TEMPLATES */\n  void erase(iterator position) { \n    typedef typename rep_type::iterator rep_iterator;\n    t.erase((rep_iterator&)position); \n  }\n  size_type erase(const key_type& x) { \n    return t.erase(x); \n  }\n  void erase(iterator first, iterator last) { \n    typedef typename rep_type::iterator rep_iterator;\n    t.erase((rep_iterator&)first, (rep_iterator&)last); \n  }\n  void clear() { t.clear(); }\n\n  // set operations:\n\n  iterator find(const key_type& x) const { return t.find(x); }\n  size_type count(const key_type& x) const { return t.count(x); }\n  iterator lower_bound(const key_type& x) const {\n    return t.lower_bound(x);\n  }\n  iterator upper_bound(const key_type& x) const {\n    return t.upper_bound(x); \n  }\n  pair<iterator,iterator> equal_range(const key_type& x) const {\n    return t.equal_range(x);\n  }\n  friend bool operator== __STL_NULL_TMPL_ARGS (const set&, const set&);\n  friend bool operator< __STL_NULL_TMPL_ARGS (const set&, const set&);\n};\n```\n\n# 3 multiset\n\n以下为stl_multiset.h中multiset的类定义\n\n```c++\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\ntemplate <class Key, class Compare = less<Key>, class Alloc = alloc>\n#else\ntemplate <class Key, class Compare, class Alloc = alloc>\n#endif\nclass multiset {\npublic:\n  // typedefs:\n\n  typedef Key key_type;\n  typedef Key value_type;\n  typedef Compare key_compare;\n  typedef Compare value_compare;\nprivate:\n  typedef rb_tree<key_type, value_type, \n                  identity<value_type>, key_compare, Alloc> rep_type;\n  rep_type t;  // red-black tree representing multiset\npublic:\n  typedef typename rep_type::const_pointer pointer;\n  typedef typename rep_type::const_pointer const_pointer;\n  typedef typename rep_type::const_reference reference;\n  typedef typename rep_type::const_reference const_reference;\n  typedef typename rep_type::const_iterator iterator;\n  typedef typename rep_type::const_iterator const_iterator;\n  typedef typename rep_type::const_reverse_iterator reverse_iterator;\n  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;\n  typedef typename rep_type::size_type size_type;\n  typedef typename rep_type::difference_type difference_type;\n\n  // allocation/deallocation\n\n  multiset() : t(Compare()) {}\n  explicit multiset(const Compare& comp) : t(comp) {}\n\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  multiset(InputIterator first, InputIterator last)\n    : t(Compare()) { t.insert_equal(first, last); }\n  template <class InputIterator>\n  multiset(InputIterator first, InputIterator last, const Compare& comp)\n    : t(comp) { t.insert_equal(first, last); }\n#else\n  multiset(const value_type* first, const value_type* last)\n    : t(Compare()) { t.insert_equal(first, last); }\n  multiset(const value_type* first, const value_type* last,\n           const Compare& comp)\n    : t(comp) { t.insert_equal(first, last); }\n\n  multiset(const_iterator first, const_iterator last)\n    : t(Compare()) { t.insert_equal(first, last); }\n  multiset(const_iterator first, const_iterator last, const Compare& comp)\n    : t(comp) { t.insert_equal(first, last); }\n#endif /* __STL_MEMBER_TEMPLATES */\n\n  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}\n  multiset<Key, Compare, Alloc>&\n  operator=(const multiset<Key, Compare, Alloc>& x) {\n    t = x.t; \n    return *this;\n  }\n\n  // accessors:\n\n  key_compare key_comp() const { return t.key_comp(); }\n  value_compare value_comp() const { return t.key_comp(); }\n  iterator begin() const { return t.begin(); }\n  iterator end() const { return t.end(); }\n  reverse_iterator rbegin() const { return t.rbegin(); } \n  reverse_iterator rend() const { return t.rend(); }\n  bool empty() const { return t.empty(); }\n  size_type size() const { return t.size(); }\n  size_type max_size() const { return t.max_size(); }\n  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }\n\n  // insert/erase\n  iterator insert(const value_type& x) { \n    return t.insert_equal(x);\n  }\n  iterator insert(iterator position, const value_type& x) {\n    typedef typename rep_type::iterator rep_iterator;\n    return t.insert_equal((rep_iterator&)position, x);\n  }\n\n#ifdef __STL_MEMBER_TEMPLATES  \n  template <class InputIterator>\n  void insert(InputIterator first, InputIterator last) {\n    t.insert_equal(first, last);\n  }\n#else\n  void insert(const value_type* first, const value_type* last) {\n    t.insert_equal(first, last);\n  }\n  void insert(const_iterator first, const_iterator last) {\n    t.insert_equal(first, last);\n  }\n#endif /* __STL_MEMBER_TEMPLATES */\n  void erase(iterator position) { \n    typedef typename rep_type::iterator rep_iterator;\n    t.erase((rep_iterator&)position); \n  }\n  size_type erase(const key_type& x) { \n    return t.erase(x); \n  }\n  void erase(iterator first, iterator last) { \n    typedef typename rep_type::iterator rep_iterator;\n    t.erase((rep_iterator&)first, (rep_iterator&)last); \n  }\n  void clear() { t.clear(); }\n\n  // multiset operations:\n  // 注意这里特化了一个find函数，相比于全局的find，该函数有性能优势\n  iterator find(const key_type& x) const { return t.find(x); }\n  size_type count(const key_type& x) const { return t.count(x); }\n  iterator lower_bound(const key_type& x) const {\n    return t.lower_bound(x);\n  }\n  iterator upper_bound(const key_type& x) const {\n    return t.upper_bound(x); \n  }\n  pair<iterator,iterator> equal_range(const key_type& x) const {\n    return t.equal_range(x);\n  }\n  friend bool operator== __STL_NULL_TMPL_ARGS (const multiset&,\n                                               const multiset&);\n  friend bool operator< __STL_NULL_TMPL_ARGS (const multiset&,\n                                              const multiset&);\n};\n```\n\n\n\n\n\n\n\n'),(44,'STL源码剖析10-map&multimap',2,'2022-10-22 12:45:03','STL源码剖析','# 1 概述\n\n1. map/multimap都是基于rb tree（与queue和stack一样，可以称为container adapter），故都是有序的。排序的依据是key。value = key + data。与set/multiset不同的是data不为空。\n\n> 存储键值对的结构都叫map，重载[]运算符来增加和修改。\n\n1. map/multimap提供遍历操作及迭代器，按照正常规则（++iter）遍历，便能获得排序状态（sorted）。\n2. 我们无法使用map/multimap的迭代器改变key（因为key有其严格的排序规则），但却可以改变data。map/multimap的iterator即为rb tree的iterator。通过typedef pair<const Key, T> value_type 来保证禁止修改key。\n3. map元素（key）不可重复，故插入操作使用的是rb tree的insert_unique()；multimap元素（key）可重复，故插入操作使用的是rb tree的insert_equal()。\n\n# 2 map\n\n```c++\n//定义一个map\nmap<int, string> imap;\n//其全部的模板参数为\nmap<int,\n	string,\n	less<int>,\n	alloc\n    > imap;\n//map内部的rb tree的模板参数为\nrb_tree<int,\n		pair<const int, string>,\n		select1st<pair<const int, string>>,\n		less<int>,\n		alloc\n        > t;\n```\n\nmap内部rb tree的模板参数select1st为定义在stl_function.h中的仿函数\n\n```c++\ntemplate <class Pair>\nstruct select1st : public unary_function<Pair, typename Pair::first_type> {\n  const typename Pair::first_type& operator()(const Pair& x) const\n  {\n    return x.first;\n  }\n};\n```\n\n以下为stl_map.h中map类的定义\n\n```c++\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\n//4个模板参数\ntemplate <class Key, class T, class Compare = less<Key>, class Alloc = alloc>\n#else\ntemplate <class Key, class T, class Compare, class Alloc = alloc>\n#endif\nclass map {\npublic:\n\n// typedefs:\n\n  typedef Key key_type;\n  typedef T data_type;\n  typedef T mapped_type;\n  //const key，禁止修改key，可以修改data\n  typedef pair<const Key, T> value_type;\n  typedef Compare key_compare;\n    \n  class value_compare\n    : public binary_function<value_type, value_type, bool> {\n  friend class map<Key, T, Compare, Alloc>;\n  protected :\n    Compare comp;\n    value_compare(Compare c) : comp(c) {}\n  public:\n    bool operator()(const value_type& x, const value_type& y) const {\n      return comp(x.first, y.first);\n    }\n  };\n\nprivate:\n  // map中的rb tree，5个模板参数\n  typedef rb_tree<key_type, value_type, \n                  select1st<value_type>, key_compare, Alloc> rep_type;\n  rep_type t;  // red-black tree representing map\npublic:\n  typedef typename rep_type::pointer pointer;\n  typedef typename rep_type::const_pointer const_pointer;\n  typedef typename rep_type::reference reference;\n  typedef typename rep_type::const_reference const_reference;\n  typedef typename rep_type::iterator iterator;\n  typedef typename rep_type::const_iterator const_iterator;\n  typedef typename rep_type::reverse_iterator reverse_iterator;\n  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;\n  typedef typename rep_type::size_type size_type;\n  typedef typename rep_type::difference_type difference_type;\n\n  // allocation/deallocation\n\n  map() : t(Compare()) {}\n  explicit map(const Compare& comp) : t(comp) {}\n\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  map(InputIterator first, InputIterator last)\n    : t(Compare()) { t.insert_unique(first, last); }\n\n  template <class InputIterator>\n  map(InputIterator first, InputIterator last, const Compare& comp)\n    : t(comp) { t.insert_unique(first, last); }\n#else\n  map(const value_type* first, const value_type* last)\n    : t(Compare()) { t.insert_unique(first, last); }\n  map(const value_type* first, const value_type* last, const Compare& comp)\n    : t(comp) { t.insert_unique(first, last); }\n\n  map(const_iterator first, const_iterator last)\n    : t(Compare()) { t.insert_unique(first, last); }\n  map(const_iterator first, const_iterator last, const Compare& comp)\n    : t(comp) { t.insert_unique(first, last); }\n#endif /* __STL_MEMBER_TEMPLATES */\n\n  map(const map<Key, T, Compare, Alloc>& x) : t(x.t) {}\n  map<Key, T, Compare, Alloc>& operator=(const map<Key, T, Compare, Alloc>& x)\n  {\n    t = x.t;\n    return *this; \n  }\n\n  // accessors:\n\n  key_compare key_comp() const { return t.key_comp(); }\n  value_compare value_comp() const { return value_compare(t.key_comp()); }\n  iterator begin() { return t.begin(); }\n  const_iterator begin() const { return t.begin(); }\n  iterator end() { return t.end(); }\n  const_iterator end() const { return t.end(); }\n  reverse_iterator rbegin() { return t.rbegin(); }\n  const_reverse_iterator rbegin() const { return t.rbegin(); }\n  reverse_iterator rend() { return t.rend(); }\n  const_reverse_iterator rend() const { return t.rend(); }\n  bool empty() const { return t.empty(); }\n  size_type size() const { return t.size(); }\n  size_type max_size() const { return t.max_size(); }\n  // map可以用[]来插入元素！！！，但multimap不行  \n  // 如果k存在，返回second的值；如果k不存在...?见GNU4.9版本\n  /*\n  #if __cplusplus >= 201103L\n      mapped_type&\n      operator[](key_type&& __k)\n      {\n	// concept requirements\n	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)\n\n	iterator __i = lower_bound(__k);\n	// __i->first is greater than or equivalent to __k.\n	if (__i == end() || key_comp()(__k, (*__i).first))\n	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,\n					std::forward_as_tuple(std::move(__k)),\n					std::tuple<>());\n	return (*__i).second;\n      }\n#endif\n  */\n  T& operator[](const key_type& k) {\n    return (*((insert(value_type(k, T()))).first)).second;\n  }\n  void swap(map<Key, T, Compare, Alloc>& x) { t.swap(x.t); }\n\n  // insert/erase\n\n  // insert的参数是pair<const Key, T>\n  pair<iterator,bool> insert(const value_type& x) { return t.insert_unique(x); }\n  iterator insert(iterator position, const value_type& x) {\n    return t.insert_unique(position, x);\n  }\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  void insert(InputIterator first, InputIterator last) {\n    t.insert_unique(first, last);\n  }\n#else\n  void insert(const value_type* first, const value_type* last) {\n    t.insert_unique(first, last);\n  }\n  void insert(const_iterator first, const_iterator last) {\n    t.insert_unique(first, last);\n  }\n#endif /* __STL_MEMBER_TEMPLATES */\n\n  void erase(iterator position) { t.erase(position); }\n  size_type erase(const key_type& x) { return t.erase(x); }\n  void erase(iterator first, iterator last) { t.erase(first, last); }\n  void clear() { t.clear(); }\n\n  // map operations:\n\n  iterator find(const key_type& x) { return t.find(x); }\n  const_iterator find(const key_type& x) const { return t.find(x); }\n  size_type count(const key_type& x) const { return t.count(x); }\n  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }\n  const_iterator lower_bound(const key_type& x) const {\n    return t.lower_bound(x); \n  }\n  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }\n  const_iterator upper_bound(const key_type& x) const {\n    return t.upper_bound(x); \n  }\n  \n  pair<iterator,iterator> equal_range(const key_type& x) {\n    return t.equal_range(x);\n  }\n  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {\n    return t.equal_range(x);\n  }\n  friend bool operator== __STL_NULL_TMPL_ARGS (const map&, const map&);\n  friend bool operator< __STL_NULL_TMPL_ARGS (const map&, const map&);\n};\n```\n\n'),(45,'STL源码剖析11-hashtable',3,'2022-10-22 12:45:45','STL源码剖析','# 1 hashtable 与 rb tree\n\n1. hashtable结构较红黑树简单，二者都是不公开的数据结构，都是关联式容器的底层结构，为set和map服务。\n2. rb tree的时间复杂度（插入、删除、搜索）为$O(logn)$，hashtabel为$O(1)$，但rb tree是有序的，hashtable无序。\n\n# 2 hashtable的节点\n\n```c++\ntemplate <class Value>\nstruct __hashtable_node\n{\n  __hashtable_node* next;\n  Value val;\n};  \n```\n\n# 3 hashtable的迭代器\n\n![img](https://cdn.moyusoldier.cn/20200212172435697.png)\n\n散列表的碰撞策略：开链，即“数组+链表”。(GNUC是单向链表，VC是双向链表)\n\n当遍历到一个bucket的链表尾时，有能力去到下一个bucket，因此需要有一个hashtable* ht。（ 与deque有异曲同工之妙）\n\n```c++\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey, class Alloc>\nstruct __hashtable_iterator {\n  typedef hashtable<Value, Key, HashFcn, ExtractKey, EqualKey, Alloc>\n          hashtable;\n  typedef __hashtable_iterator<Value, Key, HashFcn, \n                               ExtractKey, EqualKey, Alloc>\n          iterator;\n  typedef __hashtable_const_iterator<Value, Key, HashFcn, \n                                     ExtractKey, EqualKey, Alloc>\n          const_iterator;\n  typedef __hashtable_node<Value> node;\n\n  typedef forward_iterator_tag iterator_category;\n  typedef Value value_type;\n  typedef ptrdiff_t difference_type;\n  typedef size_t size_type;\n  typedef Value& reference;\n  typedef Value* pointer;\n\n  node* cur; //迭代器目前所指向的节点\n  hashtable* ht; //保持对容器的连结关系(因为可能从一个bucket跳到另一个bucket)\n\n  // 注意这种构造函数  \n  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}\n  __hashtable_iterator() {}\n  reference operator*() const { return cur->val; }\n#ifndef __SGI_STL_NO_ARROW_OPERATOR\n  pointer operator->() const { return &(operator*()); }\n#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n  iterator& operator++();\n  iterator operator++(int);\n  bool operator==(const iterator& it) const { return cur == it.cur; }\n  bool operator!=(const iterator& it) const { return cur != it.cur; }\n};\n```\n\n这其中最值得注意的operator++操作。\n\n当前进一个（节点）位置时，由于节点被安置于list内，所以利用节点的next指针即可轻易达成前进操作。如果目前节点正巧是list的尾端，就跳至下一个bucket身上，即下一个list的头部节点。\n\n```c++\n// prefix increment\ntemplate <class V, class K, class HF, class ExK, class EqK, class A>\n__hashtable_iterator<V, K, HF, ExK, EqK, A>&\n__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++()\n{\n  const node* old = cur;\n  cur = cur->next;\n  //如果cur为空，说明走到链表尾，要找下一个node\n  if (!cur) {\n    // 回到该bucket\n    size_type bucket = ht->bkt_num(old->val);\n    // 依次遍历bucket，直到cur不为空\n    while (!cur && ++bucket < ht->buckets.size())\n      cur = ht->buckets[bucket];\n  }\n  return *this;\n}\n\n// postfix increment\ntemplate <class V, class K, class HF, class ExK, class EqK, class A>\ninline __hashtable_iterator<V, K, HF, ExK, EqK, A>\n__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++(int)\n{\n  iterator tmp = *this;\n  ++*this;\n  return tmp;\n}\n```\n\n注意hashtable的迭代器没有后退操作（operator--），也没有逆向迭代器（reverse iterator）。\n\n# 4 hashtable的数据结构\n\n空hashtable大小为3+12+4 = 19->20(内存对齐)\n\n```c++\n/* \n6个模板参数\nValue-键值对的键和值key+data=value\nKey-键值对的键key\nHashFcn-键值对（元素）通过HashFunction得到hashcode\nExtractKey-如何取出key，相当于rb tree里的keyOfValue\nEqualKey-什么叫做key相等\nAlloc-空间配置器\n*/\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc>\nclass hashtable {\npublic:\n  typedef HashFcn hasher;\n  typedef EqualKey key_equal;\n  //...\nprivate:\n  //以下三个仿函数实例化后的大小各为1bytes\n  hasher hash;\n  key_equal equals;\n  ExtractKey get_key;\n  //\n  typedef __hashtable_node<Value> node;\n  //数组，vector里面有三个指针，本身大小为12bytes\n  vector<node*,Alloc> buckets;\n  //hashtable中元素个数, 大小为4bytes  \n  size_type num_elements;  \n  //...  \npublic:\n  //buckets的个数  \n  size_type bucket_count() const { return buckets.size(); }    \n  //...  \n};\n```\n\n# 5 构造与内存管理\n\n```c++\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc>\nclass hashtable {\n    //...\nprivate:\n    // hashtable专属的节点配置器\n  typedef simple_alloc<node, Alloc> node_allocator;\n    \nprivate:\n  //举例：传入50，返回53。以下  首先保留53个空间，然后将其全部填0\n  void initialize_buckets(size_type n)\n  {\n    const size_type n_buckets = next_size(n);\n    buckets.reserve(n_buckets); //vector的reserve函数\n    buckets.insert(buckets.end(), n_buckets, (node*) 0);\n    num_elements = 0;\n  }  \n    \n  // 节点配置  \n  node* new_node(const value_type& obj)\n  {\n    node* n = node_allocator::allocate();\n    n->next = 0;\n    __STL_TRY {\n      construct(&n->val, obj);\n      return n;\n    }\n    __STL_UNWIND(node_allocator::deallocate(n));\n  }\n  // 节点释放\n  void delete_node(node* n)\n  {\n    destroy(&n->val);\n    node_allocator::deallocate(n);\n  }\npublic:\n  // 构造函数，指定hashtable的大小  \n  hashtable(size_type n,\n            const HashFcn&    hf,\n            const EqualKey&   eql,\n            const ExtractKey& ext)\n    : hash(hf), equals(eql), get_key(ext), num_elements(0)\n  {\n    initialize_buckets(n);\n  }\n    \n};\n```\n\n# 6 插入(insert)与表格重整(resize)\n\n插入操作分两种：insert_unique 和 insert_equal，二者都是先进行resize，再执行插入操作。\n\n这里的resize即**rehashing**，包括两个步骤：\n\n1. resize the hashtable\n2. rehashing every elements\n\nresize只能扩容，不能缩容？是的，因为只有插入（insert）操作会调用resize，删除（erase）不会。\n\n扩容条件：如果hashtable内元素总个数（包括新增的一个）> buckets数组大小，扩容（其实没什么道理）\n\n```c++\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc>\nclass hashtable {\npublic:    \n  // 插入元素，不允许重复	\n  // 注意返回值一个包含iterator的pair类型，bool表示是否插入成功\n  pair<iterator, bool> insert_unique(const value_type& obj)\n  {\n    resize(num_elements + 1);\n    return insert_unique_noresize(obj);\n  }\n  // 插入元素，允许重复	\n  iterator insert_equal(const value_type& obj)\n  {\n    resize(num_elements + 1);\n    return insert_equal_noresize(obj);\n  }  \n   \n};\n\n// 判断是否需要重建表格。如果不需要，立即返回。\ntemplate <class V, class K, class HF, class Ex, class Eq, class A>\nvoid hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)\n{\n  const size_type old_n = buckets.size();\n  // 如果hashtable内元素总个数（包括新增的一个）> buckets数组大小，扩容\n  // 由此可知，每个链表的最长长度与buckets数组长度相同  \n  if (num_elements_hint > old_n) {\n    // 找到下一个质数  \n    const size_type n = next_size(num_elements_hint);  \n    if (n > old_n) {\n      //1. 创建新的buckets数组  \n      vector<node*, A> tmp(n, (node*) 0);\n      __STL_TRY {\n        // 2. 处理旧buckets数组  \n        // 对于每个链表  \n        for (size_type bucket = 0; bucket < old_n; ++bucket) {\n          // 头节点  \n          node* first = buckets[bucket]; \n          while (first) {\n            // 找出节点应该落在哪个新bucket内  \n            size_type new_bucket = bkt_num(first->val, n);\n            // 指向头节点的下一个节点 头删\n            buckets[bucket] = first->next;\n            // 头插\n            first->next = tmp[new_bucket];\n            tmp[new_bucket] = first;\n            first = buckets[bucket];          \n          }\n        }\n        // 3. 新旧两个buckets数组对调。\n        // 注意，对调两方如果大小不同，大的会变小，小的会变大\n        // 离开时释放local tmp的内存！！！\n        // 堆还是栈？？主要是堆指针  \n        buckets.swap(tmp);\n      }\n#         ifdef __STL_USE_EXCEPTIONS\n      catch(...) {\n        for (size_type bucket = 0; bucket < tmp.size(); ++bucket) {\n          while (tmp[bucket]) {\n            node* next = tmp[bucket]->next;\n            delete_node(tmp[bucket]);\n            tmp[bucket] = next;\n          }\n        }\n        throw;\n      }\n#         endif /* __STL_USE_EXCEPTIONS */\n    }\n  }\n}\n\n// 真正执行unique插入操作的函数\ntemplate <class V, class K, class HF, class Ex, class Eq, class A>\npair<typename hashtable<V, K, HF, Ex, Eq, A>::iterator, bool> \nhashtable<V, K, HF, Ex, Eq, A>::insert_unique_noresize(const value_type& obj)\n{\n  const size_type n = bkt_num(obj);\n  node* first = buckets[n];\n  \n  for (node* cur = first; cur; cur = cur->next) \n    // 发现相同值，不插入，立即返回 \n    if (equals(get_key(cur->val), get_key(obj)))\n      return pair<iterator, bool>(iterator(cur, this), false);\n  // 链表头插入\n  node* tmp = new_node(obj);\n  tmp->next = first;\n  buckets[n] = tmp;\n  ++num_elements;\n  return pair<iterator, bool>(iterator(tmp, this), true);\n} \n\n// 真正执行equal插入操作的函数\ntemplate <class V, class K, class HF, class Ex, class Eq, class A>\ntypename hashtable<V, K, HF, Ex, Eq, A>::iterator \nhashtable<V, K, HF, Ex, Eq, A>::insert_equal_noresize(const value_type& obj)\n{\n  const size_type n = bkt_num(obj);\n  node* first = buckets[n];\n  	\n  for (node* cur = first; cur; cur = cur->next) \n    // 发现相同值，插在相同值后，然后返回  \n    if (equals(get_key(cur->val), get_key(obj))) {\n      node* tmp = new_node(obj);\n      tmp->next = cur->next;\n      cur->next = tmp;\n      ++num_elements;\n      return iterator(tmp, this);\n    }\n\n  node* tmp = new_node(obj);\n  tmp->next = first;\n  buckets[n] = tmp;\n  ++num_elements;\n  return iterator(tmp, this);\n}\n\n```\n\n下图为resize操作的示意图。\n\n![img](https://cdn.moyusoldier.cn/20200212174526813.png)\n\n其中，左侧为旧buckets数组，右侧为新tmp数组。\n\n# 7 resize的数组大小\n\n散列表的“散”：打散rehashing，把bucket打散。为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多时， 程序需要对哈希表的大小进行相应的扩展。\n\nSGI STL将buckets vector的大小设置为质数，并且先将28个质数（逐渐呈现大约**两倍**的关系）计算好，使用时找出最接近并大于等于n的那个质数。\n\n如下图，当元素个数从6个增加到54个时，需要rehash，将buckets vector 的大小变为53。\n\n![img](https://cdn.moyusoldier.cn/image-20220909132730280.png)\n\n```c++\n// Note: assumes long is at least 32 bits. 假设 long 至少有32bits\nstatic const int __stl_num_primes = 28;\nstatic const unsigned long __stl_prime_list[__stl_num_primes] =\n{\n  53,         97,           193,         389,       769,\n  1543,       3079,         6151,        12289,     24593,\n  49157,      98317,        196613,      393241,    786433,\n  1572869,    3145739,      6291469,     12582917,  25165843,\n  50331653,   100663319,    201326611,   402653189, 805306457, \n  1610612741, 3221225473ul, 4294967291ul\n};\n\n//找出28个质数当中，最接近并大于或等于n的那个质数\ninline unsigned long __stl_next_prime(unsigned long n)\n{\n  const unsigned long* first = __stl_prime_list;\n  const unsigned long* last = __stl_prime_list + __stl_num_primes;\n  const unsigned long* pos = lower_bound(first, last, n);\n  return pos == last ? *(last - 1) : *pos;\n}\n\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc>\nclass hashtable {\n  //...\npublic:\n  //总共可以有多少buckets\n  size_type max_bucket_count() const\n    { return __stl_prime_list[__stl_num_primes - 1]; } \nprivate:\n  // 为resize提供调用的方法  \n  size_type next_size(size_type n) const { return __stl_next_prime(n); }    \n};\n```\n\n# 8 计算元素应处于哪个bucket\n\n如插入操作的代码所示，判断元素应处于哪个bucket通过bkt_num函数完成，分两步：\n\n1. 元素通过哈希函数（hash function）计算hashcode\n2. 对hashcode进行取模运算计算元素落在哪个bucket\n\n```c++\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc>\nclass hashtable {\n  //...\nprivate:\n  // 版本1: 接受Value和buckets个数  \n  size_type bkt_num(const value_type& obj, size_t n) const\n  {\n    return bkt_num_key(get_key(obj), n);\n  }\n  \n  // 版本2: 接受Value \n  size_type bkt_num(const value_type& obj) const\n  {\n    return bkt_num_key(get_key(obj));\n  }\n    \n  size_type bkt_num_key(const key_type& key) const\n  {\n    return bkt_num_key(key, buckets.size());\n  }\n    \n  //具体实现	\n  size_type bkt_num_key(const key_type& key, size_t n) const\n  {\n    return hash(key) % n;\n  }\n};\n```\n\n# 9 哈希函数\n\n哈希函数均为定义在stl_hash_fun.h中的仿函数\n\n```c++\ninline size_t __stl_hash_string(const char* s)\n{\n  unsigned long h = 0; \n  for ( ; *s; ++s)\n    h = 5*h + *s;\n  \n  return size_t(h);\n}\n\n//泛化版本的模板类\ntemplate <class Key> struct hash { };\n\n//偏特化版本的模板类\n//__STL_TEMPLATE_NULL即为template<>\n__STL_TEMPLATE_NULL struct hash<char*>\n{\n  size_t operator()(const char* s) const { return __stl_hash_string(s); }\n};\n\n__STL_TEMPLATE_NULL struct hash<const char*>\n{\n  size_t operator()(const char* s) const { return __stl_hash_string(s); }\n};\n\n__STL_TEMPLATE_NULL struct hash<char> {\n  size_t operator()(char x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash<unsigned char> {\n  size_t operator()(unsigned char x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash<signed char> {\n  size_t operator()(unsigned char x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash<short> {\n  size_t operator()(short x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash<unsigned short> {\n  size_t operator()(unsigned short x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash<int> {\n  size_t operator()(int x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash<unsigned int> {\n  size_t operator()(unsigned int x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash<long> {\n  size_t operator()(long x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash<unsigned long> {\n  size_t operator()(unsigned long x) const { return x; }\n};\n\n```\n\n# 10 删除(erase)\n\nerase函数有很多重载\n\n```c++\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc>\nclass hashtable {\n  //...\npublic:\n  size_type erase(const key_type& key);\n  void erase(const iterator& it);\n  void erase(iterator first, iterator last);\n\n  void erase(const const_iterator& it);\n  void erase(const_iterator first, const_iterator last);\n};\n```\n\n其中最基础的两个重载如下\n\n```c++\n//按key删除，可以删除多个节点\ntemplate <class V, class K, class HF, class Ex, class Eq, class A>\ntypename hashtable<V, K, HF, Ex, Eq, A>::size_type \nhashtable<V, K, HF, Ex, Eq, A>::erase(const key_type& key)\n{\n  const size_type n = bkt_num_key(key);\n  node* first = buckets[n];\n  // 删除了几个节点（因为可能有重复节点）  \n  size_type erased = 0;\n\n  if (first) {\n    node* cur = first;\n    node* next = cur->next;\n    // 从第二个节点开始判断？为什么不从第一个开始判断？相当于没有哑结点，无法统一代码！第二个以后不需要修改buckets[n]，第一个需要\n    while (next) {\n      if (equals(get_key(next->val), key)) {\n        cur->next = next->next;\n        delete_node(next);\n        next = cur->next;\n        ++erased;\n        --num_elements;\n      }\n      else {\n        cur = next;\n        next = cur->next;\n      }\n    }\n    // 判断第一个节点  \n    if (equals(get_key(first->val), key)) {\n      buckets[n] = first->next;\n      delete_node(first);\n      ++erased;\n      --num_elements;\n    }\n  }\n  return erased;\n}\n\n//按iterator删除，只能删除一个节点\ntemplate <class V, class K, class HF, class Ex, class Eq, class A>\nvoid hashtable<V, K, HF, Ex, Eq, A>::ierase(const iterator& it)\n{\n  if (node* const p = it.cur) {\n    const size_type n = bkt_num(p->val);\n    node* cur = buckets[n];\n    // 如果是第一个节点  \n    if (cur == p) {\n      buckets[n] = cur->next;\n      delete_node(cur);\n      --num_elements;\n    }\n   // 不是第一个节点\n    else {\n      node* next = cur->next;\n      while (next) {\n        if (next == p) {\n          cur->next = next->next;\n          delete_node(next);\n          --num_elements;\n          break;\n        }\n        else {\n          cur = next;\n          next = cur->next;\n        }\n      }\n    }\n  }\n}\n```\n\n# 11 复制（copy_from）和整体删除（claer）\n\n注意内存释放问题\n\n```c++\ntemplate <class V, class K, class HF, class Ex, class Eq, class A>\nvoid hashtable<V, K, HF, Ex, Eq, A>::clear()\n{\n  for (size_type i = 0; i < buckets.size(); ++i) {\n    node* cur = buckets[i];\n    while (cur != 0) {\n      node* next = cur->next;\n      delete_node(cur);\n      cur = next;\n    }\n    // 0即为NULL  \n    buckets[i] = 0;\n  }\n  num_elements = 0;\n}\n```\n\n```c++\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc>\nclass hashtable { \n  //拷贝构造函数调用copy_from  \n  hashtable(const hashtable& ht)\n    : hash(ht.hash), equals(ht.equals), get_key(ht.get_key), num_elements(0)\n  {\n    copy_from(ht);\n  }\n};\n\ntemplate <class V, class K, class HF, class Ex, class Eq, class A>\nvoid hashtable<V, K, HF, Ex, Eq, A>::copy_from(const hashtable& ht)\n{\n  //先清空  \n  buckets.clear();\n  buckets.reserve(ht.buckets.size());\n  buckets.insert(buckets.end(), ht.buckets.size(), (node*) 0);\n  __STL_TRY {\n    for (size_type i = 0; i < ht.buckets.size(); ++i) {\n      if (const node* cur = ht.buckets[i]) {\n        node* copy = new_node(cur->val);\n        buckets[i] = copy;\n\n        for (node* next = cur->next; next; cur = next, next = cur->next) {\n          copy->next = new_node(next->val);\n          copy = copy->next;\n        }\n      }\n    }\n    num_elements = ht.num_elements;\n  }\n  __STL_UNWIND(clear());\n}\n```\n\n\n\n\n\n# 12 Example\n\n```c++\nint main() {\n    //仿函数\n    struct eqstr {\n        bool operator()(const char *s1, const char *s2) const {\n            return strcmp(s1, s2) == 0;\n        }\n    };\n\n    hashtable<const char *,\n            const char *,\n            hash<const char *>,\n            identity<const char *>,\n            eqstr>;\n            ht(50, hash<const char *>(), eqstr());\n    \n    ht.insert_unique(\"kiwi\");\n    ht.insert_unique(\"plum\");\n    ht.insert_unique(\"apple\");\n}\n```\n\n其中，identity为定义在stl_function.h中的仿函数\n\n```c++\ntemplate <class T>\nstruct identity : public unary_function<T, T> {\n  const T& operator()(const T& x) const { return x; }\n};\n```\n\n\n\n\n\n\n\n\n\n'),(46,'STL源码剖析12-unordered容器',4,'2022-10-22 12:46:36','STL源码剖析','# 1 概述\n\nC++11中，hash\\_容器 修改为 unordered\\_容器\n\n![image-20221015123835484](https://cdn.moyusoldier.cn/image-20221015123835484.png)\n\n# 2 hash_set\n\n- 以hashtable为底层机制。由于hash_set所提供的方法，hashtable都提供了，所以几乎所有的hash_set方法，都只是转调用hastable的方法而已。\n- set的目的是快速查找。以rb tree作底层的set有自动排序功能，而以hashtable作底层的hash_set没有。\n- set与map的区别在于，set中key和value合一，没有data，value就是key。（value = key + data）\n- hash_set的使用方法和set**完全相同**。\n\n源码（stl_hash_set.h）\n\n```c++\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\ntemplate <class Value, class HashFcn = hash<Value>,\n          class EqualKey = equal_to<Value>,\n          class Alloc = alloc>\n#else\ntemplate <class Value, class HashFcn, class EqualKey, class Alloc = alloc>\n#endif\nclass hash_set\n{\nprivate:\n  typedef hashtable<Value, Value, HashFcn, identity<Value>, \n                    EqualKey, Alloc> ht;\n  ht rep;\n\npublic:\n  typedef typename ht::key_type key_type;\n  typedef typename ht::value_type value_type;\n  typedef typename ht::hasher hasher;\n  typedef typename ht::key_equal key_equal;\n\n  typedef typename ht::size_type size_type;\n  typedef typename ht::difference_type difference_type;\n  typedef typename ht::const_pointer pointer;\n  typedef typename ht::const_pointer const_pointer;\n  typedef typename ht::const_reference reference;\n  typedef typename ht::const_reference const_reference;\n\n  typedef typename ht::const_iterator iterator;\n  typedef typename ht::const_iterator const_iterator;\n\n  hasher hash_funct() const { return rep.hash_funct(); }\n  key_equal key_eq() const { return rep.key_eq(); }\n\npublic:\n  // 缺省使用大小为100的表格，将被hashtable调整为最近且大于100的质数  \n  hash_set() : rep(100, hasher(), key_equal()) {}\n  // 防止（在拷贝构造中发生）隐式类型转换  \n  explicit hash_set(size_type n) : rep(n, hasher(), key_equal()) {}\n  hash_set(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n  hash_set(size_type n, const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) {}\n\n#ifdef __STL_MEMBER_TEMPLATES\n  // 插入操作全部使用insert_unique()，不允许重复  \n  template <class InputIterator>\n  hash_set(InputIterator f, InputIterator l)\n    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  template <class InputIterator>\n  hash_set(InputIterator f, InputIterator l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  template <class InputIterator>\n  hash_set(InputIterator f, InputIterator l, size_type n,\n           const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n  template <class InputIterator>\n  hash_set(InputIterator f, InputIterator l, size_type n,\n           const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n#else\n\n  hash_set(const value_type* f, const value_type* l)\n    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  hash_set(const value_type* f, const value_type* l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  hash_set(const value_type* f, const value_type* l, size_type n,\n           const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n  hash_set(const value_type* f, const value_type* l, size_type n,\n           const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n\n  hash_set(const_iterator f, const_iterator l)\n    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  hash_set(const_iterator f, const_iterator l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  hash_set(const_iterator f, const_iterator l, size_type n,\n           const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n  hash_set(const_iterator f, const_iterator l, size_type n,\n           const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n#endif /*__STL_MEMBER_TEMPLATES */\n\npublic:\n  // 所有操作几乎都有hashtable对应版本。转调用就行。  \n  size_type size() const { return rep.size(); }\n  size_type max_size() const { return rep.max_size(); }\n  bool empty() const { return rep.empty(); }\n  void swap(hash_set& hs) { rep.swap(hs.rep); }\n  friend bool operator== __STL_NULL_TMPL_ARGS (const hash_set&,\n                                               const hash_set&);\n\n  iterator begin() const { return rep.begin(); }\n  iterator end() const { return rep.end(); }\n\npublic:\n  pair<iterator, bool> insert(const value_type& obj)\n    {\n      pair<typename ht::iterator, bool> p = rep.insert_unique(obj);\n      return pair<iterator, bool>(p.first, p.second);\n    }\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }\n#else\n  void insert(const value_type* f, const value_type* l) {\n    rep.insert_unique(f,l);\n  }\n  void insert(const_iterator f, const_iterator l) {rep.insert_unique(f, l); }\n#endif /*__STL_MEMBER_TEMPLATES */\n  pair<iterator, bool> insert_noresize(const value_type& obj)\n  {\n    pair<typename ht::iterator, bool> p = rep.insert_unique_noresize(obj);\n    return pair<iterator, bool>(p.first, p.second);\n  }\n\n  iterator find(const key_type& key) const { return rep.find(key); }\n\n  size_type count(const key_type& key) const { return rep.count(key); }\n  \n  pair<iterator, iterator> equal_range(const key_type& key) const\n    { return rep.equal_range(key); }\n\n  size_type erase(const key_type& key) {return rep.erase(key); }\n  void erase(iterator it) { rep.erase(it); }\n  void erase(iterator f, iterator l) { rep.erase(f, l); }\n  void clear() { rep.clear(); }\n\npublic:\n  void resize(size_type hint) { rep.resize(hint); }\n  size_type bucket_count() const { return rep.bucket_count(); }\n  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n  size_type elems_in_bucket(size_type n) const\n    { return rep.elems_in_bucket(n); }\n};\n\ntemplate <class Value, class HashFcn, class EqualKey, class Alloc>\ninline bool operator==(const hash_set<Value, HashFcn, EqualKey, Alloc>& hs1,\n                       const hash_set<Value, HashFcn, EqualKey, Alloc>& hs2)\n{\n  return hs1.rep == hs2.rep;\n}\n```\n\n# 3 hash_multiset\n\n- 使用方法与multiset完全相同，唯一差别在于它的底层机制是hashtable，因此，hash_multiset的元素不会被自动排序。\n- hash_multiset与hash_set在实现上的唯一差别是，前者的元素插入操作采用的底层机制是hashtable的insert_equal()，后者是insert_unique()。\n\n源码（stl_hash_set.h）\n\n```c++\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\ntemplate <class Value, class HashFcn = hash<Value>,\n          class EqualKey = equal_to<Value>,\n          class Alloc = alloc>\n#else\ntemplate <class Value, class HashFcn, class EqualKey, class Alloc = alloc>\n#endif\nclass hash_multiset\n{\nprivate:\n  typedef hashtable<Value, Value, HashFcn, identity<Value>, \n                    EqualKey, Alloc> ht;\n  ht rep;\n\npublic:\n  typedef typename ht::key_type key_type;\n  typedef typename ht::value_type value_type;\n  typedef typename ht::hasher hasher;\n  typedef typename ht::key_equal key_equal;\n\n  typedef typename ht::size_type size_type;\n  typedef typename ht::difference_type difference_type;\n  typedef typename ht::const_pointer pointer;\n  typedef typename ht::const_pointer const_pointer;\n  typedef typename ht::const_reference reference;\n  typedef typename ht::const_reference const_reference;\n\n  typedef typename ht::const_iterator iterator;\n  typedef typename ht::const_iterator const_iterator;\n\n  hasher hash_funct() const { return rep.hash_funct(); }\n  key_equal key_eq() const { return rep.key_eq(); }\n\npublic:\n  hash_multiset() : rep(100, hasher(), key_equal()) {}\n  explicit hash_multiset(size_type n) : rep(n, hasher(), key_equal()) {}\n  hash_multiset(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n  hash_multiset(size_type n, const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) {}\n\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  hash_multiset(InputIterator f, InputIterator l)\n    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  template <class InputIterator>\n  hash_multiset(InputIterator f, InputIterator l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  template <class InputIterator>\n  hash_multiset(InputIterator f, InputIterator l, size_type n,\n                const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n  template <class InputIterator>\n  hash_multiset(InputIterator f, InputIterator l, size_type n,\n                const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n#else\n\n  hash_multiset(const value_type* f, const value_type* l)\n    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  hash_multiset(const value_type* f, const value_type* l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  hash_multiset(const value_type* f, const value_type* l, size_type n,\n                const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n  hash_multiset(const value_type* f, const value_type* l, size_type n,\n                const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n\n  hash_multiset(const_iterator f, const_iterator l)\n    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  hash_multiset(const_iterator f, const_iterator l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  hash_multiset(const_iterator f, const_iterator l, size_type n,\n                const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n  hash_multiset(const_iterator f, const_iterator l, size_type n,\n                const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n#endif /*__STL_MEMBER_TEMPLATES */\n\npublic:\n  size_type size() const { return rep.size(); }\n  size_type max_size() const { return rep.max_size(); }\n  bool empty() const { return rep.empty(); }\n  void swap(hash_multiset& hs) { rep.swap(hs.rep); }\n  friend bool operator== __STL_NULL_TMPL_ARGS (const hash_multiset&,\n                                               const hash_multiset&);\n\n  iterator begin() const { return rep.begin(); }\n  iterator end() const { return rep.end(); }\n\npublic:\n  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }\n#else\n  void insert(const value_type* f, const value_type* l) {\n    rep.insert_equal(f,l);\n  }\n  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }\n#endif /*__STL_MEMBER_TEMPLATES */\n  iterator insert_noresize(const value_type& obj)\n    { return rep.insert_equal_noresize(obj); }    \n\n  iterator find(const key_type& key) const { return rep.find(key); }\n\n  size_type count(const key_type& key) const { return rep.count(key); }\n  \n  pair<iterator, iterator> equal_range(const key_type& key) const\n    { return rep.equal_range(key); }\n\n  size_type erase(const key_type& key) {return rep.erase(key); }\n  void erase(iterator it) { rep.erase(it); }\n  void erase(iterator f, iterator l) { rep.erase(f, l); }\n  void clear() { rep.clear(); }\n\npublic:\n  void resize(size_type hint) { rep.resize(hint); }\n  size_type bucket_count() const { return rep.bucket_count(); }\n  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n  size_type elems_in_bucket(size_type n) const\n    { return rep.elems_in_bucket(n); }\n};\n\ntemplate <class Val, class HashFcn, class EqualKey, class Alloc>\ninline bool operator==(const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,\n                       const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs2)\n{\n  return hs1.rep == hs2.rep;\n}\n\n```\n\n# 4 hash_map\n\nvalue = key + data\n\nmap的目的: 根据key 快速找到value \n\n源码（stl_hash_map.h）\n\n```c++\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\ntemplate <class Key, class T, class HashFcn = hash<Key>,\n          class EqualKey = equal_to<Key>,\n          class Alloc = alloc>\n#else\ntemplate <class Key, class T, class HashFcn, class EqualKey, \n          class Alloc = alloc>\n#endif\nclass hash_map\n{\nprivate:\n  typedef hashtable<pair<const Key, T>, Key, HashFcn,\n                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;\n  ht rep;\n\npublic:\n  typedef typename ht::key_type key_type;\n  typedef T data_type;\n  typedef T mapped_type;\n  typedef typename ht::value_type value_type;\n  typedef typename ht::hasher hasher;\n  typedef typename ht::key_equal key_equal;\n\n  typedef typename ht::size_type size_type;\n  typedef typename ht::difference_type difference_type;\n  typedef typename ht::pointer pointer;\n  typedef typename ht::const_pointer const_pointer;\n  typedef typename ht::reference reference;\n  typedef typename ht::const_reference const_reference;\n\n  typedef typename ht::iterator iterator;\n  typedef typename ht::const_iterator const_iterator;\n\n  hasher hash_funct() const { return rep.hash_funct(); }\n  key_equal key_eq() const { return rep.key_eq(); }\n\npublic:\n  hash_map() : rep(100, hasher(), key_equal()) {}\n  explicit hash_map(size_type n) : rep(n, hasher(), key_equal()) {}\n  hash_map(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n  hash_map(size_type n, const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) {}\n\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  hash_map(InputIterator f, InputIterator l)\n    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  template <class InputIterator>\n  hash_map(InputIterator f, InputIterator l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  template <class InputIterator>\n  hash_map(InputIterator f, InputIterator l, size_type n,\n           const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n  template <class InputIterator>\n  hash_map(InputIterator f, InputIterator l, size_type n,\n           const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n\n#else\n  hash_map(const value_type* f, const value_type* l)\n    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  hash_map(const value_type* f, const value_type* l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  hash_map(const value_type* f, const value_type* l, size_type n,\n           const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n  hash_map(const value_type* f, const value_type* l, size_type n,\n           const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n\n  hash_map(const_iterator f, const_iterator l)\n    : rep(100, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  hash_map(const_iterator f, const_iterator l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_unique(f, l); }\n  hash_map(const_iterator f, const_iterator l, size_type n,\n           const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_unique(f, l); }\n  hash_map(const_iterator f, const_iterator l, size_type n,\n           const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_unique(f, l); }\n#endif /*__STL_MEMBER_TEMPLATES */\n\npublic:\n  size_type size() const { return rep.size(); }\n  size_type max_size() const { return rep.max_size(); }\n  bool empty() const { return rep.empty(); }\n  void swap(hash_map& hs) { rep.swap(hs.rep); }\n  friend bool\n  operator== __STL_NULL_TMPL_ARGS (const hash_map&, const hash_map&);\n\n  iterator begin() { return rep.begin(); }\n  iterator end() { return rep.end(); }\n  const_iterator begin() const { return rep.begin(); }\n  const_iterator end() const { return rep.end(); }\n\npublic:\n  pair<iterator, bool> insert(const value_type& obj)\n    { return rep.insert_unique(obj); }\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }\n#else\n  void insert(const value_type* f, const value_type* l) {\n    rep.insert_unique(f,l);\n  }\n  void insert(const_iterator f, const_iterator l) { rep.insert_unique(f, l); }\n#endif /*__STL_MEMBER_TEMPLATES */\n  pair<iterator, bool> insert_noresize(const value_type& obj)\n    { return rep.insert_unique_noresize(obj); }    \n\n  iterator find(const key_type& key) { return rep.find(key); }\n  const_iterator find(const key_type& key) const { return rep.find(key); }\n\n  T& operator[](const key_type& key) {\n    return rep.find_or_insert(value_type(key, T())).second;\n  }\n\n  size_type count(const key_type& key) const { return rep.count(key); }\n  \n  pair<iterator, iterator> equal_range(const key_type& key)\n    { return rep.equal_range(key); }\n  pair<const_iterator, const_iterator> equal_range(const key_type& key) const\n    { return rep.equal_range(key); }\n\n  size_type erase(const key_type& key) {return rep.erase(key); }\n  void erase(iterator it) { rep.erase(it); }\n  void erase(iterator f, iterator l) { rep.erase(f, l); }\n  void clear() { rep.clear(); }\n\npublic:\n  void resize(size_type hint) { rep.resize(hint); }\n  size_type bucket_count() const { return rep.bucket_count(); }\n  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n  size_type elems_in_bucket(size_type n) const\n    { return rep.elems_in_bucket(n); }\n};\n\ntemplate <class Key, class T, class HashFcn, class EqualKey, class Alloc>\ninline bool operator==(const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,\n                       const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm2)\n{\n  return hm1.rep == hm2.rep;\n}\n```\n\n# 5 hash_multimap\n\n源码（stl_hash_map.h）\n\n```c++\n#ifndef __STL_LIMITED_DEFAULT_TEMPLATES\ntemplate <class Key, class T, class HashFcn = hash<Key>,\n          class EqualKey = equal_to<Key>,\n          class Alloc = alloc>\n#else\ntemplate <class Key, class T, class HashFcn, class EqualKey,\n          class Alloc = alloc>\n#endif\nclass hash_multimap\n{\nprivate:\n  typedef hashtable<pair<const Key, T>, Key, HashFcn,\n                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;\n  ht rep;\n\npublic:\n  typedef typename ht::key_type key_type;\n  typedef T data_type;\n  typedef T mapped_type;\n  typedef typename ht::value_type value_type;\n  typedef typename ht::hasher hasher;\n  typedef typename ht::key_equal key_equal;\n\n  typedef typename ht::size_type size_type;\n  typedef typename ht::difference_type difference_type;\n  typedef typename ht::pointer pointer;\n  typedef typename ht::const_pointer const_pointer;\n  typedef typename ht::reference reference;\n  typedef typename ht::const_reference const_reference;\n\n  typedef typename ht::iterator iterator;\n  typedef typename ht::const_iterator const_iterator;\n\n  hasher hash_funct() const { return rep.hash_funct(); }\n  key_equal key_eq() const { return rep.key_eq(); }\n\npublic:\n  hash_multimap() : rep(100, hasher(), key_equal()) {}\n  explicit hash_multimap(size_type n) : rep(n, hasher(), key_equal()) {}\n  hash_multimap(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}\n  hash_multimap(size_type n, const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) {}\n\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  hash_multimap(InputIterator f, InputIterator l)\n    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  template <class InputIterator>\n  hash_multimap(InputIterator f, InputIterator l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  template <class InputIterator>\n  hash_multimap(InputIterator f, InputIterator l, size_type n,\n                const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n  template <class InputIterator>\n  hash_multimap(InputIterator f, InputIterator l, size_type n,\n                const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n\n#else\n  hash_multimap(const value_type* f, const value_type* l)\n    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  hash_multimap(const value_type* f, const value_type* l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  hash_multimap(const value_type* f, const value_type* l, size_type n,\n                const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n  hash_multimap(const value_type* f, const value_type* l, size_type n,\n                const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n\n  hash_multimap(const_iterator f, const_iterator l)\n    : rep(100, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  hash_multimap(const_iterator f, const_iterator l, size_type n)\n    : rep(n, hasher(), key_equal()) { rep.insert_equal(f, l); }\n  hash_multimap(const_iterator f, const_iterator l, size_type n,\n                const hasher& hf)\n    : rep(n, hf, key_equal()) { rep.insert_equal(f, l); }\n  hash_multimap(const_iterator f, const_iterator l, size_type n,\n                const hasher& hf, const key_equal& eql)\n    : rep(n, hf, eql) { rep.insert_equal(f, l); }\n#endif /*__STL_MEMBER_TEMPLATES */\n\npublic:\n  size_type size() const { return rep.size(); }\n  size_type max_size() const { return rep.max_size(); }\n  bool empty() const { return rep.empty(); }\n  void swap(hash_multimap& hs) { rep.swap(hs.rep); }\n  friend bool\n  operator== __STL_NULL_TMPL_ARGS (const hash_multimap&, const hash_multimap&);\n\n  iterator begin() { return rep.begin(); }\n  iterator end() { return rep.end(); }\n  const_iterator begin() const { return rep.begin(); }\n  const_iterator end() const { return rep.end(); }\n\npublic:\n  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class InputIterator>\n  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }\n#else\n  void insert(const value_type* f, const value_type* l) {\n    rep.insert_equal(f,l);\n  }\n  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }\n#endif /*__STL_MEMBER_TEMPLATES */\n  iterator insert_noresize(const value_type& obj)\n    { return rep.insert_equal_noresize(obj); }    \n\n  iterator find(const key_type& key) { return rep.find(key); }\n  const_iterator find(const key_type& key) const { return rep.find(key); }\n\n  size_type count(const key_type& key) const { return rep.count(key); }\n  \n  pair<iterator, iterator> equal_range(const key_type& key)\n    { return rep.equal_range(key); }\n  pair<const_iterator, const_iterator> equal_range(const key_type& key) const\n    { return rep.equal_range(key); }\n\n  size_type erase(const key_type& key) {return rep.erase(key); }\n  void erase(iterator it) { rep.erase(it); }\n  void erase(iterator f, iterator l) { rep.erase(f, l); }\n  void clear() { rep.clear(); }\n\npublic:\n  void resize(size_type hint) { rep.resize(hint); }\n  size_type bucket_count() const { return rep.bucket_count(); }\n  size_type max_bucket_count() const { return rep.max_bucket_count(); }\n  size_type elems_in_bucket(size_type n) const\n    { return rep.elems_in_bucket(n); }\n};\n\ntemplate <class Key, class T, class HF, class EqKey, class Alloc>\ninline bool operator==(const hash_multimap<Key, T, HF, EqKey, Alloc>& hm1,\n                       const hash_multimap<Key, T, HF, EqKey, Alloc>& hm2)\n{\n  return hm1.rep == hm2.rep;\n}\n```\n\n'),(47,'STL源码剖析13-算法概览',2,'2022-10-22 12:47:57','STL源码剖析','# 1 算法概览\n\nSTL六大组件：\n\n空间配置器、容器、迭代器、仿函数、适配器 都是 class template\n\n算法是function template\n\n![image-20221015203714862](https://cdn.moyusoldier.cn/image-20221015203714862.png)\n\n算法看不见容器，它需要的所有信息都必须从迭代器获得。而迭代器必须能回答算法的所有提问，才能搭配该算法的所有操作。\n\n# 2 迭代器的分类\n\n## 2.1五类迭代器\n\niterator_category是迭代器的五个关联类型之一（5 associated types），迭代器(Iterator)中关联类型的存在是为了回答算法(Algorithm)的问题。\n\n![image-20221015204846976](https://cdn.moyusoldier.cn/image-20221015204846976.png)\n\n5类\n\n1. Input Iterator：只读    \n2. Output Iterator：只写    \n3. Forward Iterator：可读可写，只能前进，每次前进一个单位    \n4. Bidirectional Iterator：可读可写，双向移动，每次移动一个单位    \n5. Random Access Iterator：可读可写，双向移动，每次移动多个单位\n\n图中各种容器对应的迭代器类型见下图的输出结果。\n\n源码（stl_iterator.h）\n\n```c++\n// 五种迭代器类型都是结构体（结构体里啥也没有），不用12345来表现的原因有二\n// 1. 把5种类型设计成结构体，方便程序员可以通过Iterator_traits萃取出迭代器类型，再通过函数重载来cout出具体类型\n// 2. 在实现distance、advance方法的时候，由于类型的继承关系，任何一个类型的实现一定会落到一个版本的实现上\nstruct input_iterator_tag {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag : public input_iterator_tag {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag{};\n\n//凡是叫迭代器的东西，都有5 associated type\ntemplate <class T, class Distance> struct input_iterator {\n  typedef input_iterator_tag iterator_category;\n  typedef T                  value_type;\n  typedef Distance           difference_type;\n  typedef T*                 pointer;\n  typedef T&                 reference;\n};\n\nstruct output_iterator {\n  typedef output_iterator_tag iterator_category;\n  typedef void                value_type;\n  typedef void                difference_type;\n  typedef void                pointer;\n  typedef void                reference;\n};\n\ntemplate <class T, class Distance> struct forward_iterator {\n  typedef forward_iterator_tag iterator_category;\n  typedef T                    value_type;\n  typedef Distance             difference_type;\n  typedef T*                   pointer;\n  typedef T&                   reference;\n};\n\n\ntemplate <class T, class Distance> struct bidirectional_iterator {\n  typedef bidirectional_iterator_tag iterator_category;\n  typedef T                          value_type;\n  typedef Distance                   difference_type;\n  typedef T*                         pointer;\n  typedef T&                         reference;\n};\n\ntemplate <class T, class Distance> struct random_access_iterator {\n  typedef random_access_iterator_tag iterator_category;\n  typedef T                          value_type;\n  typedef Distance                   difference_type;\n  typedef T*                         pointer;\n  typedef T&                         reference;\n};\n```\n\n![image-20221016102518621](https://cdn.moyusoldier.cn/image-20221016102518621.png)\n\n把5种类型设计成结构体，方便程序员可以通过Iterator_traits萃取出迭代器类型，再通过函数重载来cout出具体类型。\n\n## 2.2 istream_iterator\n\n![image-20221016103552117](https://cdn.moyusoldier.cn/image-20221016103552117.png)\n\n## 2.3 ostream_iterator\n\n![image-20221016103916333](https://cdn.moyusoldier.cn/image-20221016103916333.png)\n\n# 3 迭代器对算法的影响\n\n## 3.1 distance方法（如何计算两个迭代器之间的距离？）\n\n源码（stl_iterator.h）\n\n```c++\ntemplate <class InputIterator>\ninline iterator_traits<InputIterator>::difference_type\n__distance(InputIterator first, InputIterator last, input_iterator_tag) {\n  iterator_traits<InputIterator>::difference_type n = 0;\n  while (first != last) {\n    ++first; ++n;\n  }\n  return n;\n}\n\ntemplate <class RandomAccessIterator>\ninline iterator_traits<RandomAccessIterator>::difference_type\n__distance(RandomAccessIterator first, RandomAccessIterator last,\n           random_access_iterator_tag) {\n  return last - first;\n}\n\n//函数入口\ntemplate <class InputIterator>\ninline iterator_traits<InputIterator>::difference_type // 萃取出迭代器的距离的类型\ndistance(InputIterator first, InputIterator last) {\n  typedef typename iterator_traits<InputIterator>::iterator_category category; // 萃取出迭代器的类型\n  return __distance(first, last, category()); // 创建了一个临时对象\n}\n```\n\n为啥只实现了两种类型迭代器（InputIterator、RandomAccessIterator）？另外两种呢？\n\n![image-20221016110043558](https://cdn.moyusoldier.cn/image-20221016110043558.png)\n\n在实现distance、advance方法的时候，由于类型的继承关系，任何一个类型的实现一定会落到一个版本的实现上\n\n## 3.2 advance方法（如何移动迭代器n个距离？）\n\n源码\n\n```c++\ntemplate <class InputIterator, class Distance>\ninline void __advance(InputIterator& i, Distance n, input_iterator_tag) {\n  while (n--) ++i;\n}\n\ntemplate <class BidirectionalIterator, class Distance>\ninline void __advance(BidirectionalIterator& i, Distance n, \n                      bidirectional_iterator_tag) {\n  if (n >= 0)\n    while (n--) ++i;\n  else\n    while (n++) --i;\n}\n\ntemplate <class RandomAccessIterator, class Distance>\ninline void __advance(RandomAccessIterator& i, Distance n, \n                      random_access_iterator_tag) {\n  i += n;\n}\n\n// 函数入口\ntemplate <class InputIterator, class Distance>\ninline void advance(InputIterator& i, Distance n) {\n  __advance(i, n, iterator_category(i));// 见下文\n}\n\n//与distance方法实现的稍有不同之处，通过函数获得迭代器的类型并创建对象\ntemplate <class Iterator>\ninline typename iterator_traits<Iterator>::iterator_category\niterator_category(const Iterator&) {\n  typedef typename iterator_traits<Iterator>::iterator_category category;\n  return category();\n}\n\n```\n\n## 3.3 copy方法\n\n![image-20221016111113258](https://cdn.moyusoldier.cn/image-20221016111113258.png)\n\n## 3.4 destroy方法\n\n![image-20221016113653356](https://cdn.moyusoldier.cn/image-20221016113653356.png)\n\n![image-20221016114044853](https://cdn.moyusoldier.cn/image-20221016114044853.png)\n\n## 3.5 unique_copy方法\n\n![image-20221016114112394](https://cdn.moyusoldier.cn/image-20221016114114244.png)\n\n注:OutputIterator是只写的，应该避免read动作，如左图。\n\n# 4 算法对迭代器的“暗示”\n\n![image-20221016115219710](https://cdn.moyusoldier.cn/image-20221016115219710.png)\n\n如sort中，没有强制规定传入RandomAccessIterator，但是“暗示”要传入这种类型。如果类型不对，最终还是无法执行。\n\n'),(48,'STL源码剖析14-算法11例',4,'2022-10-22 12:50:02','STL源码剖析','# 1 概述\n\nC函数的传参\n\n```c++\n// 起点，元素个数...\nqsort(c.data(),ASIZE,sizeof(long),compareLongs);\nlong *pItem = (long*)bsearch(&target,(c.data()),ASIZE,sizeof(long),compareLongs);\n```\n\nC++函数的传参\n\n```c++\n// 起点，终点...\ncout<<count_if(vi.begin(),vi.end(),not1(bind2nd(less<int>(),40)));\nauto ite = find(c.begin(),c.end(),target);\nsort(c.begin,c.end());\n```\n\nSCI STL的实现文件\n\n- stl_algo.h: 算法（数值类除外）\n- stl_algobase.h: 基本算法 swap, min, max, copy, copy_backward, copy_n, fill, fill_n, mismatch, equal, lexicographical_compare\n- stl_function.h: 函数对象（function object）或称仿函数（functor）\n- stl_numeric.h: 数值类算法 accumulate, inner_product, partial_sum, adjacent_difference, power, iota\n\n相应的头文件\n\n```c++\n#include <algorithm>\n#include <functional>\n#include <numeric>\n```\n\n\n\n# 2 accumulate\n\n源码 stl_numeric.h\n\n```c++\ntemplate <class InputIterator, class T>\nT accumulate(InputIterator first, InputIterator last, T init) {\n  for ( ; first != last; ++first)\n    init = init + *first;\n  return init;\n}\n\n// 最后一个参数是函数or仿函数\ntemplate <class InputIterator, class T, class BinaryOperation>\nT accumulate(InputIterator first, InputIterator last, T init,\n             BinaryOperation binary_op) {\n  for ( ; first != last; ++first)\n    init = binary_op(init, *first);\n  return init;\n}\n```\n\ndemo（这里使用的并不是GNUC 2.9的STL）\n\n```c++\n#include <iostream>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\nint myfun(int x, int y) {\n    return x + 2 * y;\n}\n\nstruct myclass {\n    int operator()(int x, int y) {\n        return x + 3 * y;\n    }\n}myobj;\n\nint main () {\n    int init = 100;\n    int nums[] = {10, 20, 30};\n\n    cout << \"using default accumulate: \";\n    cout << accumulate(nums, nums + 3, init); // 160\n    cout << \'\\n\';\n\n    cout << \"using functional\'s minus: \";\n    cout << accumulate(nums, nums + 3, init, minus<int>()); // 40\n    cout << \'\\n\';\n\n    cout << \"using custom function: \";\n    cout << accumulate(nums, nums + 3, init, myfun); // 220\n    cout << \'\\n\';\n\n    cout << \"using custom object: \";\n    cout << accumulate(nums, nums + 3, init, myobj); // 280\n    cout << \'\\n\';\n}\n```\n\n# 3 for_each\n\n 源码（stl_algo.h）\n\n```c++\ntemplate <class InputIterator, class Function>\nFunction for_each(InputIterator first, InputIterator last, Function f) {\n  for ( ; first != last; ++first)\n    f(*first);\n  return f;\n}\n```\n\ndemo\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvoid myfun(int i) {\n    cout << \' \' << i;\n}\n\nstruct myclass {\n    void operator()(int i) {\n        cout << \' \' << i;\n    }\n} myobj;\n\nint main() {\n    vector<int> myvec;\n    myvec.push_back(10);\n    myvec.push_back(20);\n    myvec.push_back(30);\n\n    for_each(myvec.begin(), myvec.end(), myfun);\n    cout << endl;\n\n    for_each(myvec.begin(), myvec.end(), myobj);\n    cout << endl;\n\n    //C++11\n    for (auto &elem: myvec) {\n        elem += 5;\n    }\n    for (auto &elem: myvec) {\n        cout << \' \' << elem; // 15 25 35\n    }\n\n}\n```\n\n# 4 replace, replace_if, replace_copy\n\n 源码（stl_algo.h）\n\n```c++\ntemplate <class ForwardIterator, class T>\nvoid replace(ForwardIterator first, ForwardIterator last, const T& old_value,\n             const T& new_value) {\n  // 范围内所有等同于old_value者都以new_value取代\n  for ( ; first != last; ++first)\n    if (*first == old_value) *first = new_value;\n}\n\ntemplate <class ForwardIterator, class Predicate, class T>\nvoid replace_if(ForwardIterator first, ForwardIterator last, Predicate pred,\n                const T& new_value) {\n  // 范围内所有满足pred()==ture者都以new_value取代\n  for ( ; first != last; ++first)\n    if (pred(*first)) *first = new_value;\n}\n\ntemplate <class InputIterator, class OutputIterator, class T>\nOutputIterator replace_copy(InputIterator first, InputIterator last,\n                            OutputIterator result, const T& old_value,\n                            const T& new_value) {\n  // 范围内所有等同于old_value者都已new_value放至新区间，不符合者以原值放入新区间  \n  for ( ; first != last; ++first, ++result)\n    *result = *first == old_value ? new_value : *first;\n  return result;\n}\n```\n\n# 5 count, count_if\n\n源码（stl_algo.h）\n\n```c++\ntemplate <class InputIterator, class T, class Size>\nvoid count(InputIterator first, InputIterator last, const T& value,\n           Size& n) {\n  for ( ; first != last; ++first)\n    if (*first == value)\n      ++n;\n}\n\ntemplate <class InputIterator, class Predicate, class Size>\nvoid count_if(InputIterator first, InputIterator last, Predicate pred,\n              Size& n) {\n  for ( ; first != last; ++first)\n    if (pred(*first))\n      ++n;\n}\n```\n\n- 容器**不带**成员函数count()：\n\narray, vector, list, forward_list, deque\n\n- 容器**带**成员函数count()：关联式容器！！！\n\nset/multiset,\n\nmap/multimap,\n\nunordered_set/unordered_multiset,\n\nunordered_map/unordered_multimap.\n\n# 6 find, find_if\n\n源码（stl_algo.h）\n\n```c++\ntemplate <class InputIterator, class T>\nInputIterator find(InputIterator first, InputIterator last, const T& value) {\n  while (first != last && *first != value) ++first;\n  return first;\n}\n\ntemplate <class InputIterator, class Predicate>\nInputIterator find_if(InputIterator first, InputIterator last,\n                      Predicate pred) {\n  while (first != last && !pred(*first)) ++first;\n  return first;\n}\n```\n\n- 容器**不带**成员函数find()：\n\narray, vector, list, forward_list, deque\n\n- 容器**带**成员函数find()：关联式容器！！！ \n\nset/multiset,\n\nmap/multimap,\n\nunordered_set/unordered_multiset,\n\nunordered_map/unordered_multimap.\n\n# 7 sort\n\ndemo\n\n```c++\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n\nusing namespace std;\n\nbool myfun(int i, int j) {\n    return i < j;\n}\n\nstruct myclass {\n    bool operator()(int i, int j) {\n        return i < j;\n    }\n} myobj;\n\nint main() {\n    int myints[] = {32, 71, 12, 45, 26, 80, 53, 33};\n    vector<int> myvec(myints, myints + 8);\n\n    sort(myvec.begin(), myvec.begin() + 4); //(12 32 45 71) 26 80 53 33\n\n    sort(myvec.begin() + 4, myvec.end(), myfun); // 12 32 45 71 (26 33 53 80)\n\n    sort(myvec.begin(), myvec.end(), myobj); // 12 26 32 33 45 53 71 80\n\n    sort(myvec.rbegin(), myvec.rend()); // 80 71 53 45 33 32 26 12  \n}\n\n```\n\n- 容器**不带**成员函数sort()：\n\n仅限迭代器类型为randomaccessIterator可使用全局sort\n\narray, vector,  deque\n\n关联式容器！！！ 遍历自然形成sorted状态，不能用全局sort，会报错\n\nset/multiset,\n\nmap/multimap,\n\nunordered_set/unordered_multiset,\n\nunordered_map/unordered_multimap.\n\n- 容器**带**成员函数sort()：\n\nlist, forward_list 不能用全局sort，会报错\n\n# 8 binary_search\n\n基础知识：二分查找的实现lower_bound和upper_bound\n\n## 8.1 lower_bound\n\nlower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。\n\n![image-20221017152433276](https://cdn.moyusoldier.cn/image-20221017152433276.png)\n\n源码（stl_algo.h）\n\n```c++\n//提供的两个版本的接口\n//版本1\ntemplate <class ForwardIterator, class T>\ninline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,\n                                   const T& value) {\n  return __lower_bound(first, last, value, distance_type(first),\n                       iterator_category(first));\n}\n\n//版本2\ntemplate <class ForwardIterator, class T, class Compare>\ninline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,\n                                   const T& value, Compare comp) {\n  return __lower_bound(first, last, value, comp, distance_type(first),\n                       iterator_category(first));\n}\n\n// 具体实现\n// 1-1\ntemplate <class ForwardIterator, class T, class Distance>\nForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,\n                              const T& value, Distance*,\n                              forward_iterator_tag) {\n  Distance len = 0;\n  distance(first, last, len); // 返回[first,last)内的元素个数\n  Distance half;\n  ForwardIterator middle;\n\n  // 相当于left = 0, right = n\n  // while left < right 结束条件是left=right，或者说first = last\n  while (len > 0) {\n    half = len >> 1;\n    middle = first;\n    advance(middle, half);\n    if (*middle < value) {\n      first = middle;\n      ++first; // middle不满足条件，故从middle+1重新开始\n      len = len - half - 1;\n    }\n    else\n      len = half;\n  }\n  return first;\n}\n\n//1-2\ntemplate <class RandomAccessIterator, class T, class Distance>\nRandomAccessIterator __lower_bound(RandomAccessIterator first,\n                                   RandomAccessIterator last, const T& value,\n                                   Distance*, random_access_iterator_tag) {\n  Distance len = last - first;\n  Distance half;\n  RandomAccessIterator middle;\n\n  while (len > 0) {\n    half = len >> 1;\n    middle = first + half;\n    if (*middle < value) {\n      first = middle + 1;\n      len = len - half - 1;\n    }\n    else\n      len = half;\n  }\n  return first;\n}\n\n//2-1\ntemplate <class ForwardIterator, class T, class Compare, class Distance>\nForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,\n                              const T& value, Compare comp, Distance*,\n                              forward_iterator_tag) {\n  Distance len = 0;\n  distance(first, last, len);\n  Distance half;\n  ForwardIterator middle;\n\n  while (len > 0) {\n    half = len >> 1;\n    middle = first;\n    advance(middle, half);\n    if (comp(*middle, value)) {\n      first = middle;\n      ++first;\n      len = len - half - 1;\n    }\n    else\n      len = half;\n  }\n  return first;\n}\n\n//2-2\ntemplate <class RandomAccessIterator, class T, class Compare, class Distance>\nRandomAccessIterator __lower_bound(RandomAccessIterator first,\n                                   RandomAccessIterator last,\n                                   const T& value, Compare comp, Distance*,\n                                   random_access_iterator_tag) {\n  Distance len = last - first;\n  Distance half;\n  RandomAccessIterator middle;\n\n  while (len > 0) {\n    half = len >> 1;\n    middle = first + half;\n    if (comp(*middle, value)) {\n      first = middle + 1;\n      len = len - half - 1;\n    }\n    else\n      len = half;\n  }\n  return first;\n}\n\n```\n\n## 8.2 upper_bound\n\n用于在指定范围内查找大于目标值的第一个元素\n\n源码\n\n```c++\ntemplate <class ForwardIterator, class T>\ninline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,\n                                   const T& value) {\n  return __upper_bound(first, last, value, distance_type(first),\n                       iterator_category(first));\n}\n\ntemplate <class ForwardIterator, class T, class Compare>\ninline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,\n                                   const T& value, Compare comp) {\n  return __upper_bound(first, last, value, comp, distance_type(first),\n                       iterator_category(first));\n}\n\ntemplate <class ForwardIterator, class T, class Distance>\nForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,\n                              const T& value, Distance*,\n                              forward_iterator_tag) {\n  Distance len = 0;\n  distance(first, last, len);\n  Distance half;\n  ForwardIterator middle;\n\n  while (len > 0) {\n    half = len >> 1;\n    middle = first;\n    advance(middle, half);\n    if (value < *middle)\n      len = half;\n    else {\n      first = middle;\n      ++first;\n      len = len - half - 1;\n    }\n  }\n  return first;\n}\n\ntemplate <class RandomAccessIterator, class T, class Distance>\nRandomAccessIterator __upper_bound(RandomAccessIterator first,\n                                   RandomAccessIterator last, const T& value,\n                                   Distance*, random_access_iterator_tag) {\n  Distance len = last - first;\n  Distance half;\n  RandomAccessIterator middle;\n\n  while (len > 0) {\n    half = len >> 1;\n    middle = first + half;\n    if (value < *middle)\n      len = half;\n    else {\n      first = middle + 1;\n      len = len - half - 1;\n    }\n  }\n  return first;\n}\n\ntemplate <class ForwardIterator, class T, class Compare, class Distance>\nForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,\n                              const T& value, Compare comp, Distance*,\n                              forward_iterator_tag) {\n  Distance len = 0;\n  distance(first, last, len);\n  Distance half;\n  ForwardIterator middle;\n\n  while (len > 0) {\n    half = len >> 1;\n    middle = first;\n    advance(middle, half);\n    if (comp(value, *middle))\n      len = half;\n    else {\n      first = middle;\n      ++first;\n      len = len - half - 1;\n    }\n  }\n  return first;\n}\n\ntemplate <class RandomAccessIterator, class T, class Compare, class Distance>\nRandomAccessIterator __upper_bound(RandomAccessIterator first,\n                                   RandomAccessIterator last,\n                                   const T& value, Compare comp, Distance*,\n                                   random_access_iterator_tag) {\n  Distance len = last - first;\n  Distance half;\n  RandomAccessIterator middle;\n\n  while (len > 0) {\n    half = len >> 1;\n    middle = first + half;\n    if (comp(value, *middle))\n      len = half;\n    else {\n      first = middle + 1;\n      len = len - half - 1;\n    }\n  }\n  return first;\n}\n\n```\n\n## 8.3 binary_search\n\n源码（stl_algo.h）\n\n```c++\ntemplate <class ForwardIterator, class T>\nbool binary_search(ForwardIterator first, ForwardIterator last,\n                   const T& value) {\n  ForwardIterator i = lower_bound(first, last, value);\n  // 这一步的判断和二分查找寻找左侧边界最后的返回是一样的\n  // if (left == nums.length) return -1;\n  // return nums[left] == target ? left : -1;\n  return i != last && !(value < *i);\n}\n\ntemplate <class ForwardIterator, class T, class Compare>\nbool binary_search(ForwardIterator first, ForwardIterator last, const T& value,\n                   Compare comp) {\n  ForwardIterator i = lower_bound(first, last, value, comp);\n  return i != last && !comp(value, *i);\n}\n```\n\n'),(49,'STL源码剖析15-sort',10,'2022-10-22 12:50:40','STL源码剖析','# 1 概述\n\n## 1.1 用处\n\n函数原型（stl_algo.h）\n\n```c++\ntemplate <class RandomAccessIterator>\ninline void sort(RandomAccessIterator first, RandomAccessIterator last) {\n  if (first != last) {\n    __introsort_loop(first, last, value_type(first), __lg(last - first) * 2);\n    __final_insertion_sort(first, last);\n  }\n}\n\ntemplate <class RandomAccessIterator, class Compare>\ninline void sort(RandomAccessIterator first, RandomAccessIterator last,\n                 Compare comp) {\n  if (first != last) {\n    __introsort_loop(first, last, value_type(first), __lg(last - first) * 2,\n                     comp);\n    __final_insertion_sort(first, last, comp);\n  }\n}\n```\n\n`sort()`方法接受两个RandomAccessIterator。\n\n所有关联式容器都是自动排序（基于rb tree）或者不需要排序的（基于hashtable），故用不到这个`sort()`。\n\n序列式容器只有vector、list、deque的迭代器类型是RandomAccessIterator，用到这个`sort()`；\n\nlist的迭代器类型是BidirectionalIterator，slist的迭代器类型是ForwardIterator，都要用member function sort() 来排序。\n\n## 1.2 策略\n\n- 数据量大时采用Quick Sort，分段递归排序。\n\n- 一旦分段后的数据量小于某个阈值，为避免Quick Sort的递归调用带来过大的额外负荷，就改用Insertion Sort。\n\n- 如果递归层次过深，还会采用Heap Sort\n\n下面分别介绍Insertion Sort和Quick Sort，然后再整合起来介绍STL sort算法。\n\n# 2 Insertion Sort\n\n![insertionSort](https://cdn.moyusoldier.cn/insertionSort.gif)\n\n插入排序的时间复杂度是$O(n^2)$，说起来并不理想，但当数据量很少时，却有不错的效果，原因是是现实有一些技巧（稍后源码可见）。\n\nInsertion Sort一共有两个版本，版本二允许用户指定一个仿函数，以下只介绍版本一的源码。\n\n```c++\ntemplate <class RandomAccessIterator>\nvoid __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {\n  if (first == last) return; \n  for (RandomAccessIterator i = first + 1; i != last; ++i)\n    __linear_insert(first, i, value_type(first));\n}\n\ntemplate <class RandomAccessIterator, class T>\ninline void __linear_insert(RandomAccessIterator first, \n                            RandomAccessIterator last, T*) {  \n  T value = *last;\n  // 特判：如果比第一个元素小，就放到第一个元素的位置  \n  if (value < *first) {\n    copy_backward(first, last, last + 1);\n    *first = value;\n  }\n  else\n    __unguarded_linear_insert(last, value);\n}\n\ntemplate <class RandomAccessIterator, class T>\nvoid __unguarded_linear_insert(RandomAccessIterator last, T value) {\n  RandomAccessIterator next = last;\n  --next;\n  // 由于之前进行了特判，value肯定大于等于第一个元素，故这里不用判断是否到达边界，提高了效率\n  while (value < *next) {\n    *last = *next;\n    last = next;\n    --next;\n  }\n  *last = value;\n}\n```\n\n# 3 Quick Sort\n\n平均时间复杂度$O(NlogN)$，最坏情况$O(N^2)$，但通过IntroSort（极类似median-of-three的一种排序算法）可将最坏情况推进到$O(NlogN)$。早期的STL sort算法都采用Quick Sort，SGI STL已改用IntroSort。\n\n![img](https://cdn.moyusoldier.cn/quickSort.gif)\n\n快排算法可以叙述如下，假设S代表将被处理的序列：\n\n- 如果S的元素个数为0或1，结束\n- 取S中任何一个元素作为pivot\n- 将S分为L，R两段，使L内的每一个元素都小于或等于pivot，R内的每一个元素都大于或等于pivot\n- 对L，R递归执行Quick Sort\n\n# 4 Median-of-three\n\n任何一个元素都可以作为pivot，但是其合适与否却会影响Quick Sort的效率。\n\n为了避免元素当初输入时不够随机所带来的恶化效应，最理想最稳当的方式就是取整个序列的头、尾、中央三个位置的元素。\n\n以头、尾、中央三个位置的元素中的中值（median）作为pivot的方法称为Median-of-three，或称为median-of-three-QuickSort。\n\n为了能够快速取出中央位置的元素，显然迭代器必须能随机存取，故必须是RandomAccessIterator。\n\n以下是SGI STL提供的三点中值确定函数\n\n```c++\ntemplate <class T>\ninline const T& __median(const T& a, const T& b, const T& c) {\n  if (a < b)\n    if (b < c)\n      return b;\n    else if (a < c)\n      return c;\n    else\n      return a;\n  else if (a < c)\n    return a;\n  else if (b < c)\n    return c;\n  else\n    return b;\n}\n```\n\n# 5 Partitioning\n\n分割：使L内的每一个元素都小于或等于pivot，R内的每一个元素都大于或等于pivot。\n\n```c++\ntemplate <class RandomAccessIterator, class T>\nRandomAccessIterator __unguarded_partition(RandomAccessIterator first, \n                                           RandomAccessIterator last, \n                                           T pivot) {\n  while (true) {\n    while (*first < pivot) ++first; // first调整到>=pivot的元素\n    --last;\n    while (pivot < *last) --last; // last调整到<=pivot的元素\n    if (!(first < last)) return first;  //first>=last 结束\n    iter_swap(first, last); // 交换first和last\n    ++first;\n  }\n}  \n```\n\n# 6 Threshold\n\n多小的序列才应该将Quick Sort改为Insertion Sort呢？5-20都可能导致差不多的结果，实际的最佳值因设备而异。SGI STL用过16.\n\n# 7 Final insertion sort\n\n如果我们令某个大小以下的子序列滞留在“几近排序但尚未完成”的状态，最后再以一次Insertion Sort将所有这些子序列做一次完成排序，效率一般会比”将所有子序列彻底排序“更好。\n\n这是因为Insertion Sort在面对“几乎排序“的序列时会有很好的表现。\n\n# 8 Introsort\n\nIntrosort在大部分情况下与median-of-three-QuickSort完全相同，只是在递归层次过深时（分割恶化），会采用Heap Sort，使效率维持在Heap Sort的$O(NlogN)$。\n\n# 9 Sort\n\n千呼万唤始出来！\n\n```c++\ntemplate <class RandomAccessIterator>\ninline void sort(RandomAccessIterator first, RandomAccessIterator last) {\n  if (first != last) {\n    __introsort_loop(first, last, value_type(first), __lg(last - first) * 2);\n    // 此时[first,last)内有多个元素个数小于16的序列，属于“几近排序但尚未完成”的状态\n    __final_insertion_sort(first, last);\n  }\n}\n\n// 用来控制分割（partition）恶化的情况\n// 取log2(n)向下取整\ntemplate <class Size>\ninline Size __lg(Size n) {\n  Size k;\n  for (k = 0; n > 1; n >>= 1) ++k;\n  return k;\n}\n\n// 当元素个数为40时，最后一个参数为5*2，表示最多允许分割10层\ntemplate <class RandomAccessIterator, class T, class Size>\nvoid __introsort_loop(RandomAccessIterator first,\n                      RandomAccessIterator last, T*,\n                      Size depth_limit) {\n  while (last - first > __stl_threshold) {  //  __stl_threshold是一个全局常数，稍早定义为const int 16\n    if (depth_limit == 0) { // 如果分割层次超过指定值，分割恶化\n      partial_sort(first, last, last); // 改用heapsort\n      return;\n    }\n    --depth_limit;\n    // 以下是median-of-three-QuickSort，选择一个较好的pivot并决定分割点\n    // 分割点将落在迭代器cut上\n    RandomAccessIterator cut = __unguarded_partition\n      (first, last, T(__median(*first, *(first + (last - first)/2),\n                               *(last - 1))));\n    // 对右半段递归进行sort\n    __introsort_loop(cut, last, value_type(first), depth_limit);\n    last = cut;\n    // 现在回到while循环，准备对左半段递归进行sort\n    // 这种写法可读性较差，效率并没有比较好  \n  }\n}\n\n//最终的插入排序\ntemplate <class RandomAccessIterator>\nvoid __final_insertion_sort(RandomAccessIterator first, \n                            RandomAccessIterator last) {\n  // 如果元素个数大于16  \n  if (last - first > __stl_threshold) { \n    // 将[first,last)分割成一段长为16的子序列和另一段剩余子序列 \n    __insertion_sort(first, first + __stl_threshold);\n    __unguarded_insertion_sort(first + __stl_threshold, last);\n  }\n  else\n    __insertion_sort(first, last);\n}\n\ntemplate <class RandomAccessIterator>\ninline void __unguarded_insertion_sort(RandomAccessIterator first, \n                                RandomAccessIterator last) {\n  __unguarded_insertion_sort_aux(first, last, value_type(first));\n}\n\ntemplate <class RandomAccessIterator, class T>\nvoid __unguarded_insertion_sort_aux(RandomAccessIterator first, \n                                    RandomAccessIterator last, T*) {\n  for (RandomAccessIterator i = first; i != last; ++i)\n    __unguarded_linear_insert(i, T(*i));\n}\n\n```\n\n'),(50,'STL源码剖析16-仿函数',18,'2022-10-22 12:51:17','STL源码剖析','# 1 概述\n\n## 1.1 名字\n\n这一节探索的东西有两个名字：仿函数（functors）和函数对象（function objects）\n\n仿函数：模仿函数，可以像函数一样被调用。（最贴切）\n\n函数对象：一种具有函数特质的对象。（新名称）\n\n## 1.2 主要应用在哪？\n\nSTL的各种算法往往有两个版本，第一个版本表现出最常用（直观）的某种运算，第二个版本表现出最泛化的某种运算，允许用户以template参数来指定所要采取的策略。\n\n## 1.3为什么不用函数指针？\n\n不能满足STL对抽象性的要求，也不能满足软件积木的要求——函数指针无法和STL其它组件（如配接器adapter）搭配，产生更灵活的变化。\n\n## 1.4 使用方法\n\n```\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint main() {\n	// 第一种方法：先实例化一个名为ig的对象，ig(4, 6)是调用其operator()，并传入两个参数4，6\n    greater<int> ig;\n    cout << boolalpha << ig(4, 6); // false\n    // 第二种方法（主流用法）：产生一个临时对象，之后的(4, 6)才是指定两个参数4，6\n    cout << greater<int>()(6, 4); // true\n}\n```\n\n## 1.5 仿函数的分类\n\n以功能划分为三类仿函数：算数类（Arithmetic）、关系运算类（Rational）、逻辑运算类（Logical）\n\n# 2 算术类仿函数\n\n加减乘除，取模，否定\n\n```c++\ntemplate <class T>\nstruct plus : public binary_function<T, T, T> {\n    T operator()(const T& x, const T& y) const { return x + y; }\n};\n\ntemplate <class T>\nstruct minus : public binary_function<T, T, T> {\n    T operator()(const T& x, const T& y) const { return x - y; }\n};\n\ntemplate <class T>\nstruct multiplies : public binary_function<T, T, T> {\n    T operator()(const T& x, const T& y) const { return x * y; }\n};\n\ntemplate <class T>\nstruct divides : public binary_function<T, T, T> {\n    T operator()(const T& x, const T& y) const { return x / y; }\n};\n\ntemplate <class T>\nstruct modulus : public binary_function<T, T, T> {\n    T operator()(const T& x, const T& y) const { return x % y; }\n};\n\ntemplate <class T>\nstruct negate : public unary_function<T, T> {\n    T operator()(const T& x) const { return -x; }\n};\n```\n\n# 3 关系运算类仿函数\n\n6种\n\n```c++\ntemplate <class T>\nstruct equal_to : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x == y; }\n};\n\ntemplate <class T>\nstruct not_equal_to : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x != y; }\n};\n\ntemplate <class T>\nstruct greater : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x > y; }\n};\n\ntemplate <class T>\nstruct less : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x < y; }\n};\n\ntemplate <class T>\nstruct greater_equal : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x >= y; }\n};\n\ntemplate <class T>\nstruct less_equal : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x <= y; }\n};\n```\n\n# 4 逻辑运算类仿函数\n\n3种\n\n```c++\ntemplate <class T>\nstruct logical_and : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x && y; }\n};\n\ntemplate <class T>\nstruct logical_or : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x || y; }\n};\n\ntemplate <class T>\nstruct logical_not : public unary_function<T, bool> {\n    bool operator()(const T& x) const { return !x; }\n};\n```\n\n# 5 C++标准外的仿函数\n\nC++标准规格未规定，这些是GNUC独有，非标准。\n\n回顾关联式容器：\n\n红黑树一族\n\n```c++\n//stl_tree.h\ntemplate <class Key, class Value, class KeyOfValue, class Compare,\n          class Alloc = alloc>\nclass rb_tree {\n    //...\n};\n\n//stl_map.h\n//map和multimap中rb tree的定义相同\ntemplate <class Key, class T, class Compare = less<Key>, class Alloc = alloc>\nclass map {\nprivate:\n  typedef rb_tree<key_type, value_type, \n                  select1st<value_type>, key_compare, Alloc> rep_type;\n  rep_type t;  // red-black tree representing map\n  //...\n};\n\n//stl_set.h\ntemplate <class Key, class Compare = less<Key>, class Alloc = alloc>\nclass set {\nprivate:\n  typedef rb_tree<key_type, value_type, \n                  identity<value_type>, key_compare, Alloc> rep_type;\n  rep_type t;  // red-black tree representing set\n  //...  \n};\n```\n\nhash_table一族\n\n```c++\ntemplate <class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc>\nclass hashtable {\n    //...\n};\n\n//stl_hash_map.h\ntemplate <class Key, class T, class HashFcn = hash<Key>,\n          class EqualKey = equal_to<Key>,\n          class Alloc = alloc>\nclass hash_map\n{\nprivate:\n  typedef hashtable<pair<const Key, T>, Key, HashFcn,\n                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;\n  ht rep;\n  //...\n}\n\n//stl_hash_set.h\ntemplate <class Value, class HashFcn = hash<Value>,\n          class EqualKey = equal_to<Value>,\n          class Alloc = alloc>\nclass hash_set\n{\nprivate:\n  typedef hashtable<Value, Value, HashFcn, identity<Value>, \n                    EqualKey, Alloc> ht;\n  ht rep;\n  //...\n};\n```\n\n发现map和set使用的仿函数分别是select1st和identity\n\n```c++\ntemplate <class T>\nstruct identity : public unary_function<T, T> {\n  const T& operator()(const T& x) const { return x; }\n};\n\ntemplate <class Pair>\nstruct select1st : public unary_function<Pair, typename Pair::first_type> {\n  const typename Pair::first_type& operator()(const Pair& x) const\n  {\n    return x.first;\n  }\n};\n\ntemplate <class Pair>\nstruct select2nd : public unary_function<Pair, typename Pair::second_type> {\n  const typename Pair::second_type& operator()(const Pair& x) const\n  {\n    return x.second;\n  }\n};\n```\n\n# 6 可配接（Adaptable）的关键\n\n自己创建的仿函数VS标准库中的仿函数的区别？有没有**继承**，未继承就没融入到STL中。\n\nSTL仿函数应该有能力被函数配接器（functioon adapter）修饰，彼此像积木一样地串接。为了拥有配接能力，每一个仿函数必须定义自己的关联类型（associated types），就像迭代器的关联类型一样。\n\n> 仿函数（functor）中关联类型的存在是为了回答配接器（adapter）的问题。\n>\n> 迭代器（Iterator）中关联类型的存在是为了回答算法（Algorithm）的问题。\n\n这些关联类型的目的是向配接器提供某些信息，主要是参数类型和返回值。\n\n在<stl_function.h>中定义了两个类，分别表示一元仿函数和二元仿函数（STL不支持三元仿函数），其中没有任何data members或member functions，只有typedef。任何仿函数旋转继承其一即可自动拥有关联类型，从而具有配接能力。\n\n## 6.1 unary_function\n\n```c++\ntemplate <class Arg, class Result>\nstruct unary_function {\n    typedef Arg argument_type;\n    typedef Result result_type;\n};\n```\n\n## 6.2 binary_function\n\n```c++\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function {\n    typedef Arg1 first_argument_type;\n    typedef Arg2 second_argument_type;\n    typedef Result result_type;\n};    \n```\n\n\n\n\n\n'),(51,'STL源码剖析17-适配器',50,'2022-10-22 12:51:51','STL源码剖析','# 1 概述\n\n## 1.1 名字\n\n适配器，配接器，改造器\n\n## 1.2 是什么\n\n适配器的关键：A改造了B，人们用A，实际上是A交给B来做。\n\n实现方案：继承or内含？内含\n\n## 1.3 分类\n\n![image-20221017190754629](https://cdn.moyusoldier.cn/image-20221017190754629.png)\n\n应用于容器 container adapter\n\n应用于迭代器 iterator adapter\n\n应用于仿函数 functor adapter\n\n# 1 container adapter\n\n如queue、stack是基于deque的适配器\n\n# 2 functor adapter\n\n **Effective Modern C++: 优先lambda表达式，而非bind**\n\n**人生建议：学好lambda表达式！！！**\n\n## 2.1 bind2nd\n\n问题：统计vector中小于40的元素个数\n\n（本小节仅讨论bind2nd，不讨论图中前面的not1）\n\n![image-20221017193220066](https://cdn.moyusoldier.cn/image-20221017193220066.png)\n\n注意体会functor和functor adapter之间的“问”和“答\"。functor adapter（本例中是bind2nd）一共问了functor（less\\<int>()）三个问题\n\n1. 第二个参数y是什么类型\n2. 第一个参数x是什么类型\n3. 返回值是什么类型\n\n源码（stl_function.h）\n\n```c++\n//functor\ntemplate <class T>\nstruct less : public binary_function<T, T, bool> {\n    bool operator()(const T& x, const T& y) const { return x < y; }\n};\n\n//functor adapter的主体\ntemplate <class Operation, class T>\ninline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {\n  // 问题1：注意这里是adapter向functor提问second_argument_type，functor来回答\n  // typename的目的是让编译器不报错  \n  typedef typename Operation::second_argument_type arg2_type;\n  // 检测传入的参数x=40是否能转成arg2_type\n  return binder2nd<Operation>(op, arg2_type(x));\n}\n\n//functor adapter的辅助实现\n//继承自unary_function，表示自己还可以被改造。自己只有一个参数。\ntemplate <class Operation> \nclass binder2nd\n  : public unary_function<typename Operation::first_argument_type,\n                          typename Operation::result_type> {\nprotected:\n  Operation op;\n  // 注意这里是adapter向functor提问second_argument_type，functor来回答                    \n  typename Operation::second_argument_type value;\npublic:\n  // 构造函数，入参是op, arg2_type(x)                           \n  binder2nd(const Operation& x,\n            const typename Operation::second_argument_type& y) \n      : op(x), value(y) {}\n  // 问题2：注意这里是adapter向functor提问first_argument_type，functor来回答\n  // 问题3：注意这里是adapter向functor提问result_type，functor来回答                                \n  typename Operation::result_type\n  operator()(const typename Operation::first_argument_type& x) const {\n    // 注意adapter的返回值，这里相当于调用函数less<int>()(x,value)  \n    return op(x, value); \n  }\n};\n```\n\n源码（stl_algo.h）\n\n```c++\ntemplate <class InputIterator, class Predicate, class Size>\nvoid count_if(InputIterator first, InputIterator last, Predicate pred,\n              Size& n) {\n  for ( ; first != last; ++first)\n    if (pred(*first))\n      ++n;\n}\n```\n\n## 2.2 not1\n\n问题：统计vector中**不**小于40的元素个数\n\n堆积木：functor adapter + functor adapter + functor\n\n![image-20221017193220066](https://cdn.moyusoldier.cn/image-20221017193220066.png)\n\n```c++\n//functor adapter的主体\n// pred传来的参数是bind2nd(less<int>(),40)\ntemplate <class Predicate>\ninline unary_negate<Predicate> not1(const Predicate& pred) {\n  return unary_negate<Predicate>(pred);\n}\n\n//functor adapter的辅助实现\ntemplate <class Predicate>\nclass unary_negate\n  : public unary_function<typename Predicate::argument_type, bool> {\nprotected:\n  Predicate pred;\npublic:\n  explicit unary_negate(const Predicate& x) : pred(x) {}\n  // functor adapter的返回类型应该和被改造的一样，所以询问Predicate::argument_type\n  bool operator()(const typename Predicate::argument_type& x) const {\n    return !pred(x);\n  }\n};\n\n```\n\n## 2.3 bind C++11的新型Adapter\n\n![image-20221017202526595](https://cdn.moyusoldier.cn/image-20221017202526595.png)\n\n# 3 iterator adapter\n\n## reverse_iterator\n\n可以一般迭代器的前进方向进行逆转，使原本应该前进的operator++变成了后退操作，使原本应该后退的operator--变成了前进操作。\n\n使用方法：\n\n```c++\nint main() {\n    vector<int> vec({9,8,7,6,5,4,3,2,1,0});\n    cout<<*(vec.rbegin())<<endl; // 0\n    cout<<*(vec.rend())<<endl; // 134270134（越界！）\n    vector<int>::reverse_iterator riter = vec.rbegin();\n    cout<<*(++riter)<<endl; // 1\n    cout<<*(riter+2)<<endl; // 3\n    cout<<riter[3]<<endl; // 4\n    cout<<*(--riter)<<endl; // 0\n}\n```\n\n![image-20221017151805973](https://cdn.moyusoldier.cn/image-20221017151805973.png)\n\n提供`rbegin()`和`rend()`方法的容器有vector、list、deque、set/multiset、map/multimap。\n\n例如：\n\n```c++\ntemplate <class T, class Alloc = alloc>\nclass vector {\npublic:\n  typedef T value_type;\n  typedef value_type* iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  //...  \n};\n\n\ntemplate <class T, class Alloc = alloc>\nclass list {\npublic:\n  typedef __list_iterator<T, T&, T*>             iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;   \n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  //...  \n};\n\ntemplate <class T, class Alloc = alloc, size_t BufSiz = 0> \nclass deque {\npublic:    \n  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;\n  typedef reverse_iterator<iterator> reverse_iterator;    \n  reverse_iterator rbegin() { return reverse_iterator(finish); }\n  reverse_iterator rend() { return reverse_iterator(start); }\n  //...\n};\n```\n\n源码：\n\n```c++\n// 这是一个iterator adaptor，用来将一个iterator前进方向进行逆转\n// 前进变后退，后退变前进\ntemplate <class Iterator>\nclass reverse_iterator \n{\nprotected:\n  Iterator current;\npublic:\n  // reverse_iterator的5种关联类型和iterator一样  \n  typedef typename iterator_traits<Iterator>::iterator_category\n          iterator_category;\n  typedef typename iterator_traits<Iterator>::value_type\n          value_type;\n  typedef typename iterator_traits<Iterator>::difference_type\n          difference_type;\n  typedef typename iterator_traits<Iterator>::pointer\n          pointer;\n  typedef typename iterator_traits<Iterator>::reference\n          reference;\n\n  typedef Iterator iterator_type;\n  typedef reverse_iterator<Iterator> self;\n\npublic:\n  reverse_iterator() {}\n  explicit reverse_iterator(iterator_type x) : current(x) {}\n\n  reverse_iterator(const self& x) : current(x.current) {}\n#ifdef __STL_MEMBER_TEMPLATES\n  template <class Iter>\n  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}\n#endif /* __STL_MEMBER_TEMPLATES */\n    \n  iterator_type base() const { return current; }\n  // 关键：对reverse_iterator取值，就是将对应的iterator后退一格后取值  \n  reference operator*() const {\n    Iterator tmp = current;\n    return *--tmp;\n  }\n\n  pointer operator->() const { return &(operator*()); }\n\n  // 返回左值  \n  self& operator++() {\n    --current;\n    return *this;\n  }\n  self operator++(int) {\n    self tmp = *this;\n    --current;\n    return tmp;\n  }\n  // 返回左值 \n  self& operator--() {\n    ++current;\n    return *this;\n  }\n  self operator--(int) {\n    self tmp = *this;\n    ++current;\n    return tmp;\n  }\n  self operator+(difference_type n) const {\n    return self(current - n);\n  }\n  // 返回左值 \n  self& operator+=(difference_type n) {\n    current -= n;\n    return *this;\n  }\n  self operator-(difference_type n) const {\n    return self(current + n);\n  }\n  // 返回左值   \n  self& operator-=(difference_type n) {\n    current += n;\n    return *this;\n  }\n  //   \n  reference operator[](difference_type n) const { return *(*this + n); }  \n}; \n```\n\n'),(52,'记一次vue网站首页加载慢的优化过程',95,'2022-12-07 14:46:20','结论：还是换个好点的服务器吧','记一次vue网站首页加载慢的优化过程\n\n# 1 背景\n\n众所周知（不知道也行），我的个人网站www.moyusoldier.cn半年前改用了阿里云薅羊毛薅来的老破小服务器，从此我就对它失去了兴趣，因为访问实在是太慢了，开个首页居然要等一分钟。\n\n![image-20221207214749919](https://cdn.moyusoldier.cn/image-20221207214749919.png)\n\n我把访问缓慢顺理成章地归因于服务器性能问题，就没再管它。直到最近开始思考人生，研究起心理学中的“归因论”和“因果论”，才幡然醒悟，开始研究起加载慢的原因和优化方法。\n\n点击F12，查看network，发现耗时最长的是chunk-vendors-xxx.js文件，有2.5M之多，而google一下发现别人几百K还嫌大呢。\n\n我将chunk-vendors-xxx.js简单理解为第三方库，首次访问网站时，需要浏览器从服务器下载。\n\n# 2 分析\n\n![image-20221207220558874](https://cdn.moyusoldier.cn/image-20221207220558874.png)\n\n打包命令后加上`--report`，在打包后的`dist`文件夹中就会生成`report.html`文件，一看便可知chunk-vendors-xxx.js都包含了什么。\n\nchunk-vendors-xxx.js中最大的几个第三方包为 hightlight.js、moment.js、element-plus、vue。就从它们下手\n\n# 3 优化方案\n\n## 3.1 不用第三方库\n\n弃用moment.js，直接在后端进行日期格式转换。\n\n## 3.2 引入CDN引入第三方库\n\n我的服务器带宽低，是小辣鸡，那就从别的地方去下载啊。\n\n引入CDN，使浏览器可以同时通过CDN下载多个第三方库，而且下载速度肯定比从我的服务器下载快，不需要从chunk-vendors-xxx.js获取第三方库，chunk-vendors-xxx.js的大小自然就降下来了。\n\n### 3.2.1 引入CDN\n\n![image-20221207221007137](https://cdn.moyusoldier.cn/image-20221207221007137.png)\n\n在index.html的head或者body标签中添加以下代码：\n\n```html\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n    <title><%= htmlWebpackPlugin.options.title %></title>\n    <!-- Import style -->\n    <link rel=\"stylesheet\" href=\"//unpkg.com/element-plus/dist/index.css\" />\n    <!-- Import Vue 3 -->\n    <script src=\"//unpkg.com/vue@3.2.33\"></script>\n    <!-- Import component library -->\n    <script src=\"//unpkg.com/element-plus@2.2.26\"></script>\n    <!-- Import highlight.js -->\n    <link rel=\"stylesheet\"\n          href=\"https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/default.min.css\">\n    <script src=\"https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js\"></script>\n</head>\n```\n\n不知道为啥，从bootcdn或者jsdelivr上直接查到的CDN都不好用，还是建议看每个组件库的官方文档找到正确的CDN使用方法。\n\n> jsdelivr可以查看某一个CDN的使用频率（Top 5 versions）、最佳实践星人狂喜\n\n### 3.2.2 告诉webpack不要打包这些第三方库\n\n![image-20221207221559035](https://cdn.moyusoldier.cn/image-20221207221559035.png)\n\n在vue.config.js中添加以下代码：\n\n```javascript\nmodule.exports = {\n    configureWebpack: {\n        externals: {\n            \'vue\': \'Vue\',\n            \'highlight.js\': \'hljs\',\n            \'element-plus\': \'ElementPlus\',\n        }\n    }\n```\n\n## 3.3 gzip压缩前端文件\n\n把css、js等大文件压缩成浏览器能解析的`.gz`格式，通过nginx分发给浏览器，这样文件小，传输时间短。\n\n### 3.3.1 使用compression-webpack-plugin压缩文件\n\n下载compression-webpack-plugin到`devDependencies`，注意下载的版本一定不能是最新，否则会报错\n\n```shell\nnpm install --save-dev compression-webpack-plugin@5.0.1\n```\n\n在vue.config.js中添加以下代码：\n\n```javascript\nmodule.exports = {\n    configureWebpack: {\n        plugins: [new CompressionPlugin()]\n}\n```\n\n打包后每个前端文件就能有对应的`.gz`版本啦。\n\n### 3.3.2 对nginx进行gzip配置\n\n参考https://cloud.tencent.com/document/product/214/5404，感觉这一步跟上一步没啥联系，或者说是二次压缩。\n\n# 4 结论\n\nchunk-vendors-xxx.js从2.5M降到了325KiB，压缩后103.02KiB，实际传输119kB。加上各种CDN同时下载，首页加载平均仅需10s！！！\n\n![image-20221207224429228](https://cdn.moyusoldier.cn/image-20221207224429228.png)\n\n（结论：还是换个好点的服务器吧）\n\n'),(53,'日志',79,'2023-01-14 15:11:25','来一起学一下日志系统吧~','# 1 日志规约\n\n引用自阿里巴巴Java开发者手册\n\n![image-20230114204706858](https://cdn.moyusoldier.cn/image-20230114204706858.png)\n\n![image-20230114204643199](https://cdn.moyusoldier.cn/image-20230114204643199.png)\n\n![image-20230114204732583](https://cdn.moyusoldier.cn/image-20230114204732583.png)\n\n# 2 slf4j\n\nhttps://www.slf4j.org/\n\nslf4j（日志框架）和logback、log4j（日志系统）的关系类似于接口和实现类。\n\n阿里强制使用slf4j中的API进行日志管理，不能直接使用log4j、logback中的API。\n\n![img](https://cdn.moyusoldier.cn/170130_10338.jpg)\n\nSpringboot自带了两种日志系统：logback、log4j2。想要使用哪种直接配置即可，不用再引入maven。\n\n![image-20230114210035639](https://cdn.moyusoldier.cn/image-20230114210035639.png)\n\n日志常用的五个级别，根据严重程度由低到高，依次为：debug(调试 ) < info(消息) < warn(警告) < error(错误) < fatal(严重错误)\n\n一般我只使用info和error。\n\n# 3 logback（全面拥抱）\n\n首页：https://logback.qos.ch/\n\n文档：https://logback.qos.ch/manual/index.html\n\n## 3.1 集成springboot\n\nlogback是springboot默认使用的日志系统。\n\n### 3.1.1 默认配置\n\n首先，`SpringBoot`会从`resource`包下查找`logback-test.xml`或`logback.xml` ，如果这两个都不存在，则会调用`BasicConfigurator`，创建一个最小化的基本配置。\n\n最小化配置由一个关联到根`logger`的`ConsoleAppender`组成，默认输出模式为`%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n`，`root logger`级别为`DEBUG`，所以并不会生成日志文件，只会输出到控制台。\n\n### 3.1.2 自定义配置\n\n1. 在application.yml中加入如下配置\n\n```xml\nlogging:\n  config: src/main/resources/logback.xml # 加上全路径是为了支持微服务，如果单体服务不用配这项\n```\n\n2. 在resources下添加logback.xml文件\n\n```xml\n<!-- Logback configuration. See http://logback.qos.ch/manual/index.html -->\n<configuration scan=\"true\" scanPeriod=\"2 seconds\">\n    <!--定义日志文件的存储地址-->\n    <property name=\"LOG_PATH\" value=\"./logs\" />\n    <!-- 控制台输出 -->\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            <!--格式化输出：%d表示日期，%-5level：级别从左显示5个字符宽度，%t表示线程名，%msg：日志消息，%n是换行符-->\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level ${PID:-} --- [%t] %logger{50} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    <!-- 日志文件输出 -->\n    <appender name=\"LOG_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <!-- 日志文件输出的文件名 -->\n        <File>${LOG_PATH}/moyublog.log</File>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <!-- 每日生成日志文件或日志文件大小超出限制后输出的文件名模板 -->\n            <fileNamePattern>${LOG_PATH}/moyublog.log.%d{yyyy-MM-dd}.%i</fileNamePattern>\n            <!-- 日志文件保留天数 -->\n            <maxHistory>60</maxHistory>\n            <!-- 日志文件最大大小：100MB -->\n            <maxFileSize>1MB</maxFileSize>\n        </rollingPolicy>\n        <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level ${PID:-} --- [%t] %logger{50} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    <!-- 默认日志输出级别 -->\n    <root level=\"INFO\">\n        <appender-ref ref=\"STDOUT\" />\n        <appender-ref ref=\"LOG_FILE\" />\n    </root>\n\n</configuration>\n```\n\n# 4 log4j\n\nhttps://logging.apache.org/log4j/2.x/\n\nlog4j2是log4j项目的继承者，log4j现一般指log4j2。\n\n\n\n```ascii\nlog.info(\"User signed in.\");\n │\n │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐\n ├──>│ Appender │───>│  Filter  │───>│  Layout  │───>│ Console  │\n │   └──────────┘    └──────────┘    └──────────┘    └──────────┘\n │\n │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐\n ├──>│ Appender │───>│  Filter  │───>│  Layout  │───>│   File   │\n │   └──────────┘    └──────────┘    └──────────┘    └──────────┘\n │\n │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐\n └──>│ Appender │───>│  Filter  │───>│  Layout  │───>│  Socket  │\n     └──────────┘    └──────────┘    └──────────┘    └──────────┘\n```\n\n当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：\n\n- console：输出到屏幕；\n- file：输出到文件；\n- socket：通过网络输出到远程计算机；\n- jdbc：输出到数据库\n\n在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出`ERROR`级别的日志。\n\n最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。\n\n上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。\n\n# 5 lombok与@slf4j注解\n\nlombok常用用法：https://projectlombok.org/features/\n\nlombok的@slf4j注解：https://projectlombok.org/api/lombok/extern/slf4j/Slf4j\n\n![image-20230114213510441](https://cdn.moyusoldier.cn/image-20230114213510441.png)\n\n也就是说，使用lombok的@slf4j注解帮我们少写了一行代码。');
/*!40000 ALTER TABLE `t_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comment`
--

DROP TABLE IF EXISTS `t_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_comment` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `parent_id` int(10) unsigned DEFAULT NULL,
  `parent_username` varchar(32) DEFAULT NULL,
  `root_id` int(10) unsigned DEFAULT NULL,
  `blog_id` int(10) unsigned NOT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `content` mediumtext NOT NULL,
  `user_id` int(10) unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comment`
--

LOCK TABLES `t_comment` WRITE;
/*!40000 ALTER TABLE `t_comment` DISABLE KEYS */;
INSERT INTO `t_comment` VALUES (1,NULL,NULL,NULL,53,'2023-01-23 08:44:53','一级评论-1',1),(2,NULL,NULL,NULL,53,'2023-01-23 08:45:25','一级评论-2',1),(3,1,'moyu',1,53,'2023-01-23 08:46:02','二级评论-1.1',2),(4,1,'moyu',1,53,'2023-01-23 08:46:33','二级评论-1.2',3),(5,3,'test_visitor',1,53,'2023-01-23 08:47:32','二级评论-1.1.1',1),(6,NULL,NULL,NULL,53,'2023-01-24 14:28:14','测试一级评论',1),(7,NULL,NULL,NULL,53,'2023-01-25 11:13:49','测试无头像用户一级评论',3),(8,NULL,NULL,NULL,53,'2023-01-25 11:13:49','测试无头像用户一级评论',3),(9,2,'moyu',2,53,'2023-01-25 12:44:02','二级评论-2.1',1),(10,NULL,NULL,NULL,53,'2023-01-25 16:24:42','测一条',1),(11,NULL,NULL,NULL,53,'2023-01-25 16:25:44','测一条啊啊啊啊啊11',1),(12,NULL,NULL,NULL,53,'2023-01-25 16:27:46','好了吗',1),(13,12,'moyu',12,53,'2023-01-25 16:27:56','已经好了',1),(14,12,'moyu',12,53,'2023-01-25 16:34:07','再试试',1),(15,14,'moyu',12,53,'2023-01-25 16:34:39','再再试试',1),(16,11,'moyu',11,53,'2023-01-25 16:34:51','啊啊啊啊啊啊啊啊222',1),(17,9,'moyu',2,53,'2023-01-25 16:35:46','怎个事？我看看',2),(18,2,'moyu',2,53,'2023-01-25 16:36:38','可以哈',2),(19,5,'moyu',1,53,'2023-01-25 16:36:55','看看好不好使',2),(20,4,'moyu1',1,53,'2023-01-25 16:37:27','挺好',2),(21,1,'moyu',1,53,'2023-01-25 16:38:04','点两次呢',2),(22,1,'moyu',1,53,'2023-01-25 16:41:10','点一次',2),(23,1,'moyu',1,53,'2023-01-25 16:41:25','点几次呢',2),(24,1,'moyu',1,53,'2023-01-25 16:41:32','好神奇',2),(25,NULL,NULL,NULL,54,'2023-01-25 16:42:27','来评论啦',2),(26,NULL,NULL,NULL,54,'2023-01-26 03:11:41','测试一级评论',1),(27,NULL,NULL,NULL,54,'2023-01-26 03:15:00','测试一级评论',1),(28,NULL,NULL,NULL,53,'2023-01-26 04:31:55','发评论啦',1),(29,NULL,NULL,NULL,53,'2023-01-26 04:32:01','再来',1),(30,NULL,NULL,NULL,54,'2023-01-26 04:32:12','瓶',1),(31,NULL,NULL,NULL,54,'2023-01-26 04:32:20','好评',1),(32,NULL,NULL,NULL,52,'2023-01-26 04:32:39','绝好评',1),(33,NULL,NULL,NULL,48,'2023-01-26 04:53:08','我来了',1),(34,NULL,NULL,NULL,48,'2023-01-26 04:53:15','来',1),(35,NULL,NULL,NULL,53,'2023-01-26 04:53:28','hello',1),(36,NULL,NULL,NULL,49,'2023-01-26 04:53:44','水军来了',1),(37,NULL,NULL,NULL,44,'2023-01-26 05:13:18','我来评论啦',1),(38,NULL,NULL,NULL,51,'2023-01-26 05:25:42','来了',1),(39,NULL,NULL,NULL,29,'2023-01-26 05:26:26','赞',1),(40,NULL,NULL,NULL,34,'2023-01-26 05:26:46','写的啥？',1),(41,NULL,NULL,NULL,36,'2023-01-26 05:27:33','入坑',1),(42,NULL,NULL,NULL,35,'2023-01-26 05:28:01','入坑',1);
/*!40000 ALTER TABLE `t_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_user` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `role` enum('admin','visitor') DEFAULT NULL,
  `avatar` varchar(128) DEFAULT NULL,
  `phone` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
INSERT INTO `t_user` VALUES (1,'moyu','4bdbb56340f32e27005d1feda6820caa6d31f8e6','admin','https://cdn.moyusoldier.cn/moyublog-moyu.jpg',NULL),(2,'test_visitor','c7fca8105e027bf63faf6a3f2c1eb47fd9e46f32','visitor','https://cdn.moyusoldier.cn/kotori.jpg',NULL),(3,'moyu1','8df19eb1ea1f9c79678ca79469220fee2be80fd8','visitor',NULL,NULL),(4,'moyu2','8df19eb1ea1f9c79678ca79469220fee2be80fd8','visitor',NULL,NULL),(5,'moyu4','6ba6179106173eeaef4ec4c5614c86efcacd1b0c','visitor',NULL,NULL),(6,'moyu5','b1ac239b1ff1cc2dd6d1aa47644db5e1a2f0ec3a','visitor',NULL,NULL),(7,'摸鱼777','12eed909b28f50ae6651c35022dcad37a709efea','visitor',NULL,NULL),(8,'摸777','12eed909b28f50ae6651c35022dcad37a709efea','visitor',NULL,NULL),(9,'摸77','12eed909b28f50ae6651c35022dcad37a709efea','visitor',NULL,NULL),(10,'moyu123','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(11,'moyu233','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(12,'moyu9090','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(13,'m00o0o0','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(14,'moyu77777','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(15,'moyuwnw','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(16,'moyuwnwp','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(17,'moyu1234','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(18,'yumo','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(19,'moyu333','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(20,'moyu444','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(21,'moyu234234','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL),(22,'moyu357','4bdbb56340f32e27005d1feda6820caa6d31f8e6','visitor',NULL,NULL);
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-01-26 23:46:10
