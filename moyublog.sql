-- MySQL dump 10.13  Distrib 8.0.21, for Win64 (x86_64)
--
-- Host: 82.157.174.176    Database: moyublog
-- ------------------------------------------------------
-- Server version	5.7.36

create database moyublog;
use moyublog;

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `t_blog`
--

DROP TABLE IF EXISTS `t_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `hits` int(10) unsigned DEFAULT '0',
  `date` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `description` text,
  `content` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog`
--

LOCK TABLES `t_blog` WRITE;
/*!40000 ALTER TABLE `t_blog` DISABLE KEYS */;
INSERT INTO `t_blog` VALUES (1,'01背包问题',4,'2021-12-16 12:27:36','这个01背包就是逊啦','## 题目\n题目在[acwing](https://www.acwing.com/problem/content/2/)\n![0-1-bei-bao-wen-ti-1](http://cdn.moyusoldier.cloud/0-1-bei-bao-wen-ti-1.png)\n\n## 讲解视频\n讲解在[bilibili](https://www.bilibili.com/video/BV1qt411Z7nE?t=1718)\n## 解法-二维DP\n\n\n![0-1-bei-bao-wen-ti-2](http://cdn.moyusoldier.cloud/0-1-bei-bao-wen-ti-2.png)\ndp[i][j]表示前i件物品，容量为j时的最大价值，即重叠子问题。\n\n状态转移方程：\n\n1.不放第i件物品，转化为\"前i-1件物品与容量为j\"的情况，这时候最大价值不会变化。\n\n2.放第i件物品，只有背包的体积比该物品体积大时，才考虑这种情况。这时候的最大价值应该为\"前i-1件物品，容量为j-v[i]\"的情况加上第i件物品的价值。\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1010;\nint n,m;\nint f[N][N];\nint v[N], w[N];\n\nint main(void)\n{\n   cin >> n >> m;\n   for (int i = 1;i <= n;i++)\n   {\n      cin >> v[i] >> w[i];\n   }\n   for (int i = 1;i <= n;i++)\n   {\n      for (int j = 0;j <= m;j++)\n      {\n         f[i][j] = f[i - 1][j];\n      //只有背包的体积比该物品体积大时，才考虑放入该物品的情况\n         if (j>=v[i])\n         {\n            f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);\n         }\n      }\n   }\n   int res = 0;\n   for (int i = 0;i <= m;i++)\n   {\n      res = max(res, f[n][i]);\n   }\n   cout << res << endl;\n   return 0;\n}\n```\n\n## 解法升级-一维DP\n为什么可以压缩空间?考虑到我们遍历二维数组的方式为逐行遍历，且下一行的数据之和上一行的有关，我们只保留一行的数据，然后依旧通过外层循环不断对这一行数据进行刷新。对应到数组上即删除数组的一维。\n\n根据之前的状态转移方程我们可以看出，要确定当前状态我们要已知它正上面的那个数据和左上方的某个数据，进而在刷新一行数据的时候，从后往前遍历不会导致每个位置的刷新读到错误数据（刚刚刷新的数据），而确保了每个位置的刷新读到的都是上一行的数据。\n\n所以，空间复杂度由O(NV)变为O(V)，即只与背包的体积有关。\n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1010;\nint n, m;\nint f[N];\nint v[N], w[N];\n\nint main(void)\n{\n   cin >> n >> m;\n   for (int i = 1;i <= n;i++)\n   {\n      cin >> v[i] >> w[i];\n   }\n   for (int i = 1;i <= n;i++)\n   {\n      for (int j = m;j >= v[i];j--)\n      {\n         f[j] = max(f[j], f[j - v[i]] + w[i]);\n      }\n   }\n   cout << f[m] << endl;\n   return 0;\n}\n```\n\n\n\n## 写在后面\n01背包问题是一个NP完全问题，也就是说，如果你发现了该问题的一个多项式算法，那么恭喜你证明出了 P=NP，可以期待一下图灵奖了。\n\n正因如此，我们不应期望该问题有多项式时间复杂度的解法,而必须尝试非多项式时间复杂度的算法，例如时间复杂度与元素大小相关的动态规划。\n\n考虑上述动态规划算法的时间复杂度，根据二维数组有N*V个状态，其中N为物品的数量，V为背包的体积，状态之间转移时间复杂度O(1)，故可以得出该算法的时间复杂度为O(NV)。至于问什么说这不是多项式时间，为了分析方便，我们把时间复杂度写作O(nC)，其中C表示背包的体积，这下就可看出来时间复杂度不是输入数据规模的多项式函数，因为当输入数据大小相同时，只需改变C的值就可以改变时间复杂度。'),(12,'从yolo开始的目标检测入门',1,'2021-12-14 14:03:03','肆式青春中一次拉跨的yolo尝试','## 目标检测的两大流派\n\n- two-stage：以R-CNN系为代表，R-CNN，Fast R-CNN，Faster R-CNN， 准确率更高。\n\n  - stage1:生成候选区域RP\n  - stage2:对RP进行检测，分类和边框调整\n\n- one-stage：以Yolo系，SSD系为代表，速度更快。\n\n  - 没有stage1，对整张图进行检测\n  \n  ![img](http://cdn.moyusoldier.cloud/yolo-00.png)\n  \n  【注】two-stage 准确率更高，one-stage速度更快仅较大体而言，采用不同的特征提取模型（backbone）、输入分辨率，特征图尺寸，候选框的个数(锚框的个数)等对模型精度和速度均有影响。\n\n![img](http://cdn.moyusoldier.cloud/yolo-01.jpg)\n\n## Yolov1初探\n\n### 1.预测阶段\n\n​	假定模型已经训练完成，现在只考虑网络的前向传播过程，输入一张彩色图片，怎样才能得到目标检测的结果呢？\n\n![yolo-03](http://cdn.moyusoldier.cloud/yolo-03.png)\n\n\n\n​	首先将输入的彩色图片resizec成448x448x3的张量用于输入，在经历一系列操作（视作黑箱）之后，生成7x7x30的张量，这个张量包含了所有预测框的坐标，置信度和类别结果。只需解析此张量即可得到最终目标检测的结果。\n\n​	![yolo-04](http://cdn.moyusoldier.cloud/yolo-04.png)\n\n7x7x30的张量该如何解析呢？\n\n​	【左图】将图片划分为SxS(S=7)维的grid cell，每个grid cell 生成B(B=2)个bounding box，每个bounding box的中心点落在该grid cell内，总计生成了7x7x2=98个bounding box，每个bounding box都包含4个位置参数和1个置信度参数。\n\n\n\n​	![yolo-05](http://cdn.moyusoldier.cloud/yolo-05.png)\n\n​	【上图】将所有的bounding box都可视化的结果就是上图，黑框边框的粗细程度表示置信度的大小。\n\n​	【下图】每个grid cell 还可以生成20个类别（PASCAL VOC 数据集的20个类别）的条件概率，即在该bounding box包含物体的情况下，物体是某一个类别的概率，每个grid cell 生成的两个bounding box共享这一份概率。\n\n​	一个bounding box预测得到物体的全概率=该bounding box包含物体的概率（置信度） x 物体是某一类别的条件概率。![yolo-07](http://cdn.moyusoldier.cloud/yolo-07.png)\n\n​	将每个grid cell概率最大的类别可视化的结果就是下图。\n\n​	【右图】结合上图与右图，将bounding box进行筛选即可得到最后的结果。\n\n![yolo-06](http://cdn.moyusoldier.cloud/yolo-06.png)\n\n​	\n\n​	7x7x30的张量可视化结果如上图，将这个张量看作有7x7个门的抽屉，每一个抽屉门代表一个grid cell，将抽屉门拉开，可以看到该grid cell包含的30个信息，前五个信息代表第一个bounding box的五元组，挨着的是第二个bounding box的五元组，最后是20个类别的条件概率。\n\n​	\n\n### 2.预测阶段后处理\n\n​	将生成的7x7x2=98个bounding box筛选，把低置信度的bounding box过滤，重复的bounding box只保留一个，最终获得目标检测的结果。\n\n​	![yolo-08](http://cdn.moyusoldier.cloud/yolo-08.png)\n\n​	对于7x7x2=98个bounding box对应的全概率按如下步骤进行操作（以第一个类别为例）\n\n 1. 设置阈值，将低于阈值的概率归零\n\n 2. 从大到小排序\n\n 3. NMS-非极大值抑制\n\n    ![yolo-09](http://cdn.moyusoldier.cloud/yolo-09.png)\n\n\n\n​		首先以第一个为基准，比较第一个与第二个bounding box对应狗的概率，如果IOU大于某个阈值，认为这两个bounding box识别的是同一个物体，属于重复识别，将低概率的bounding box去掉，即将第二个概率归零。依次比较第一个到最后一个。\n\n​		在以下一个不为0的为基准，重复上述过程，得到如下图结果。\n\n![yolo-10](http://cdn.moyusoldier.cloud/yolo-10.png)\n\n​		对20个类别进行20次非极大值抑制，选出不全为零的bounding box，将其对应的类别与概率标注出来，即得到最终结果。\n\n### 3.训练阶段'),(13,'Java多线程',5,'2021-12-15 22:18:43','《找个好班上》系列笔记开山之作','# 1.线程简介\n\n## 1.1进程与线程区别？\n\n定义：进程是资源分配的基本单位，线程是独立调度的基本单位。\n\n包含关系：一个进程中可以有多个线程，它们共享进程资源。\n\n区别：\n\nⅠ 拥有资源\n\n进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。\n\nⅡ 调度\n\n线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n\nⅢ 系统开销\n\n由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。\n\nⅣ 通信方面\n\n线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC（进程间通信机制）。\n\n## 1.2理解多线程\n\n![img](http://cdn.moyusoldier.cloud/duoxiancheng-01.png)\n\n- 线程就是独立的执行路径\n- 在程序运行时，即使没有自己创建线程，后台也会有多个线程，比如主线程，GC线程\n- main()称之为主线程，为系统的入口，用于执行整个程序\n- 在一个进程中，如果开辟了多个线程，线程的运行是由调度器（cpu）安排调度的，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的\n- 对同一份资源操作时会存在资源抢夺的问题，需要加入并发控制\n- 线程会带来额外的开销，如CPU调度时间，并发控制开销\n- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致\n  \n\n\n\n# 2.线程实现\n\n## 2.1常用的使用线程的方法\n\n- 继承Thread类\n- 实现Runnable接口\n- 使用线程池例如Executor框架\n  - newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则创建线程。\n  - newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n  - newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n  - newSingleThreadPool 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。\n\n```Java\nclass MyThread1 extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"MyThread1\");\n    }\n}\n\nclass MyThread2 implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"MyThread2\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        //start()方法->就绪状态\n        //run()方法->运行状态\n        MyThread1 myThread1 = new MyThread1();\n        myThread1.start();\n        MyThread2 myThread2 = new MyThread2();\n        new Thread(myThread2).start();\n    }\n}\n```\n\n```shell\nMyThread1\nMyThread2\n```\n\n```java\nclass MyThread2 implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"正在执行\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        //创建一个可重用固定线程数的线程池\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        //创建线程\n        MyThread2 myThread2 = new MyThread2();\n        Thread t1 = new Thread(myThread2);\n        Thread t2 = new Thread(myThread2);\n        Thread t3 = new Thread(myThread2);\n        Thread t4 = new Thread(myThread2);\n        Thread t5 = new Thread(myThread2);\n        //将线程放入池中执行\n        pool.execute(t1);\n        pool.execute(t2);\n        pool.execute(t3);\n        pool.execute(t4);\n        pool.execute(t5);\n        //关闭线程池\n        pool.shutdown();\n    }\n}\n```\n\n```java\npool-1-thread-2正在执行\npool-1-thread-1正在执行\npool-1-thread-2正在执行\npool-1-thread-1正在执行\npool-1-thread-2正在执行\n```\n\n> 扩展：Lambda表达式\n\n目的：为了让代码变得简洁\n\n演化：\n\n - 类： 有些类只用了一次\n - 静态内部类：把一个类定义在另一个类内部，进一步简化\n - 局部内部类：把一个类定义在方法内部，进一步简化\n - 匿名内部类：没有类的名称，借助接口或者父类实现，进一步简化\n - Lambda表达式： 没有接口名，没有方法名，简化到家了\n\n使用场景：函数式接口（任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口，如Runnable）\n\n```Java	\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n使用Lambda表达式创建线程\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        new Thread(()->{\n            System.out.println(Thread.currentThread().getName()+\"正在执行\");\n        }).start();\n    }\n}\n```\n\n```shell\nThread-0正在执行\n```\n\n\n\n## 2.2\"继承 Thread类\"VS\"实现Runnable接口\"\n\n### 2.2.1最佳实践：实现Runnable接口\n\n- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\n- 类可能只要求可执行就行，继承整个 Thread 类开销过大。\n\n### 2.2.2内在联系：静态代理模式\n\n对比JDK实现\n\n```Java\n//抽象接口\npublic interface Runnable {\n    public abstract void run();\n}\n//代理角色\nclass Thread implements Runnable {\n    private Runnable target;\n    public Thread() {\n        init(null, null, \"Thread-\" + nextThreadNum(), 0);\n    }\n    public Thread(Runnable target) {\n        init(null, target, \"Thread-\" + nextThreadNum(), 0);\n    }\n    public synchronized void start() {\n        //...\n    }\n    @Override\n    public void run() {\n        if (target != null) {\n            target.run();\n        }\n    }\n    //...\n}\n```\n\n# 3.线程状态\n\n## 3.1操作系统层面：5种\n\n![duoxiancheng-04](http://cdn.moyusoldier.cloud/duoxiancheng-04.png)\n\n## 3.2Java线程层面：6种\n\n- NEW - 创建\n- RUNNABLE - 就绪/执行\n- BLOCKED - 阻塞\n- WAITING - 阻塞\n- TIMED_WAITING - 阻塞\n- TERMINATED - 终止\n\n![duoxiancheng-03](http://cdn.moyusoldier.cloud/duoxiancheng-03.png)\n\n## 3.3Thread类方法\n\n- ### 线程停止\n\n  - 不推荐使用JDK提供的stop()、destroy()方法\n  - 推荐设置标志位让线程自己停下来\n  \n  ```Java\n  class MyThread2 implements Runnable {\n      private boolean flag = true;\n      @Override\n      public void run() {\n          while(flag){\n           //...   \n          }\n      }\n      public void stop(){\n          this.flag = false;\n      }\n  }\n  ```\n  \n- ### 线程休眠 sleep()\n\n  - Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。\n\n  - sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n  - 用于模拟网络延迟，放大问题的发生性\n\n  ```Java\n  public void run() {\n      try {\n          Thread.sleep(3000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n  }\n  ```\n  \n- ### 线程礼让 yield()\n\n  - 让当前正在执行的线程暂停，但不阻塞\n\n  - 将线程从运行状态转为就绪状态\n\n  - 让CPU重新调度，礼让不一定成功，看CPU心情\n  \n  ```java\n  public void run() {\n      Thread.yield();\n  }\n  ```\n  \n- ### 线程插队 join()\n\n  - 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\n  - 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。\n\n  ```java\n  public class JoinExample {\n  \n      private class A extends Thread {\n          @Override\n          public void run() {\n              System.out.println(\"A\");\n          }\n      }\n  \n      private class B extends Thread {\n  \n          private A a;\n  \n          B(A a) {\n              this.a = a;\n          }\n  \n          @Override\n          public void run() {\n              try {\n                  a.join();\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              System.out.println(\"B\");\n          }\n      }\n  \n      public void test() {\n          A a = new A();\n          B b = new B(a);\n          b.start();\n          a.start();\n      }\n  }\n  ```\n\n  \n\n  \n\n  ```java\n  public static void main(String[] args) {\n    JoinExample example = new JoinExample();\n    example.test();\n  }\n  ```\n\n  \n\n  \n\n  ```shell\n  A\n  B\n  ```\n\n- ### 线程状态观测 getState()\n\n  ```java\n  Thread.State state = thread.getState();\n  ```\n\n- ### 线程优先级 getPriority()，setPriority(int)\n\n  - 范围从1~10，数字越大，优先级越高\n  - 优先级低只是意味着获得调度的概率低，并不是不会被调度，取决于CPU\n  - Thread.MIN_PRIORITY = 1;\n  - Thread.MAX_PRIORITY = 10;\n  - Thread.NORM_PRIORITY = 5;\n\n  \n  ```Java\n  //先设置优先级，再启动\n  thread.setPriority(1);\n  thread.start();\n  ```\n  \n- ### 守护线程 setDaemon(boolean)\n\n  - 线程分为用户线程和守护线程\n  - JVM必须确保用户线程执行完毕\n  - JVM不用等待守护线程执行完毕（如垃圾回收线程）\n\n  ```Java\n  //默认false表示是用户线程,正常的线程都是用户线程\n  thread.setDaemon(true);\n  ```\n\n  \n\n# 4.线程同步\n\n## 4.1并发与并行\n\n并发：一个处理器按时间片轮转算法处理多个任务\n\n并行：单位时间多个处理器同时处理多个任务\n\n并发问题的起因：同一个对象被多个线程同时操作\n\n## 4.2线程不安全的例子\n\n- 买火车票\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        BuyTickets buyTickets = new BuyTickets();\n        new Thread(buyTickets, \"a\").start();\n        new Thread(buyTickets, \"b\").start();\n        new Thread(buyTickets, \"c\").start();\n    }\n}\n\nclass BuyTickets implements Runnable {\n    //票\n    private int num = 10;\n\n    @Override\n    public void run() {\n        while (true) {\n            if (num <= 0) {\n                break;\n            }\n            //模拟网络延迟，放大问题的发生性\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"抢到了第\" + num-- + \"张票\");\n        }\n    }\n}\n```\n\n```shell\na抢到了第10张票\nb抢到了第8张票\nc抢到了第9张票\na抢到了第7张票\nb抢到了第6张票\nc抢到了第6张票\na抢到了第5张票\nc抢到了第4张票\nb抢到了第3张票\na抢到了第2张票\nb抢到了第1张票\nc抢到了第1张票\na抢到了第0张票\n```\n\n- 线程不安全的集合\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<String>();\n        for (int i = 0; i < 1000; i++) {\n            new Thread(()->{\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n        //延迟，保证所有线程跑完\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n```shell\n995\n```\n\n## 4.3互斥同步\n\nJava 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的ReentrantLock。\n\n### 4.3.1 Synchronized用法（结合八锁现象理解）\n\n- Synchronized修饰实例方法\n  - 作用范围是整个方法，锁的是方法的调用者，是一个资源类的对象实例this（可以有多个）\n  - 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步\n\n```java\npublic synchronized void func () {\n    // ...\n}\n```\n\n- Synchronized修饰代码块\n\n  - 作用范围是大括号括起来的代码块，锁的是方法的调用者，是一个资源类的对象实例this\n  - 被修饰的代码块称为同步语句块\n\n  - 和修饰实例方法一样，都作用于同一个对象\n\n```Java\npublic void func() {\n    synchronized (this) {\n        // ...\n    }\n}\n```\n\n- Synchronized修饰静态方法\n\n  - 作用范围是整个方法，锁的是这个资源类的Class类模板\n\n  - 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步\n\n```java\npublic synchronized static void fun() {\n    // ...\n}\n```\n\n- Synchronized修饰类\n  - 作用范围是大括号括起来的代码块，锁的是这个资源类的Class类模板（只有唯一一个）\n\n```java\npublic void func() {\n    synchronized (SynchronizedExample.class) {\n        // ...\n    }\n}\n```\n\n### 4.3.2理解Synchronized\n\n- 加锁this，创建一个实例\n\n对于以下代码，创建线程池，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。\n\n```java\npublic class SynchronizedExample {\n\n    public void func1() {\n        synchronized (this) {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n}\n```\n\n```Java\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func1());\n    executorService.execute(() -> e1.func1());\n}\n```\n\n```shell\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n```\n\n- 加锁this，创建多个实例\n\n对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。\n\n```java\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    SynchronizedExample e2 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func1());\n    executorService.execute(() -> e2.func1());\n}\n```\n\n```shell\n0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9\n```\n\n- 加锁class，创建多个实例\n\n```java\npublic class SynchronizedExample {\n\n    public void func2() {\n        synchronized (SynchronizedExample.class) {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n}\n```\n\n```java\npublic static void main(String[] args) {\n    SynchronizedExample e1 = new SynchronizedExample();\n    SynchronizedExample e2 = new SynchronizedExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> e1.func2());\n    executorService.execute(() -> e2.func2());\n}\n```\n\n```shell\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n```\n\n### 4.3.3ReentrantLock\n\nReentrantLock 是 java.util.concurrent（J.U.C）包中的锁\n\n```java\npublic class LockExample {\n\n    private Lock lock = new ReentrantLock();\n\n    public void func() {\n        lock.lock();\n        try {\n            for (int i = 0; i < 10; i++) {\n                System.out.print(i + \" \");\n            }\n        } finally {\n            lock.unlock(); // 确保释放锁，从而避免发生死锁。\n        }\n    }\n}\n```\n\n```Java\npublic static void main(String[] args) {\n    LockExample lockExample = new LockExample();\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    executorService.execute(() -> lockExample.func());\n    executorService.execute(() -> lockExample.func());\n}\n```\n\n```shell\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\n```\n\n### 4.3.4Synchronized VS ReentrantLock\n\n**1. 锁的实现**\n\nsynchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n\n**2. 性能**\n\n新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。\n\n**3. 等待可中断**\n\n当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。\n\nReentrantLock 可中断，而 synchronized 不行。\n\n**4. 公平锁**\n\n公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。\n\nsynchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。\n\n**5. 锁绑定多个条件**\n\n一个 ReentrantLock 可以同时绑定多个 Condition 对象。\n\n**使用选择**\n\n除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n\n## 4.4 修改线程不安全的例子\n\n- 修改 买火车票\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        BuyTickets buyTickets = new BuyTickets();\n        new Thread(buyTickets, \"a\").start();\n        new Thread(buyTickets, \"b\").start();\n        new Thread(buyTickets, \"c\").start();\n    }\n}\n\nclass BuyTickets implements Runnable {\n    //票\n    private int num = 10;\n\n    @Override\n    public synchronized void run() {\n        while (true) {\n            if (num <= 0) {\n                break;\n            }\n            //模拟网络延迟，放大问题的发生性\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"抢到了第\" + num-- + \"张票\");\n        }\n    }\n}\n```\n\n- 修改 线程不安全集合\n\n```java\n//测试JUC安全类型的集合\npublic class Test {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>();\n        for (int i = 0; i < 10000; i++) {\n            new Thread(() -> {\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n# 5.线程通信 \n\n## 5.1三个线程打印ABC问题\n\n- Synchronized版本\n\n```java\npublic class WaitNotifyABC {\n    private int num;\n    private static final Object LOCK = new Object();\n\n    private void printABC(String name, int targetNum) {\n        for (int i = 0; i < 20; i++) {\n            synchronized (LOCK) {\n                while (num % 3 != targetNum) {\n                    try {\n                        LOCK.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                num++;\n                System.out.println(name);\n                LOCK.notifyAll();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        WaitNotifyABC waitNotifyABC = new WaitNotifyABC();\n        new Thread(() -> waitNotifyABC.printABC(\"A\", 0)).start();\n        new Thread(() -> waitNotifyABC.printABC(\"B\", 1)).start();\n        new Thread(() -> waitNotifyABC.printABC(\"C\", 2)).start();\n    }\n}\n```\n\n- Lock版本\n\n```java\npublic class WaitNotifyABC {\n    private int num;\n    private Lock lock = new ReentrantLock();\n\n    private void printABC(String name, int targetNum) {\n        for (int i = 0; i < 20;) {\n            lock.lock();\n                if (num % 3 == targetNum) {\n                    num++;\n                    i++;\n                    System.out.println(name);\n                }\n                lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        WaitNotifyABC waitNotifyABC = new WaitNotifyABC();\n        new Thread(() -> waitNotifyABC.printABC(\"A\", 0)).start();\n        new Thread(() -> waitNotifyABC.printABC(\"B\", 1)).start();\n        new Thread(() -> waitNotifyABC.printABC(\"C\", 2)).start();\n    }\n}\n```\n\n\n\n# 6.volatile\n\n## 6.1 JMM\n\n![duoxiancheng-05](http://cdn.moyusoldier.cloud/duoxiancheng-05.png)\n\n线程对共享变量的操作只能在本地内存区进行，不能直接在主内存区中操作共享变量。\n\n## 6.2 volatile特性\n\n轻量级 synchronized\n\n> 并发三大特性为可见性、有序性、原子性。volatile保证可见性和有序性，不保证原子性\n\n- 保证可见性：volatile可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值。\n\n```java\npublic class Demo01 {\n\n    // 如果不加volatile 程序会死循环\n    // 加了volatile是可以保证可见性的\n    private volatile static Integer number = 0;\n\n    public static void main(String[] args) {\n        \n        //子线程\n        new Thread(()->{\n            while (number==0){//若不加volatile，循环不会退出\n            }\n        }).start();\n        \n        //延时，保证子线程启动\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        \n        //main线程修改number的值\n        number=1;\n        System.out.println(number);\n    }\n}\n```\n\n- 保证有序性：volatile会通过禁止指令重排来保证有序性\n\n  - 指令重排：你写的程序，计算机并不是按照你写的那样去执行的，源代码->编译器优化重拍->指令并行重排->内存系统重排->执行\n\n  - 原理：内存屏障，CPU执行过程中，在volatile语句前后加屏障，在单例模式里使用的最多\n\n- 不保证原子性：对于单个volatile修饰的变量可以保证原子性，但对于i++这种符合操作不能保证原子性\n\n```java\npublic class Demo02 {\n\n    private static volatile int number = 0;\n\n    public static void add(){\n        number++; \n        //++ 不是一个原子性操作，是两个~3个操作\n    }\n\n    public static void main(String[] args) {\n        //理论上number  === 20000\n\n        for (int i = 1; i <= 20; i++) {\n            new Thread(()->{\n                for (int j = 1; j <= 1000 ; j++) {\n                    add();\n                }\n            }).start();\n        }\n\n        while (Thread.activeCount()>2){\n            //main  gc\n            Thread.yield();\n        }\n        System.out.println(Thread.currentThread().getName()+\",num=\"+number);\n    }\n}\n```\n\n```shell\nmain,num=19973\n```\n\n反编译，通过字节码查看number++这行语句的执行过程\n\n```shell\n> javap -c Demo02\n```\n\n```java\n  public static void add();\n    Code:\n       0: getstatic     #2                  // Field number:I\n       3: iconst_1\n       4: iadd\n       5: putstatic     #2                  // Field number:I\n       8: return\n```\n\n如果不加lock和synchronized ，怎么样保证原子性？\n\n——使用原子类\n\n```java\npublic class Demo02 {\n\n    private static volatile AtomicInteger number = new AtomicInteger();\n\n    public static void add(){\n        number.getAndIncrement();\n        //++ 不是一个原子性操作，是两个~3个操作\n    }\n\n    public static void main(String[] args) {\n        //理论上number  === 20000\n\n        for (int i = 1; i <= 20; i++) {\n            new Thread(()->{\n                for (int j = 1; j <= 1000 ; j++) {\n                    add();\n                }\n            }).start();\n        }\n\n        while (Thread.activeCount()>2){\n            //main  gc\n            Thread.yield();\n        }\n        System.out.println(Thread.currentThread().getName()+\",num=\"+number);\n    }\n}\n```\n\n```shell\nmain,num=20000\n```'),(14,'小记代理模式',2,'2021-12-14 14:03:10','啊 可能我未来几年都不会接触到AOP了，记录一下','## 1. 静态代理模式\n\n### 1.1介绍\n\n![](http://cdn.moyusoldier.cloud/duoxiancheng-02.png)\n\n四个角色：\n\n- 抽象角色：一般使用接口/抽象类\n- 真实角色：被代理的角色\n- 代理角色：代理真实角色，并做出附属动作\n- 客户：使用代理角色进行操作\n\n### 1.2例子\n\n```Java\n/**\n * 静态代理:结婚案例\n */\npublic class StaticProxy {\n    public static void main(String[] args) {\n        new WeddingCompany(new You()).happyMarry();\n    }\n}\n\n//AbstractSubject抽象接口:结婚\ninterface Marry {\n    void happyMarry();\n}\n\n//RealSubject真实角色:你去结婚\nclass You implements Marry {\n    @Override\n    public void happyMarry() {\n        System.out.println(\"要结婚了,超开心\");\n    }\n}\n\n//Proxy代理角色:婚庆公司帮你结婚\nclass WeddingCompany implements Marry {\n    private Marry target;//代理-->真实角色,帮谁结婚\n\n    public WeddingCompany(Marry target) {\n        this.target = target;\n    }\n\n    @Override\n    public void happyMarry() {\n        before();\n        this.target.happyMarry();\n        after();\n    }\n\n    private void after() {\n        System.out.println(\"log-after\");\n    }\n\n    private void before() {\n        System.out.println(\"log-before\");\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\n```\n\n好老铁也要结婚，如何编写？\n\n```java\nclass He implements Marry {\n    @Override\n    public void happyMarry() {\n        System.out.println(\"好老铁要结婚啦，超开心\");\n    }\n}\n```\n\n\n\n```jade\npublic class StaticProxy {\n    public static void main(String[] args) {\n        new WeddingCompany(new You()).happyMarry();\n        new WeddingCompany(new He()).happyMarry();\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\nlog-before\n好老铁要结婚啦，超开心\nlog-after\n```\n\n一个接口的代理类只需编写一次，实现了该接口的真实对象都可以使用。\n\n小姐妹要租房，如何编写？\n\n```java\ninterface Rent {\n    void happyRent();\n}\n```\n\n\n\n```java\nclass She implements Rent {\n    @Override\n    public void happyRent() {\n        System.out.println(\"要租房啦\");\n    }\n}\n```\n\n\n\n```java\nclass RentCompany implements Rent {\n    private Rent target;\n\n    public RentCompany(Rent target) {\n        this.target = target;\n    }\n\n    @Override\n    public void happyRent() {\n        before();\n        this.target.happyRent();\n        after();\n    }\n\n    private void after() {\n        System.out.println(\"log-after\");\n    }\n\n    private void before() {\n        System.out.println(\"log-before\");\n    }\n}\n```\n\n\n\n```java\npublic class StaticProxy {\n    public static void main(String[] args) {\n        new WeddingCompany(new You()).happyMarry();\n        new WeddingCompany(new He()).happyMarry();\n        new RentCompany(new She()).happyRent();\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\nlog-before\n好老铁要结婚啦，超开心\nlog-after\nlog-before\n要租房啦\nlog-after\n```\n\n需再为租房接口编写一个代理类（麻烦，动态代理改进）\n\n### 1.3优缺点\n\n**优点:**\n\n- 使得我们的真实角色更加纯粹 ，不再去关注一些公共的事情 \n- 公共的业务由代理来完成 ， 实现了业务的分工 \n- 公共业务发生扩展时变得更加集中和方便 \n\n**缺点 :**\n\n- 需要为每个被代理的接口都编写一个代理类 , 工作量变大\n\n我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !\n\n## 2.反射\n\n### 2.1 初始化对象\n\n```java\npackage com.moyu;\n\npublic class Person {\n    private Integer id;\n    private String name;\n\n    public Person() {\n        System.out.println(\"执行无参构造方法\");\n    }\n\n    public Person(Integer id, String name) {\n        this.id = id;\n        this.name = name;\n        System.out.println(\"执行有参构造方法\");\n    }\n\n    public void say(String s){\n        System.out.println(s);\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"id=\" + id +\n                \", name=\'\" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n```\n\n无参构造\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        Class<?> aClass = Class.forName(\"com.moyu.Person\");\n        Person person = (Person) aClass.newInstance();\n        \n        System.out.println(person);\n    }\n}\n```\n\n\n\n```shell\n执行无参构造方法\nPerson{id=null, name=\'null\'}\n```\n\n有参构造\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n        Class<?> aClass = Class.forName(\"com.moyu.Person\");\n        Constructor<?> constructor = aClass.getConstructor(Integer.class, String.class);\n        Person person = (Person) constructor.newInstance(1, \"moyu\");\n        \n        System.out.println(person);\n    }\n}\n```\n\n\n\n```shell\n执行有参构造方法\nPerson{id=1, name=\'moyu\'}\n```\n\n### 2.2 给属性赋值\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        Class<?> aClass = Class.forName(\"com.moyu.Person\");\n        Person person = (Person) aClass.newInstance();\n        \n        Field id = aClass.getDeclaredField(\"id\");\n        id.setAccessible(true);\n        id.set(person,1);\n        \n        Field name = aClass.getDeclaredField(\"name\");\n        name.setAccessible(true);\n        name.set(person,\"moyu\");\n        \n        System.out.println(person);\n    }\n}\n```\n\n\n\n```shell\n执行无参构造方法\nPerson{id=1, name=\'moyu\'}\n```\n\n### 2.3 调用方法\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        Class<?> aClass = Class.forName(\"com.moyu.Person\");\n        Person person = (Person) aClass.newInstance();\n        Method say = aClass.getDeclaredMethod(\"say\", String.class);\n        say.invoke(person, \"你好\");\n    }\n}\n```\n\n\n\n```shell\n执行无参构造方法\n你好\n```\n\n## 3. 动态代理\n\n### 3.1 介绍\n\n- 动态代理的代理类是自动生成的（只写一次），静态代理的代理类是我们提前编写好的（每个接口都要写一次）\n\n- 动态代理分两类：\n\n  - 基于接口的动态代理 - JDK动态代理\n  - 基于类的动态代理 - CGLIB\n\n  常用Javassist生成动态代理\n\n### 3.2 例子（以JDK动态代理为例）\n\n```java\n//抽象接口\ninterface Marry {\n    void happyMarry();\n}\n```\n\n\n\n```java\n//真实角色\nclass You implements Marry {\n    @Override\n    public void happyMarry() {\n        System.out.println(\"要结婚了,超开心\");\n    }\n}\n```\n\n\n\n```java\n//代理角色\npublic class DynamicProxy implements InvocationHandler {\n\n    private Object object;\n\n    public DynamicProxy(Object object) {\n        this.object = object;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        before();\n        Object result = method.invoke(object, args);\n        after();\n        return result;\n    }\n\n    private void after() {\n        System.out.println(\"log-after\");\n    }\n\n    private void before() {\n        System.out.println(\"log-before\");\n    }\n}\n```\n\n\n\n```java\n//客户\npublic class Client {\n    public static void main(String[] args) {\n        //真实角色\n        You you = new You();\n\n        //代理角色\n        Marry marry = (Marry) Proxy.newProxyInstance(\n            you.getClass().getClassLoader(),\n            you.getClass().getInterfaces(),\n            new DynamicProxy(you));\n\n        marry.happyMarry();\n\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\n```\n\n好老铁也要结婚，如何编写？（这部分看不出动态代理的优点，因为是同一个接口）\n\n```java\npublic class He implements Marry{\n    @Override\n    public void happyMarry() {\n        System.out.println(\"好老铁要结婚啦，超开心\");\n    }\n}\n```\n\n\n\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //真实角色\n        You you = new You();\n        He he = new He();\n\n        //代理角色\n        Marry marry = (Marry) Proxy.newProxyInstance(you.getClass().getClassLoader(),you.getClass().getInterfaces(),new DynamicProxy(you));\n        Marry marry1 = (Marry) Proxy.newProxyInstance(he.getClass().getClassLoader(),he.getClass().getInterfaces(),new DynamicProxy(he));\n\n        marry.happyMarry();\n        marry1.happyMarry();\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\nlog-before\n好老铁要结婚啦，超开心\nlog-after\n```\n\n小姐妹要租房，如何编写？（不同的接口，体现动态代理优点，自动生成代理类）\n\n```java\npublic interface Rent {\n    void happyRent();\n}\n```\n\n\n\n```java\npublic class She implements Rent{\n    @Override\n    public void happyRent() {\n        System.out.println(\"要租房啦\");\n    }\n}\n```\n\n\n\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //真实角色\n        You you = new You();\n        He he = new He();\n        She she = new She();\n\n        //代理角色\n        Marry marry = (Marry) Proxy.newProxyInstance(you.getClass().getClassLoader(), you.getClass().getInterfaces(), new DynamicProxy(you));\n        Marry marry1 = (Marry) Proxy.newProxyInstance(he.getClass().getClassLoader(), he.getClass().getInterfaces(), new DynamicProxy(he));\n        Rent rent = (Rent) Proxy.newProxyInstance(she.getClass().getClassLoader(), she.getClass().getInterfaces(), new DynamicProxy(she));\n\n        marry.happyMarry();\n        marry1.happyMarry();\n        rent.happyRent();\n    }\n}\n```\n\n\n\n```shell\nlog-before\n要结婚了,超开心\nlog-after\nlog-before\n好老铁要结婚啦，超开心\nlog-after\nlog-before\n要租房啦\nlog-after\n```\n\n### 3.3 优点\n\n- 动态代理的代理类可以复用，只需编写一次，省去了重复编写代理类的麻烦\n- 不用再关心代理的对象是谁，只需要实现一套逻辑即可\n\n## 4. Spring AOP\n\n### 4.1 介绍\n\n - 全称：Aspect Oriented Program 面向切面编程。\n\n - 目的：将不同业务逻辑中共有的部分（日志管理、事务管理）封装起来，降低业务逻辑各部分之间的耦合度，提高程序的可重用性\n\n - 一些概念：\n\n    - 横切关注点：不同业务逻辑中共有的部分（日志管理、事务管理）\n\n    - 切面(Aspect)：将横切关注点抽象化为类'),(16,'jwt',11,'2021-12-18 03:40:24','JWT yyds!','![image-20211119151726683](http://cdn.moyusoldier.cloud/image-20211119151726683.png)\n## 1.是什么\n\n一种开放标准，它定义了一种方式，用于在各方之间作为 JSON 对象安全地传输信息。\n\n由于此信息经过数字签名，因此可以验证和信任。JWT 可以使用秘密（使用**HMAC**算法）或使用**RSA**或**ECDSA**的公钥/私钥对进行**签名**。\n\n## 2.能做什么\n\n- **授权**：这是使用 JWT 最常见的场景。用户登录后，每个后续请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是当今广泛使用 JWT 的一项功能，因为它的开销很小，并且能够轻松跨不同域使用。\n- **信息交换**：JSON Web Tokens 是一种在各方之间安全传输信息的好方法。因为 JWT 可以被签名——例如，使用公钥/私钥对——你可以确定发件人就是他们所说的那样。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。\n\n## 3.为什么是JWT\n\n### 3.1传统的session认证方式\n\n- **流程**\n\n1. 用户向服务器发送用户名和密码。 \n2. 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。\n3. 服务器向用户返回一个 session_id，写入用户的 Cookie。\n4. 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。\n5. 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。\n\n- **缺点**\n\n1. 用户增多，session保存在内存中，服务器开销增大\n\n2. 用户下次请求必须在这台服务器上才能授权，限制分布式架构，限制session共享\n\n3. 跨站伪造请求(CSRF)攻击：\n\n   1. 用户Alice登录和访问某银行网站A，保留cookie。\n\n   2. Alice被某些信息诱导访问危险网站B。\n\n   3. 危险网站B上有一个<img>标签：\n\n      ```\n      <img src=\"http://www.examplebank.com/account=Alice&amount=1000&payfor=Badman\" >\n      ```\n\n   4. 这个标签的src不指向一张图片，而是一个http请求，这个请求向银行要求将Alice的1000元转给Badman，由于Alice的浏览器上有cookie，这样浏览器发出的这个请求就能得到响应执行。\n\n   5. 这样Alice的钱就被偷了。\n\n4. 前后端分离系统：通常用户的一次请求多次转发，经过多次代理，多次携带session_id\n\n### 3.2 JWT 认证方式\n\n- **原理**\n\nJWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。\n {\n \"姓名\": \"张三\",\n \"角色\": \"管理员\",\n \"到期时间\": \"2018年7月1日0点0分\"\n }\n 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。\n\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n\n- **认证流程**\n\n![8qwls7hxns](http://cdn.moyusoldier.cloud/8qwls7hxns.png)\n\n1. Browser通过Web表单将username和password发送到Server，一般是一个http post 请求（推荐使用https，避免敏感信息被嗅探）。\n2. Server核对username和password成功后，将用户的id等其他信息作为JWT Payload，将其与头部分别进行Base64编码后签名，形成一个JWT(Token)。形成的JWT是一个形式为\"head.payload.singurater\"的字符串。\n3. Server将JWT字符串作为登陆成功结果返回给Browser，Browser可以将返回的结果保存在localStorage或sessionStorage上，退出登陆时Browser删除保存的JWT即可。\n4. Browser在每次请求时，将JWT放入Http header的Authorization位，解决XSS和XSRF问题。\n5. Server验证JWT有效性，例如检查签名是否正确，检查Token是否过期，检查Token接收方是否是自己（可选）。\n6. 验证通过后，Server使用JWT中包含的用户信息进行其它逻辑操作，返回相应结果。\n\n- **优点**\n\n1. 简洁：可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快\n2. 自包含：负载中包含了所有用户所需要的信息，避免了多次查询数据库\n3. 因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的\n4. 不需要在服务器端保存会话信息，特别适合于分布式微服务\n\n## 4. JWT结构\n\n一个字符串，形式为“xxxxx.yyyyy.zzzzz”，分为三部分：Header、Payload、Signature\n\n### 4.1标头（header)\n\n标头通常由两部分组成：令牌的类型，即 JWT，以及正在使用的签名算法，例如 HMAC SHA256 或 RSA。\n\n例如：\n\n```\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n\n然后，这个 JSON 被**Base64Url**编码以形成 JWT 的第一部分。\n\n### 4.2载荷（payload)\n\n令牌的第二部分是负载，其中包含声明。\n\n声明是关于实体（通常是用户）和附加数据的声明。\n\n共有三种类型的声明：*注册声明*、*公共*声明和*私人*声明。\n\n- [**注册声明**]：这些是一组预定义的声明，这些声明不是强制性的，而是推荐的，以提供一组有用的、可互操作的声明。其中一些是： **iss**（发行者）、 **exp**（到期时间）、 **sub**（主题）、 **aud**（受众）等。\n\n  > 请注意，声明名称只有三个字符，因为 JWT 是紧凑的。\n\n- [**公共声明**]：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在[IANA JSON Web Token Registry]中定义，或者定义为包含抗冲突命名空间的 URI。\n\n- [**私人权利**]：这些都是使用它们同意并既不是当事人之间建立共享信息的自定义声明注册或公众的权利要求。\n\n一个示例有效载荷可能是：\n\n```\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n然后对有效负载进行**Base64Url**编码以形成 JSON Web 令牌的第二部分。\n\n> 请注意，对于已签名的令牌，此信息虽然受到防篡改保护，但任何人都可以读取。除非加密，否则不要将机密信息放入 JWT 的负载或标头元素中。(即密码不能放在JWT中！！！)\n\n### 4.3签名（signature)\n\n前两部分是使用**Base64Url**进行编码的，即任何人可以解开知道里面的信息。\n\n要创建签名部分，需要使用base64编码的header和payload、secret、header中指定的算法，对其进行签名。\n\n例如，如果要使用 HMAC SHA256 算法，则签名将通过以下方式创建：\n\n```\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```\n\n签名用于验证消息在此过程中没有更改，并且在使用私钥签名的令牌的情况下，它还可以验证 JWT 的发送者是它所说的那个人。\n\n### 4.4 放在一起\n\n输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递，同时与基于 XML 的标准（如 SAML）相比更加紧凑。\n\n![image-20211120140613842](http://cdn.moyusoldier.cloud/image-20211120140613842.png)\n\n### 4.5 理解\n\n- JWT是干啥的？\n\n​	用户认证，由于http协议是无状态的，每一次请求都无状态。当一个用户通过用户名和密码登录了之后，他的下一个请求不会携带任何状态，应用程序无法知道他的身份，那就必须重新认证。因此我们希望用户登录成功之后的每一次http请求，都能够保存他的登录状态。\n\n- 为什么要Base64编码？\n\n​	编码了总比明文传输安全？由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据，带来了安全性问题。而session的信息是存在服务端的，相对来说更安全。\n\n- 为什么要Sha256编码\n\n​	header部分和payload部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的signature部分，服务端也就无法通过，在jwt中，消息体是透明的，使用签名可以保证消息不被篡改。\n\n- secret是啥？\n\n​	secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。\n\n- 服务器端如何验证的？\n\n​	Sha256加密jwt的第一部分、第二部分和secret，比较和jwt的第三部分是否相等。'),(19,'solaris环境配置与Pip&Conda包管理',6,'2021-12-19 01:01:55','记录难安装的solaris（其实多安几次就好了）','## 1.Windows环境下solaris环境配置\n\n1. 创建虚拟环境 conda create -n solaris python=3.7\n2. conda install tensorflow==1.13.1（之后在requirements.txt里安装应该也行）\n3. 下载好5个whl文件，依次 pip install pyproj(2.4.2) shapely(1.6.4) gdal(3.0.3) fiona(1.8.13) geopandas(0.6.2)\n4. conda install rasterio\n5. git clone https://github.com/cosmiq/solaris.git  修改requirements.txt 注释掉已经下载好的依赖后pip install -r requirements.txt\n6. 注释掉setup.py的GDAL检测部分（38-55行）后，pip install . 安装solaris \n\n## 2.Linux环境下solaris环境配置\n\n只需把步骤3的包全部用conda安装即可\n\n## 2.Pip&Conda包管理\n\n### 包安装路径\n\n|                   | base                                                    | solaris虚拟环境                                              |\n| ----------------- | ------------------------------------------------------- | ------------------------------------------------------------ |\n| pip/conda install | D:\\conda\\conda\\Lib\\site-packages 和 D:\\conda\\conda\\pkgs | D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages 和 D:\\conda\\conda\\pkgs |\n\n也就是说，conda会在同一个路径下备份所有由pip/conda安装的包。\n\n特例：\n\n​	使用pip install xxx.whl 安装的包，只会在D:\\conda\\conda\\Lib\\site-packages或D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages中，不会在conda路径下。\n\n### list展示路径（环境中可用的包路径）\n\n|                | base                             | solaris                                       |\n| -------------- | -------------------------------- | --------------------------------------------- |\n| pip/conda list | D:\\conda\\conda\\Lib\\site-packages | D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages |\n\n## 3.实验部分（可以不看）\n\n### base环境\n\n#### (base)pip list\n\n```\nC:\\Users\\Lenovo>pip list\nPackage                Version\n---------------------- ---------\nbrotlipy               0.7.0\ncertifi                2021.10.8\ncffi                   1.14.6\ncharset-normalizer     2.0.4\nconda                  4.10.3\nconda-package-handling 1.7.3\ncryptography           35.0.0\nidna                   3.2\nmenuinst               1.4.16\npip                    21.2.4\npycosat                0.6.3\npycparser              2.20\npyOpenSSL              21.0.0\nPySocks                1.7.1\npywin32                228\nrequests               2.26.0\nruamel-yaml-conda      0.15.100\nsetuptools             58.0.4\nsix                    1.16.0\ntqdm                   4.62.3\n```\n\npip list 路径 D:\\conda\\conda\\Lib\\site-packages\n\n> 请读者自行将D:\\conda\\conda替换成自己的Anaconda或Miniconda安装路径\n\n#### (base)conda list\n\n```\nC:\\Users\\Lenovo>conda list\n# packages in environment at D:\\conda\\conda:\n#\n# Name                    Version                   Build  Channel\nbrotlipy                  0.7.0           py37h2bbff1b_1003\nca-certificates           2021.10.26           haa95532_2\ncertifi                   2021.10.8        py37haa95532_0\ncffi                      1.14.6           py37h2bbff1b_0\ncharset-normalizer        2.0.4              pyhd3eb1b0_0\nconda                     4.10.3           py37haa95532_0\nconda-package-handling    1.7.3            py37h8cc25b3_1\nconsole_shortcut          0.1.1                         4\ncryptography              35.0.0           py37h71e12ea_0\nidna                      3.2                pyhd3eb1b0_0\nmenuinst                  1.4.16           py37he774522_0\nopenssl                   1.1.1l               h2bbff1b_0\npip                       21.2.4           py37haa95532_0\npowershell_shortcut       0.0.1                         3\npycosat                   0.6.3            py37h2bbff1b_0\npycparser                 2.20                       py_2\npyopenssl                 21.0.0             pyhd3eb1b0_1\npysocks                   1.7.1                    py37_1\npython                    3.7.6                h60c2a47_2\npywin32                   228              py37hbaba5e8_1\nrequests                  2.26.0             pyhd3eb1b0_0\nruamel_yaml               0.15.100         py37h2bbff1b_0\nsetuptools                58.0.4           py37haa95532_0\nsix                       1.16.0             pyhd3eb1b0_0\nsqlite                    3.36.0               h2bbff1b_0\ntqdm                      4.62.3             pyhd3eb1b0_1\nurllib3                   1.26.7             pyhd3eb1b0_0\nvc                        14.2                 h21ff451_1\nvs2015_runtime            14.27.29016          h5e58377_2\nwheel                     0.37.0             pyhd3eb1b0_1\nwin_inet_pton             1.1.0            py37haa95532_0\nwincertstore              0.2              py37haa95532_2\nyaml                      0.2.5                he774522_0\n```\n\nconda list 路径 D:\\conda\\conda\\Lib\\site-packages（显示的是D:\\conda\\conda ）\n\n#### 下载一个包看看（其实还下载了一堆依赖包）\n\n```\nconda install anaconda-navigator\n```\n\n```\nC:\\Users\\Lenovo>conda list anaconda-navigator\n# packages in environment at D:\\conda\\conda:\n#\n# Name                    Version                   Build  Channel\nanaconda-navigator        2.1.0            py37haa95532_0\n```\n\n```\nC:\\Users\\Lenovo>pip show anaconda-navigator\nName: anaconda-navigator\nVersion: 2.1.0\nSummary: Anaconda Navigator\nHome-page: UNKNOWN\nAuthor: Continuum Analytics\nAuthor-email:\nLicense: UNKNOWN\nLocation: d:\\conda\\conda\\lib\\site-packages\nRequires:\nRequired-by:\n```\n\nconda install 下载的包，conda（D:\\conda\\conda\\pkgs）和pip（D:\\conda\\conda\\Lib\\site-packages）下都有这个包\n\n### solaris虚拟环境\n\n#### (solaris)pip list\n\n```\n(solaris) C:\\Users\\Lenovo>pip list\nPackage      Version\n------------ ---------\ncertifi      2021.10.8\npip          21.2.4\nsetuptools   58.0.4\nwheel        0.37.0\nwincertstore 0.2\n```\n\npip list路径 D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages\n\n#### (solaris)conda list\n\n```\n(solaris) C:\\Users\\Lenovo>conda list\n# packages in environment at D:\\conda\\conda\\envs\\solaris:\n#\n# Name                    Version                   Build  Channel\nca-certificates           2021.10.26           haa95532_2\ncertifi                   2021.10.8        py37haa95532_0\nopenssl                   1.1.1l               h2bbff1b_0\npip                       21.2.4           py37haa95532_0\npython                    3.7.11               h6244533_0\nsetuptools                58.0.4           py37haa95532_0\nsqlite                    3.36.0               h2bbff1b_0\nvc                        14.2                 h21ff451_1\nvs2015_runtime            14.27.29016          h5e58377_2\nwheel                     0.37.0             pyhd3eb1b0_1\nwincertstore              0.2              py37haa95532_2\n```\n\nconda list路径D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages（显示的是D:\\conda\\conda\\envs\\solaris），和pip list路径是一样的\n\n#### 下载一个包\n\nconda install 的包，conda（D:\\conda\\conda\\pkgs）和pip（D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages）下都有这个包。\n\n（pip install应该也一样）\n\npip 通过whl文件安装的包路径 D:\\conda\\conda\\envs\\solaris\\Lib\\site-packages，而conda（D:\\conda\\conda\\pkgs）路径下没有。'),(20,'Spacenet系列官方博客发布时间线',7,'2021-12-18 11:32:10','好耶','# 宣布获胜者 2020/06/05\n\nhttps://medium.com/the-downlinq/spacenet-6-announcing-the-winners-df817712b515\n\n![1_rw6W3jiNHkU-q81s38ED0A](http://cdn.moyusoldier.cloud/1_rw6W3jiNHkU-q81s38ED0A.png)\n\n<img src=\"http://cdn.moyusoldier.cloud/1_8wEjaqyi7EcY8OwxcZHG4Q.png\" alt=\"1_8wEjaqyi7EcY8OwxcZHG4Q\" style=\"zoom: 50%;\" />\n\n- **EfficientNet**占**主导地位：**前 5 名中的每一个都使用了神经网络的集成，五个中的四个依赖于[新引入的 EfficientNet 的](https://arxiv.org/abs/1905.11946)轻微变体。EfficientNet 在 ImageNet 上实现了最先进的性能，同时明显比其他最先进的卷积神经网络更小、更快。\n- **更低的训练和推理时间：**总的来说，与过去的挑战相比，训练和推理时间都大大减少了。其中一些是由于网络效率的提高，另一方面是因为与之前的一些 SpaceNet 挑战相比，这是一个更小的数据集。**Zbigniewwojna 的**模型在推理方面表现最好，速度最快（在 AWS p3.8xlarge 上约为 5.4 s/km²）。\n- **并非总是需要光学预训练：**五名获胜者中只有两名以任何方式利用 SpaceNet 6 光学数据，而是发现 ImageNet 预训练权重提供了相同的性能提升。SatShipAI 在训练 SAR 之前在 PS-RGB 数据上训练了他们的所有模型，而 Motokimura 在切换到 SAR 之前在 PS-RGBNIR 数据上训练了他的集合的 1/3。\n- **多通道掩码：**使用[多通道掩码来表示建筑物内部、边缘和建筑物之间](https://miro.medium.com/max/1324/1*qePAM_bo6hwzSyOjaekS6g.png)的[接触](https://miro.medium.com/max/1324/1*qePAM_bo6hwzSyOjaekS6g.png)的趋势延续了先前的 SpaceNets，并被五名获胜者中的四名使用。只有 SatShipAI 跳过了多通道方法，而是专注于仅将模型的语义分割输出细化为二元预测。\n- **其他编码：**每个参与者都很快了解到 SAR 数据的收集方向（朝北或朝南）对于提高模型性能至关重要。几位获奖者还对 204 个 SAR 图像条带中的每一个的唯一 ID 进行了编码，并将这些信息也输入到网络中。值得注意的是，网络仍然无法直接从图像中自动学习这些信息。这些方法表明，有时即使是很小的预处理步骤对于提高性能和最小化开销观察的一些固有复杂性也特别有价值。\n\n# 模型性能初探 2020/06/16\n\nhttps://medium.com/the-downlinq/spacenet-6-a-first-look-at-model-performance-9c12c5db2b97\n\nSAR工作原理\n\nhttps://medium.com/the-downlinq/sar-101-an-introduction-to-synthetic-aperture-radar-2f0b6246c4a0\n\nhttps://medium.com/the-downlinq/sar-201-an-introduction-to-synthetic-aperture-radar-part-2-895beb0b4c0a\n\n<img src=\"http://cdn.moyusoldier.cloud/1_gAR5XkunyTUF0MH3DwdRAg.png\" alt=\"1_gAR5XkunyTUF0MH3DwdRAg\" style=\"zoom: 25%;\" />\n\n<img src=\"http://cdn.moyusoldier.cloud/1_BMuNqGIWr8NT-VcfhZN6UQ.png\" alt=\"1_BMuNqGIWr8NT-VcfhZN6UQ\" style=\"zoom:25%;\" />\n\n**任何小于 40 平方米的结构都无法识别。**\n\n# 探索大规模基础测绘 2020/07/01\n\nhttps://medium.com/the-downlinq/spacenet-6-exploring-foundational-mapping-at-scale-d0c5a2def123\n\n![1_abGjyhpYbDR9JPGDXNiLfw](http://cdn.moyusoldier.cloud/1_abGjyhpYbDR9JPGDXNiLfw.png)\n\n<img src=\"http://cdn.moyusoldier.cloud/1_GQSzKwe0XqV3lUOkrVwS4g.png\" alt=\"1_GQSzKwe0XqV3lUOkrVwS4g\" style=\"zoom: 50%;\" />\n\n<img src=\"http://cdn.moyusoldier.cloud/1_vLZacRyL5bCyMcVqtbsA2A.png\" alt=\"1_vLZacRyL5bCyMcVqtbsA2A\" style=\"zoom:25%;\" />\n\n# 数据融合和着色 2020/07/23\n\nhttps://medium.com/the-downlinq/spacenet-6-data-fusion-and-colorization-38a77cc4fb74\n\n![1__JkIWCS_ajJ-AFIDhAqQyg](http://cdn.moyusoldier.cloud/1__JkIWCS_ajJ-AFIDhAqQyg.png)\n\n总的来说，这些结果相当令人失望，但从这个工作流程中可以学到一些很好的经验教训。这里的主要内容是 SAR 和 RGB 融合是值得做的——它比仅使用 SAR SPAN 提供了 55% 的性能提升。此外，对于该任务，使用 SAR SPAN 的性能仅略低于使用所有 4 种极化（39.5 对 42.4）。不幸的是，用深度学习方法重新创建这个数据融合过程是相当困难的。\n\n- 结论\n\n这篇博客标志着我们的后 SpaceNet 6 分析系列的结束。我们一路上学到了很多东西，包括：\n\n1. [EfficentNet 在竞争中脱颖而出。](https://medium.com/the-downlinq/spacenet-6-announcing-the-winners-df817712b515)\n2. [建筑高度和大小对模型性能有什么影响？](https://medium.com/the-downlinq/spacenet-6-a-first-look-at-model-performance-9c12c5db2b97)—在处理 SAR 数据时**，高大、矮小或小型**建筑物可能非常具有挑战性。\n3. [模型在城市尺度上的表现如何？](https://medium.com/the-downlinq/spacenet-6-exploring-foundational-mapping-at-scale-d0c5a2def123)—**比单个瓷砖好 20%。**\n4. [需要多少次 SAR 重访才能最大化提取建筑物等静态对象的模型性能？](https://medium.com/the-downlinq/spacenet-6-exploring-foundational-mapping-at-scale-d0c5a2def123)——**四个。**\n5. RGB 和 SAR 融合是否可以帮助您检测建筑物？——**当然。**\n6. 我是否应该训练一个网络来对 SAR 数据进行着色并将其应用于缺乏光学图像的区域？——**你应该试试**。我们的结果非常初步，缺乏最大化性能所需的严谨性。\n\n# 获奖模型发布 2020/07/30\n\nhttps://medium.com/the-downlinq/spacenet-6-winning-model-release-a8ce702d482a\n\n模型：https://github.com/SpaceNetChallenge/SpaceNet_SAR_Buildings_Solutions\n\n权重：s3://spacenet-dataset/spacenet-model-weights/spacenet-6/\n\n# 扩展数据集发布 2020/09/23'),(21,'如何更好的使用光学图像提升模型效果？',12,'2021-12-19 04:49:22','探索探索ing','## 论文及baseline\n\n方法：\n\n​	模型首先在光学图像（RGB）上进行训练，然后将该过程得到的最终权重用作SAR训练的初始权重。\n\n结论：\n\n​	\n\n![spacenet6-baseline-performance](http://cdn.moyusoldier.cloud/spacenet6-baseline-performance.png)\n\n> Table: Baseline 模型表现，使用Optical+SAR得到的F1为0.21，仅使用SAR（经过一致性旋转，尊重其方向性）使得到的F1为0.14.\n\n**用光学图像做迁移学习确实会提升baseline上的 F1Score**\n\n## 获奖模型\n\n链接：[https://medium.com/the-downlinq/spacenet-6-announcing-the-winners-df817712b515](https://medium.com/the-downlinq/spacenet-6-announcing-the-winners-df817712b515)\n\n![1_rw6W3jiNHkU-q81s38ED0A](http://cdn.moyusoldier.cloud/1_rw6W3jiNHkU-q81s38ED0A.png)\n\n![img](http://cdn.moyusoldier.cloud/1_8wEjaqyi7EcY8OwxcZHG4Q.png)\n\n结论：\n\n​	**并非总是需要光学预训练**：五名获胜者中只有两名以任何方式利用 SpaceNet 6 光学数据，而是发现 ImageNet 预训练权重提供了相同的性能提升。SatShipAI 在训练 SAR 之前在 PS-RGB 数据上训练了他们的所有模型，而 Motokimura 在切换到 SAR 之前在 PS-RGBNIR 数据上训练了他的集合的 1/3\n\n## 数据融合和着色（官方发布的赛后总结）\n\n链接：[https://medium.com/the-downlinq/spacenet-6-data-fusion-and-colorization-38a77cc4fb74](https://medium.com/the-downlinq/spacenet-6-data-fusion-and-colorization-38a77cc4fb74)\n\n### 方法1：将SAR图像转换为光学图像\n\n结论：效果平平无奇，并且模型输出不连贯。我们得出的结论是，将 SAR 数据转换为与光学数据几乎相同似乎在如此高分辨率下相当具有挑战性，并且可能不是一个可行的解决方案。\n\n### 方法2：对SAR进行着色\n\n#### 具体流程：\n\n一、SAR与光数据融合：使用色调饱和度值 (HSV)图像融合技术融合SAR 和 RGB 光学图像\n\n二、训练着色网络：\n\n​	Pix2Pix生成对抗网络（GAN）\n\n​	输入：SAR SPAN（单通道）\n\n​	输出：Pix2Pix colorized SAR \n\n​	标签：Fused RGB-SAR\n\n三、创建彩色输出\n\n#### 结论：\n\n​	                            ![1__JkIWCS_ajJ-AFIDhAqQyg](http://cdn.moyusoldier.cloud/1__JkIWCS_ajJ-AFIDhAqQyg.png)  \n\n>  Table:     不同模型输入到SpaceNet6冠军模型的表现\n>\n> 第一行：如果知道SAR对应的RGB图像，就能达到这种效果，但实际上我们只知道SAR图像\n>\n> 第二行：只知道SAR图像，并且把SAR转换成单通道\n>\n> 第三行：只知道SAR图像，并且使用pix2pix对SAR进行着色\n>\n> （注：冠军模型：只知道SAR图像，并且使用SAR图像，Overall Score=42.4）\n\n​	\n\n​	总的来说，这些结果**相当令人失望**，但从这个工作流程中可以学到一些很好的经验教训。\n\n​	这里的主要内容是 SAR 和 RGB 融合是值得做的——它比仅使用 SAR SPAN 提供了 55% 的性能提升。此外，对于该任务，使用 SAR SPAN 的性能仅略低于使用所有 4 种极化（39.5 对 42.4）。\n\n​	不幸的是，用深度学习方法重新创建这个数据融合过程是相当困难的。我们发现 GAN 倾向于对事物进行不一致的着色，并且会留下混淆我们分割模型的伪影。此外，我们还尝试使用 CycleGAN 来完成域自适应方法和其他 SAR 输入，但结果同样非常糟糕。总的来说，我们采取了最直接的方法，对现有的 Pix2Pix 模型架构几乎没有做任何修改。**额外的训练数据、不同的输入或色彩空间、修改后的数据加载器和定制的网络可能是改善这些结果和推进研究的基线要求。**\n\n论文链接：\n\n[https://arxiv.org/abs/1802.10036](https://arxiv.org/abs/1802.10036) Generating High Quality Visible Images from SAR Images Using CNNs 【使用Pix2Pix进行着色】 \n\n[https://phillipi.github.io/pix2pix/](https://phillipi.github.io/pix2pix/)  Image-to-Image Translation with Conditional Adversarial Networks 【抑制斑点噪声+GAN着色】'),(23,'J2EE复习大纲',0,'2021-12-19 15:24:23','J2EE笔记1','# 1.Servlet部分\n\n## javax.Servlet\n\n### Servlet\n\n>destroy\n>\n>getServletConfig\n>\n>getServletInfo\n>\n>init\n>\n>service\n\n- 生命周期\n\n  1. 加载类：当容器启动或首次请求某个 Servlet 时，容器会读取 web.xml 或 @WebServlet 中的配置信息，对指定的 Servlet 进行加载。\n  2. 实例化：加载成功后，容器会通过反射对 Servlet 进行实例化。\n  3. 初始化：\n     - Servlet 容器调用 init() 方法初始化 Servlet 实例。\n     - 初始化的目的：让 Servlet 实例在处理请求之前完成一些初始化工作，例如建立数据库连接，获取配置信息等。\n     - 在 Servlet 的整个生命周期内，init() 方法只能被调用一次。\n     - 初始化期间，Servlet 实例可以通过 ServletConfig 对象获取在 web.xml 或者 @WebServlet 中配置的初始化参数。\n  4. 请求处理：\n     - 运行时阶段是 Servlet 生命周期中最重要的阶段。Servlet 容器接收到来自客户端请求时，容器会针对该请求分别创建一个 ServletRequst 对象和 ServletResponse 对象，将它们以参数的形式传入 service() 方法内，并调用该方法对请求进行处理。\n     - 这里需要注意的是，执行 service() 方法前，init() 方法必须已成功执行。\n     - 在 service() 方法中，Servlet 通过 ServletRequst 对象获取客户端的相关信息和请求信息。在请求处理完成后，通过 ServletResponse 对象将响应信息进行包装，返回给客户端。当 Servlet 容器将响应信息返回给客户端后，ServletRequst 对象与 ServletResponse 对象就会被销毁。\n     - 在 Servlet 的整个生命周期内，对于 Servlet 的每一次请求，Servlet 容器都会调用一次 service() 方法，并创建新的 ServletRequest 和 ServletResponse 对象。即 service() 方法在 Servlet 的整个生命周期中会被调用多次。\n  5. 销毁：\n     - 当 Servlet 容器关闭、重启或移除 Servlet 实例时，容器就会调用 destory() 方法，释放该实例使用的资源，例如：关闭数据库连接，关闭文件的输入流和输出流等，随后该实例被 Java 的垃圾收集器所回收。\n     - 对于每个 Servlet 实例来说，destory() 方法只能被调用一次。\n\n\n\n### ServletConfig\n\n>getInitParameter\n>\n>getInitParameterNames\n>\n>getServletContext\n>\n>getServletName\n\n### ServletContext\n\n`ServletContext` 对象包含在 [`ServletConfig`](../javax.servlet.ServletConfig.html) 对象中，[`ServletConfig`](../javax.servlet.ServletConfig.html) 对象在初始化  servlet 时由 Web 服务器提供给 servlet\n\n### ServletRequest\n\n### ServletResponse\n\n## javax.servlet.http\n\n### HttpServletRequest\n\n### HttpServletResponse\n\n### HttpSession\n\n### Cookie\n\n### HttpServlet\n\n## javax.servlet.annotation\n\nhttp://c.biancheng.net/servlet/webservlet.html\n\n> HandlesTypes\n> HttpConstraint\n> HttpMethodConstraint\n> MultipartConfig\n> ServletSecurity\n> WebFilter\n> WebInitParam\n> WebListener\n> WebServlet\n## web listeners and web events. \n\n外链笔记\n\n## Filter\n\n### javax.serlvet.Filter\n\nhttp://c.biancheng.net/servlet2/filter.html\n\n### javax.serlvet.FilterChain\n\nhttp://c.biancheng.net/servlet2/filterchain.html\n\n### javax.serlvet.FilterConfig\n\nhttp://c.biancheng.net/servlet2/filterconfig.html\n\n类比ServletConfig接口\n\n>getFilterName\n>\n>getFilterParameter\n>\n>getFilterParameterNames\n>\n>getServletContext\n\n## 请求转发和重定向\n\n### javax.servlet.RequestDispatcher\n\nhttp://c.biancheng.net/servlet2/requestdispatcher.html\n\n请求转发 request.getRequestDispatcher(\"/DoServlet\").forward(request, response);\n\n### javax.servlet.http.HttpServletResponse\n\nhttp://c.biancheng.net/servlet2/redirection.html\n\n重定向 response.sendRedirect(\"/responseDemo/RefreshServlet\");\n\n# 2.JSP部分\n\n外链笔记\n\n# 3.Struts1\n\n外链笔记\n\n# 4.Spring\n\n外链笔记'),(24,'web listeners and web events',0,'2021-12-19 15:25:21','J2EE笔记2','# Listener设计模式-观察者模式\n\n也叫发布-订阅模式，一种一对多关系，B、C、D对象观察A对象，A发生改变时，通知B、C、D 做出相应改变。\n\n# Listener接口\n\n## 介绍\n\n1. 来自Servlet规范中的一组接口（8个）\n2. 专门用来监听域对象生命周期的变化以及域对象共享数据变化情况\n\n## 域对象\n\n1. 在某一个范围内，为Servlet之间提供共享数据的对象	\n\n2. 分类：\n\n   - ServletContext application \n   - HttpSession session\n   - HttpServletRequest request\n\n   注：PageContext pageContext不是域对象 \n\n## 实现步骤\n\n1. 根据监听的目标对象，选择一个合适的监听器接口来实现\n2. 重写监听器接口中监听处理方法\n3. 在web.xml中注册监听器，通知Tomcat\n\n# Servlet监听器\n\n三类八种:\n\n监听三个域对象的创建和销毁的监听器: \n\n* ServletContextListener Event接口中方法为getServletContext\n\n![image-20211108135939379](http://cdn.moyusoldier.cloud/image-20211108135939379.png)\n\n* HttpSessionListener  Event接口中方法为getSession\n\n![image-20211108140051915](http://cdn.moyusoldier.cloud/image-20211108140051915.png)\n\n* ServletRequestListener Event接口中方法为getServletContext&getServletRequest\n\n![image-20211108140025749](http://cdn.moyusoldier.cloud/image-20211108140025749.png)\n\n监听三个域对象的属性变更的监听器(属性添加,移除,替换):\n\n* ServletContextAttributeListener Event接口中方法为getName&getValue\n\n![image-20211108140146322](http://cdn.moyusoldier.cloud/image-20211108140146322.png)\n\n* HttpSessionAttributeListener  Event接口中方法为getName&getValue&getSession\n\n![image-20211108140125024](http://cdn.moyusoldier.cloud/image-20211108140125024.png)\n\n* ServletRequestAttributeListener  Event接口中方法为getName&getValue\n\n![image-20211108140202769](http://cdn.moyusoldier.cloud/image-20211108140202769.png)\n\n监听HttpSession中的JavaBean的状态改变(绑定,解除绑定,钝化,活化)\n\n* HttpSessionBindingListener Event接口中方法为valueBound/valueUnbound\n\n![image-20211108140225671](http://cdn.moyusoldier.cloud/image-20211108140225671.png)\n\n* HttpSessionActivationListene Event接口中方法为getSession\n\n![image-20211108140247456](http://cdn.moyusoldier.cloud/image-20211108140247456.png)\n'),(25,'JSP',0,'2021-12-19 15:26:11','J2EE笔记3','# JSP基础\n\n## 1.语法\n\n- 脚本程序\n\n```jsp\n<%\nout.println(\"Your IP address is \" + request.getRemoteAddr());\n%>\n```\n\n- JSP声明\n\n```jsp\n<%! int i = 0; %> \n<%! int a, b, c; %> \n<%! Circle a = new Circle(2.0); %> \n```\n\n- JSP表达式\n\n```jsp\n<%= (new java.util.Date()).toLocaleString()%>\n```\n\n## 2.指令\n\n- page\n\n```jsp\n<%@ page attribute=\"value\" %>\n```\n\n- include\n\n```jsp\n<%@ include file=\"文件相对 url 地址\" %>\n```\n\n- taglib\n\n```jsp\n<%@ taglib uri=\"uri\" prefix=\"prefixOfTag\" %>\n```\n\n## 3.动作\n\n| 语法            | 描述                                            | Eg.                                                          |\n| :-------------- | :---------------------------------------------- | ------------------------------------------------------------ |\n| jsp:include     | 在页面被请求的时候引入一个文件。                | <jsp:include page=\"相对 URL 地址\" flush=\"true\" />            |\n| jsp:useBean     | 寻找或者实例化一个JavaBean。                    | <jsp:useBean id=\"name\" class=\"package.class\" />              |\n| jsp:setProperty | 设置JavaBean的属性。                            | <jsp:setProperty name=\"myName\" property=\"someProperty\" .../> |\n| jsp:getProperty | 输出某个JavaBean的属性。                        | <jsp:getProperty name=\"myName\" property=\"someProperty\" .../> |\n| jsp:forward     | 把请求转到一个新的页面。                        | <jsp:forward page=\"date.jsp\" />                              |\n| jsp:plugin      | 根据浏览器类型为Java插件生成OBJECT或EMBED标记。 |                                                              |\n| jsp:element     | 定义动态XML元素                                 |                                                              |\n| jsp:attribute   | 设置动态定义的XML元素属性。                     |                                                              |\n| jsp:body        | 设置动态定义的XML元素内容。                     |                                                              |\n| jsp:text        | 在JSP页面和文档中使用写入文本的模板             |                                                              |\n\n> 注：JSP指令<%@ include file=\"\" %>和动作< jsp:include page=\"\">的区别\n>\n> - include 指令 **静态包含，先合成再编译**。包含的文件的内容会原封不动地插入到包含页中使用该指令地位置，将执行结果输出到浏览器中。JSP编译器再对这个合成地文件进行编译最终编译成的文件只有一个。file支持jsp/html\n>\n> - include 动作 **动态包含，先编译再合成**。include动作标识，该标识被执行时，程序会将请求转发到（注意是转发而不是请求重定向）被包含的页面，并将执行结果输出到浏览器中，然后返回包含页继续执行后面的代码。对两个文件分别编译，服务器执行的其实是两个文件。page支持jsp/html/Servlet组件\n\n# EL基础\n\nJSP2.0以上支持EL语言（表达式语言），使编程更容易\n\n假设要输出一个属性\n\n```jsp\n<jsp:useBean id=\"box\" class=\"com.moyu.servlet.Box\" />\n<jsp:setProperty name=\"box\" property=\"perimeter\" value=\"100\"/>\n```\n\n- JSP表达式输出\n\n```jsp\n<%= box.getPerimeter()%>\n```\n\n- jsp:getProperty，JSP动作输出\n\n```jsp\n<jsp:getProperty name=\"box\" property=\"perimeter\"/>\n```\n\n- EL语言输出\n\n```jsp\n${box.perimeter}\n```\n\n支持变量、运算符(div mod eq ne lt gt le ge)\n\n# EL表达式11个隐含对象\n\n- 对比JSP中9个隐含对象，必考config和application的类型\n\n```java\nfinal javax.servlet.http.HttpServletRequest request;\nfinal javax.servlet.http.HttpServletResponse response\nfinal javax.servlet.jsp.PageContext pageContext;\njavax.servlet.http.HttpSession session = null;\nfinal javax.servlet.ServletContext application;\nfinal javax.servlet.ServletConfig config;\njavax.servlet.jsp.JspWriter out = null;\nfinal java.lang.Object page = this;\njavax.lang.Throwable exception;\n```\n\n- EL表达式11个隐含对象：${}里可以出现的变量\n\n| **隐含对象**     | **描述**                                            |\n| :--------------- | :-------------------------------------------------- |\n| pageScope        | page 作用域                                         |\n| requestScope     | request 作用域                                      |\n| sessionScope     | session 作用域                                      |\n| applicationScope | application 作用域                                  |\n| param            | 如同 ServletRequest.getParameter(String name)       |\n| paramValues      | 如同 ServletRequest.getParameterValues(String name) |\n| header           | 如同 ServletRequest.getHeader(String name)          |\n| headerValues     | 如同 ServletRequest.getHeaders(String name)         |\n| initParam        | 如同 ServletContext.getInitParameter(String name)   |\n| cookie           | 如同 HttpServletRequest.getCookies()                |\n| pageContext      | 当前页面的pageContext                               |\n\n- pageContext\n\n  - 唯一一个和JSP中隐含对象pageContext一模一样，两个隐含对象指向同一个对象，是PageContext类型，其余的EL隐含对象全是Map类型\n\n  - 以下方法提供对隐式对象的**便捷访问**：`getException()`、`getPage()`、`getRequest()`、`getResponse()`、`getSession()`、`getServletConfig()`  和 `getServletContext()`。 \n\n    以下方法提供对**转发、包含和错误处理**的支持：`forward()`、`include()` 和  `handlePageException()`\n\n    即门面对象，通过pageContext.getRequest()/getSession()/getServletContext 进而调用它们的serAttribute()/getAttribute()，麻烦，重载提供了方便，重载函数形式为\n\n  ```jsp\n  pageContext.setAttribute(String name, Object value, int scope) \n  //scope的值有四个：\n  //PageContext.PAGE_SCOPE(=1)、PageContext.REQUEST_SCOPE(=2)、PageContext.SESSION_SCOPE(=3)、PageContext.APPLICATION_SCOPE(=4)\n  ```\n\n  几种等价形式：\n\n  ```jsp\n  pageContext.getSession().setAttribute(String name, Object value);\n  //等价于\n  session.setAttribute(String name, Object value);\n  //等价于\n  pageContext.setAttribute(String name, Object value, PageContext.SESSION_SCOPE);\n  ```\n\n- 四大作用域  page<request<session<application \n\n  -  Map<String name, Object value>类型\n\n  - ```jsp\n    <%\n    	pageContext.setAttribute(\"info\",\"page属性范围\");\n    	request.setAttribute(\"info\",\"request属性范围\");\n    	session.setAttribute(\"info\",\"session属性范围\");\n    	application.setAttribute(\"info\",\"application属性范围\");\n    %>\n    \n    ${info}//从最小作用域找，输出为page属性范围\n    ${pageScope.info}//等价于${pageScope[\"info\"]}\n    ${requestScope.info}\n    ${sessionScope.info}\n    ${applicationScope.info}\n    ```\n\n  - 释放数据：invalidate\\timeout\n\n- param\n\n  - Map<String,String>类型\n\n  - 从客户端发送的请求携带的参数，url 问号后数据如何获取？调用HttpServletRequest类getParameter函数\n\n    ```java\n    String getParameter(String var1);\n    ```\n\n- paramValues\n\n  - Map<String, String[]>类型\n\n    ```java\n    String[] getParameterValues(String var1);\n    ```\n\n- initParam（Servlet组件的配置信息）\n\n  - ```java\n    String getInitParameter(String var1);\n    ```\n\n  - Map<String,String>类型，同param\n\n  - GenericServlet类实现了ServletConfig接口，同时又包含一个ServletConfig对象（看源码），则有两种方法获取initParameter\n\n  - ```java\n    //在servlet中\n    getInitParameter();\n    getServletConfig().getInitParameter();\n    //在JSP中\n    <%=config.getInitParameter(\"port\")%>\n    <%=pageContext.getServletConfig().getInitParameter(\"port\")%>\n    <%=getServletConfig().getInitParameter(\"port\")%>\n    ```\n\n- cookie\n  - Map<String, Cookie>类型\n\n存取运算符\n\n	1. 点 对象的属性，map按key取value\n	2. 方括号 括号里是key或者数组下标\n\n## 举例\n\nhttp://localhost:8080/a.jsp?at=1&at=2&at=3 \n\n1.获取at的值？\n\na.jsp\n\n```	jsp\n${paramValues.at[0]} //输出1\n```\n\n2.输出问号后内容\n\n```jsp\n<%=\n    request.getQueryString()\n%>\n```\n\n```jsp\n${pageContext.getRequest().getQueryString()}\n```\n\n牢记pageContext对象，万能对象，有它就有一切\n\ngetQueryString()是哪个接口里的函数？\n\n答：是HttpServletRequest （针对Http协议的派生接口），不是 ServletRequest，\n\n# Tag\n\nhttps://www.runoob.com/jsp/jsp-custom-tags.html\n\n\n### SimpleTag\n\n### Tag\n\n### SimpleTagSupport\n\n### TagSupport'),(26,'struts1',0,'2021-12-19 15:26:59','J2EE笔记4','# 1. 结构\n\n## 1.1 配置文件\n\n### /WEB-INF/struts-config.xml\n\n核心配置文件，ActionForm、Action要使用它，之所以有效，是因为作为<init-param>写在了web.xml中\n\n定义前端控制器form-bean以及后端控制器action-mapping，通过name属性进行对应\n\n```xml\n<struts-config>\n    <form-beans>\n        <form-bean name=\"calcForm\" type=\"com.abc.form.CalcForm\"/>\n    </form-beans>\n    <action-mappings>\n        <action path=\"/calc\" type=\"com.abc.action.CalcAction\" name=\"calcForm\"\n                input=\"/input.jsp\">\n            <forward name=\"result\" path=\"/result.jsp\" redirect=\"false\"/>\n        </action>\n    </action-mappings>\n</struts-config>\n```\n\n### web.xml\n\n文件一定会存在，Servlet要使用它\n\nServlet的处理路径：Struts1.x中的servlet路径是经典的\"*.do\"\n\n```xml\n    <servlet>\n        <servlet-name>action</servlet-name>\n        <servlet-class>org.apache.struts.action.ActionServlet</servlet-class>\n        <init-param>\n            <param-name>config</param-name>\n            <param-value>\n                /WEB-INF/struts-config.xml\n            </param-value>\n        </init-param>\n        <load-on-startup>2</load-on-startup>\n    </servlet>\n\n    <!-- Standard Action Servlet Mapping -->\n    <servlet-mapping>\n        <servlet-name>action</servlet-name>\n        <url-pattern>*.do</url-pattern>\n    </servlet-mapping>\n```\n\n## 1.2 资源文件\n\n在src目录下(最终会输出到WEB-INF/classes下 )的ApplicationResources.properties文件（全局资源文件，被Controller读取）\n\n## 1.3 JSP\n\n在输入组件中定义的property，实际上在最后页面运行的时候，会自动生成id与name两个属性\n\n```html\n<html:form action=\"/calc\">\n    n1: <html:text property=\"n1\"/><br>\n    n2: <html:text property=\"n2\"/><br>\n    <html:submit property=\"submit\" value=\"Add\"/>\n</html:form>\n```\n\n```html\n以下内容\n<html:text property=\"n2\" />\n会生成\n<input type = \"text\" id =\"n2\" name = \"n2\">\n```\n\n注：该请求的URL为http://localhost:8080/calc.do?n1=xx&n2=xx&submit=Add 有<name,value>的param就会在url的parma里出现\n\n## 1.4 Controller\n\n将一个Servlet的Controller变为两个部分：ActionForm与Action，永远成对出现\n\n产生问题：每一个Action都匹配一个ActionForm，结果ActionForm无限多（最大缺点）\n\n### ActionForm(纯数据)\n\nhttps://blog.csdn.net/lovesummerforever/article/details/18951649\n\n服务器端数据验证，保存错误信息，进行跳转（根据input跳转）\n\n继承自ActionForm类，属性都会生成对应的setter/getter\n\n### Action\n\n配置访问路径，也就是表单提交路径\n\n继承自Action类\n\n负责跳转，与Servlet相似（自己决定）\n\n# 2. 工作原理\n\n## 2.1 MVC\n\nStruts 1.x是MVC的最基础实现，请求的处理流程是重中之重。\n\n![image-20211110150955846](http://cdn.moyusoldier.cloud/image-20211110150955846.png)\n\n## 2.2 工作流程\n\n<img src=\"http://cdn.moyusoldier.cloud/struts.gif\" alt=\"img\" style=\"zoom: 150%;\" />\n\n\n\n1. 只要是MVC操作，那么核心流程：JSP提交给Servlet，而后Servlet跳转到指定的JSP页面\n2. Struts支持标签操作，在编写JSP时使用HTML标签生成HTML元素，好处是帮助用户隐藏代码细节，如\n\n```xml\n<html:text property=\"n2\" />\n```\n\n会生成HTML元素，同时也可以自动与ActionForm属性相关联（必须在ActionForm中定义好）\n\n```xml\n<html:form action=\"/calc\" >\n```\n\n由于设置了Action的处理路径，HTML代码在运行之前会默认先调用一次ActionForm的reset()方法表示进行内容的初始化\n\n3. 表单提交时输入的是struts-config.xml里配置的action路径，同时后面要加上*.do，因为在Struts里面所有的处理提交都是先提交给一个ActionServlet的，在web.xml中定义了\n\n   ```xml\n   <servlet>\n       <servlet-name>action</servlet-name>\n       <servlet-class>org.apache.struts.action.ActionServlet</servlet-class>\n       <init-param>\n         <param-name>config</param-name>\n         <param-value>\n             /WEB-INF/struts-config.xml   \n          </param-value>\n       </init-param>\n       <load-on-startup>2</load-on-startup>\n     </servlet>\n   \n     <!-- Standard Action Servlet Mapping -->\n     <servlet-mapping>\n       <servlet-name>action</servlet-name>\n       <url-pattern>*.do</url-pattern>\n     </servlet-mapping>\n   ```\n\n   之所以struts-config.xml有效，是因为在ActionServlet中要读取此路径中内容，进行SAX解析进行文件的分析。\n\n   这个ActionServlet是在项目加载时默认先执行的，及容器启动时立刻加载struts-config配置文件。\n\n   而这个ActionServlet也可以作为请求的处理，处理的时候只需要处理的后缀为.do就可以找到这个处理的Servlet。\n\n4. 当ActionServlet接收到用户请求之后，会自动的将请求处理的路径与指定的ActionForm关联，利用反射动态设置ActionForm类对象中的属性，调用setter方法，提交的路径是在Action上配置的，而Action与ActionForm在struts-config.xml中关联\n\n   ```xml\n   <form-beans>\n       <form-bean name=\"calcForm\" type=\"com.abc.form.CalcForm\" />\n   </form-beans>\n   \n   <action-mappings>\n       <action path=\"/calc\" type=\"com.abc.action.CalcAction\" name=\"calcForm\" input=\"/input.jsp\">\n           <forward name=\"result\" name=\"result\" redirect=\"false\" />\n       </action>\n   </action-mappings>\n   ```\n\n5. 当ActionForm里有内容之后，处理错误信息\n\n6. 若错误，将请求给input路径的跳转路径，将请求跳转回指定的页面并且使用<html:errors>标签进行显示\n\n7. 若无错误，继续将处理交给Action完成，Action默认执行execute()，调用业务层方法，而后根据结果跳转到指定的路径。通过ActionMapping类读取struts-config.xml配置信息，并且利用这个类对象的findForward()方法可以设置要读取数据的key的信息，而后要跳转的路径会使用ActionForward类对象包装 ，而后ActionServlet类里面根据接收到的ActionForward里面保存的路径的key(name=\"result\")取出对应的value(name=\"result\")，而后利用RequestDispatcher实现跳转操作。\n\n# 3. DispatchAction&LookupDispatchAction\n\n## 3.1 DispatchAction\n\n- https://blog.csdn.net/lovesummerforever/article/details/18967831\n- 使用场景：an HTML form has multiple submit buttons with the same name 一个表单对应多个提交按钮\n\n```xml\n<!--stuts-config.xml-->\n<action path=\"/saveSubscription\" \n        type=\"org.apache.struts.actions.DispatchAction\" \n        name=\"subscriptionForm\" \n        scope=\"request\" \n        input=\"/subscription.jsp\" \n        parameter=\"method\"/> \n```\n\n```html\n<!--index.jsp-->\n<html:form action=\"/saveSubscription\">\n    <html:submit property=\"method\" value=\"add\"></html:submit>\n    <html:submit property=\"method\" value=\"divide\"></html:submit>\n</html:form>\n```\n\n```java\npublic ActionForward add(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception{\n    \n}\npublic ActionForward delete(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception{\n    \n}\n```\n\nURL为:\n\n  http://localhost:8080/myapp/saveSubscription.do?method=add \n\n  http://localhost:8080/myapp/saveSubscription.do?method=delete\n\n```java\n//DispatchAction.java\npackage org.apache.struts.actions;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.struts.action.ActionForm;\nimport org.apache.struts.action.ActionForward;\nimport org.apache.struts.action.ActionMapping;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport java.util.HashMap;\n\n\npublic abstract class DispatchAction extends BaseAction {\n    \n    protected Class clazz = this.getClass();\n\n    /**\n     * The set of Method objects we have introspected for this class, keyed by\n     * method name.  This collection is populated as different methods are\n     * called, so that introspection needs to occur only once per method\n     * name.\n     我们为该类内省的一组方法对象，以方法名作为键值。 这个集合在调用不同的方法时被填充，因此每个方法名只需要进行一次内省。\n     */\n    protected HashMap methods = new HashMap();\n\n    /** execute函数的参数类型\n     * The set of argument type classes for the reflected method call.  These\n     * are the same for all calls, so calculate them only once.\n     反射方法调用的参数类型类集合。 这些对于所有调用都是相同的，所以只计算一次。  \n     */\n    protected Class[] types =\n        {\n            ActionMapping.class, ActionForm.class, HttpServletRequest.class,\n            HttpServletResponse.class\n        };\n\n    \n    public ActionForward execute(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        if (isCancelled(request)) {\n            ActionForward af = cancelled(mapping, form, request, response);\n\n            if (af != null) {\n                return af;\n            }\n        }\n\n        // Get the parameter. This could be overridden in subclasses.\n        //根据ActionMapping.getParameter()，从定义的struts-config.xml中得到parameter=method\n        String parameter = getParameter(mapping, form, request, response);\n\n        // Get the method\'s name. This could be overridden in subclasses.\n        //根据parameter=method，根据request.getParamater()，得到name=add\n        String name =\n            getMethodName(mapping, form, request, response, parameter);\n\n        // Prevent recursive calls\n        //防止递归调用\n        if (\"execute\".equals(name) || \"perform\".equals(name)) {\n            String message =\n                messages.getMessage(\"dispatch.recursive\", mapping.getPath());\n\n            log.error(message);\n            throw new ServletException(message);\n        }\n\n        // Invoke the named method, and return the result\n        //所有请求先进execute函数，获得name=add,再分配给dispatch函数执行\n        return dispatchMethod(mapping, form, request, response, name);\n    }\n\n    /**\n     * Method which is dispatched to when there is no value for specified\n     * request parameter included in the request.  Subclasses of\n     * <code>DispatchAction</code> should override this method if they wish to\n     * provide default behavior different than throwing a ServletException.\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @param request  The non-HTTP request we are processing\n     * @param response The non-HTTP response we are creating\n     * @return The forward to which control should be transferred, or\n     *         <code>null</code> if the response has been completed.\n     * @throws Exception if the application business logic throws an\n     *                   exception.\n     */\n    protected ActionForward unspecified(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        String message =\n            messages.getMessage(\"dispatch.parameter\", mapping.getPath(),\n                mapping.getParameter());\n\n        log.error(message);\n\n        throw new ServletException(message);\n    }\n\n    /**\n     * Method which is dispatched to when the request is a cancel button\n     * submit. Subclasses of <code>DispatchAction</code> should override this\n     * method if they wish to provide default behavior different than\n     * returning null.\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @param request  The non-HTTP request we are processing\n     * @param response The non-HTTP response we are creating\n     * @return The forward to which control should be transferred, or\n     *         <code>null</code> if the response has been completed.\n     * @throws Exception if the application business logic throws an\n     *                   exception.\n     * @since Struts 1.2.0\n     */\n    protected ActionForward cancelled(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        return null;\n    }\n\n    // ----------------------------------------------------- Protected Methods\n\n    /**\n     * Dispatch to the specified method.\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @param request  The non-HTTP request we are processing\n     * @param response The non-HTTP response we are creating\n     * @param name     The name of the method to invoke\n     * @return The forward to which control should be transferred, or\n     *         <code>null</code> if the response has been completed.\n     * @throws Exception if the application business logic throws an\n     *                   exception.\n     * @since Struts 1.1\n     */\n    protected ActionForward dispatchMethod(ActionMapping mapping,\n        ActionForm form, HttpServletRequest request,\n        HttpServletResponse response, String name)\n        throws Exception {\n        // Make sure we have a valid method name to call.\n        // This may be null if the user hacks the query string.\n        if (name == null) {\n            return this.unspecified(mapping, form, request, response);\n        }\n\n        // Identify the method object to be dispatched to\n        Method method = null;\n\n        //根据函数名name=add，从HashMap methods中得到具体的函数\n        try {\n            method = getMethod(name);\n        } catch (NoSuchMethodException e) {\n            String message =\n                messages.getMessage(\"dispatch.method\", mapping.getPath(), name);\n\n            log.error(message, e);\n\n            String userMsg =\n                messages.getMessage(\"dispatch.method.user\", mapping.getPath());\n            throw new NoSuchMethodException(userMsg);\n        }\n\n        ActionForward forward = null;\n\n        try {\n            Object[] args = { mapping, form, request, response };\n			//执行add函数并返回结果\n            //方法.invoke(对象，参数)\n            forward = (ActionForward) method.invoke(this, args);\n        } catch (ClassCastException e) {\n            String message =\n                messages.getMessage(\"dispatch.return\", mapping.getPath(), name);\n\n            log.error(message, e);\n            throw e;\n        } catch (IllegalAccessException e) {\n            String message =\n                messages.getMessage(\"dispatch.error\", mapping.getPath(), name);\n\n            log.error(message, e);\n            throw e;\n        } catch (InvocationTargetException e) {\n            // Rethrow the target exception if possible so that the\n            // exception handling machinery can deal with it\n            Throwable t = e.getTargetException();\n\n            if (t instanceof Exception) {\n                throw ((Exception) t);\n            } else {\n                String message =\n                    messages.getMessage(\"dispatch.error\", mapping.getPath(),\n                        name);\n\n                log.error(message, e);\n                throw new ServletException(t);\n            }\n        }\n\n        // Return the returned ActionForward instance\n        return (forward);\n    }\n\n    /**\n     * <p>Returns the parameter value.</p>\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @param request  The HTTP request we are processing\n     * @param response The HTTP response we are creating\n     * @return The <code>ActionMapping</code> parameter\'s value\n     * @throws Exception if the parameter is missing.\n     */\n    protected String getParameter(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n\n        // Identify the request parameter containing the method name\n        String parameter = mapping.getParameter();\n\n        if (parameter == null) {\n            String message =\n                messages.getMessage(\"dispatch.handler\", mapping.getPath());\n\n            log.error(message);\n\n            throw new ServletException(message);\n        }\n\n\n        return parameter;\n    }\n\n    /**\n     * Introspect the current class to identify a method of the specified name\n     * that accepts the same parameter types as the <code>execute</code>\n     * method does.\n     *\n     * @param name Name of the method to be introspected\n     * @return The method with the specified name.\n     * @throws NoSuchMethodException if no such method can be found\n     */\n    protected Method getMethod(String name)\n        throws NoSuchMethodException {\n        synchronized (methods) {\n            Method method = (Method) methods.get(name);\n\n            //第一次执行add函数，method中还没有，则将<key=add,value=add函数>放入Hashmap methods中\n            if (method == null) {\n                //反射获得方法，getMethod(方法名，参数类型)\n                method = clazz.getMethod(name, types);\n                methods.put(name, method);\n            }\n\n            return (method);\n        }\n    }\n\n    /**\n     * Returns the method name, given a parameter\'s value.\n     *\n     * @param mapping   The ActionMapping used to select this instance\n     * @param form      The optional ActionForm bean for this request (if\n     *                  any)\n     * @param request   The HTTP request we are processing\n     * @param response  The HTTP response we are creating\n     * @param parameter The <code>ActionMapping</code> parameter\'s name\n     * @return The method\'s name.\n     * @throws Exception if an error occurs.\n     * @since Struts 1.2.0\n     */\n    protected String getMethodName(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response,\n        String parameter) throws Exception {\n        // Identify the method name to be dispatched to.\n        // dispatchMethod() will call unspecified() if name is null\n        return request.getParameter(parameter);\n    }\n}\n\n```\n\n## 3.2 LookupDispatchAction\n\n- LookupDispatchAction是DispatchAction的子类。它们都允许同一个Action根据请求URL中的不同参数执行不同操作（即调用不同的函数）。\n- LookupDispatchAction重写了DispatchAction的getMethodName函数。\n- DispatchAction子类是根据用户请求URL中的参数(button value)，匹配DispatchAction子类中的方法名称来实现的。\n- 而LookupDispatchAction子类的实现是根据URL参数和ApplicationResources.properties找到对应button value，再根据button value和KeyMethodMap找到对应的执行函数。\n- 继承LookupDispatchAction的子类，复写getKeyMethodMap()方法，该方法返回一个Map。而这个Map的key应该和资源属性文件中的键匹配（也就是button value），这个Map的value，应该和LookupDispatchAction子类中的方法名称相匹配。\n\n```xml\n<!--stuts-config.xml-->\n<action path=\"/test\"\n        type=\"org.example.MyAction\"\n        name=\"MyForm\"\n        scope=\"request\"\n        input=\"/test.jsp\"\n        parameter=\"method\"/>\n```\n\n```html\n<!--index.jsp-->\n<html:form action=\"/test\">\n    <html:submit property=\"method\">\n        <bean:message key=\"button.add\"/>\n    </html:submit>\n    <html:submit property=\"method\">\n        <bean:message key=\"button.delete\"/>\n    </html:submit>\n</html:form>\n```\n\n```properties\n# ApplicationResources.properties\nbutton.add=Add Record\nbutton.delete=Delete Record\n```\n\n```java\n    protected Map getKeyMethodMap() {\n        Map map = new HashMap();\n        map.put(\"button.add\", \"add\");\n        map.put(\"button.delete\", \"delete\");\n        return map;\n    }\n  \n    public ActionForward add(ActionMapping mapping,\n            ActionForm form,\n            HttpServletRequest request,\n            HttpServletResponse response)\n            throws IOException, ServletException {\n        // do add\n        return mapping.findForward(\"success\");\n    }\n  \n    public ActionForward delete(ActionMapping mapping,\n            ActionForm form,\n            HttpServletRequest request,\n            HttpServletResponse response)\n            throws IOException, ServletException {\n        // do delete\n        return mapping.findForward(\"success\");\n    }\n```\n\nURL为:\n\nhttp://localhost:8080/test.do?method=add record \n\n其中的add record为button.add在属性文件中对应的属性值，注意URL不区分大小写\n\n流程：Add Record -> button.add ->add\n\n```java\n//LookupDispatchAction.java\npackage org.apache.struts.actions;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.struts.Globals;\nimport org.apache.struts.action.ActionForm;\nimport org.apache.struts.action.ActionForward;\nimport org.apache.struts.action.ActionMapping;\nimport org.apache.struts.config.MessageResourcesConfig;\nimport org.apache.struts.config.ModuleConfig;\nimport org.apache.struts.util.MessageResources;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\n\npublic abstract class LookupDispatchAction extends DispatchAction {\n\n    /**\n     * Commons Logging instance.\n     */\n    private static final Log LOG = LogFactory.getLog(LookupDispatchAction.class);\n\n    /**\n     * Reverse lookup map from resource value to resource key.\n     localeMap中存储<userLocale, lookupMap>\n     lookupMap中存储<\"add Record\",\"button.add\">\n     */\n    protected Map localeMap = new HashMap();\n\n    /**\n     * Resource key to method name lookup.\n     这个就是keyMethodMap,就是自己定义的那个Map，存储<\"button.add\",\"add\">\n     */\n    protected Map keyMethodMap = null;\n\n    // ---------------------------------------------------------- Public Methods\n\n    /**\n     * Process the specified HTTP request, and create the corresponding HTTP\n     * response (or forward to another web component that will create it).\n     * Return an <code>ActionForward</code> instance describing where and how\n     * control should be forwarded, or <code>null</code> if the response has\n     * already been completed.\n     *\n     * @param mapping  The ActionMapping used to select this instance\n     * @param request  The HTTP request we are processing\n     * @param response The HTTP response we are creating\n     * @param form     The optional ActionForm bean for this request (if any)\n     * @return Describes where and how control should be forwarded.\n     * @throws Exception if an error occurs\n     */\n    public ActionForward execute(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response)\n        throws Exception {\n        return super.execute(mapping, form, request, response);\n    }\n\n    /**\n     * This is the first time this Locale is used so build the reverse lookup\n     * Map. Search for message keys in all configured MessageResources for the\n     * current module.\n     *\n     * @param request    The HTTP request we are processing\n     * @param userLocale The locale for this request\n     * @return The reverse lookup map for the specified locale.\n     */\n    private Map initLookupMap(HttpServletRequest request, Locale userLocale) {\n        Map lookupMap = new HashMap();\n\n        this.keyMethodMap = this.getKeyMethodMap();\n\n        ModuleConfig moduleConfig =\n            (ModuleConfig) request.getAttribute(Globals.MODULE_KEY);\n\n        MessageResourcesConfig[] mrc =\n            moduleConfig.findMessageResourcesConfigs();\n\n        // Look through all module\'s MessageResources\n        for (int i = 0; i < mrc.length; i++) {\n            MessageResources resources =\n                this.getResources(request, mrc[i].getKey());\n\n            // Look for key in MessageResources\n            Iterator iter = this.keyMethodMap.keySet().iterator();\n\n            while (iter.hasNext()) {\n                String key = (String) iter.next();\n                String text = resources.getMessage(userLocale, key);\n\n                // Found key and haven\'t added to Map yet, so add the text\n                if ((text != null) && !lookupMap.containsKey(text)) {\n                    lookupMap.put(text, key);\n                }\n            }\n        }\n\n        return lookupMap;\n    }\n\n    /**\n     * Provides the mapping from resource key to method name.\n     *\n     * @return Resource key / method name map.\n     */\n    protected abstract Map getKeyMethodMap();\n\n    /**\n     * Lookup the method name corresponding to the client request\'s locale.\n     *\n     * @param request The HTTP request we are processing\n     * @param keyName The parameter name to use as the properties key\n     * @param mapping The ActionMapping used to select this instance\n     * @return The method\'s localized name.\n     * @throws ServletException if keyName cannot be resolved\n     * @since Struts 1.2.0\n     根据\"Add Record\" 返回\"add\"：\"Add Record\"->\"button.add\",\"button.add\"->\"add\"\n     */\n    protected String getLookupMapName(HttpServletRequest request,\n        String keyName, ActionMapping mapping)\n        throws ServletException {\n        // Based on this request\'s Locale get the lookupMap\n        Map lookupMap = null;\n\n        synchronized (localeMap) {\n            Locale userLocale = this.getLocale(request);\n\n            lookupMap = (Map) this.localeMap.get(userLocale);\n\n            if (lookupMap == null) {\n                lookupMap = this.initLookupMap(request, userLocale);\n                this.localeMap.put(userLocale, lookupMap);\n            }\n        }\n\n        // Find the key for the resource\n        // \"Add Record\"->\"button.add\"\n        String key = (String) lookupMap.get(keyName);\n\n        if (key == null) {\n            String message =\n                messages.getMessage(\"dispatch.resource\", mapping.getPath());\n            LOG.error(message + \" \'\" + keyName + \"\'\");\n            throw new ServletException(message);\n        }\n\n        // Find the method name\n        // \"button.add\"->\"add\"\n        String methodName = (String) keyMethodMap.get(key);\n\n        if (methodName == null) {\n            String message =\n                messages.getMessage(\"dispatch.lookup\", mapping.getPath(), key);\n\n            throw new ServletException(message);\n        }\n\n        return methodName;\n    }\n\n    /**\n     * Returns the method name, given a parameter\'s value.\n     *\n     * @param mapping   The ActionMapping used to select this instance\n     * @param form      The optional ActionForm bean for this request (if\n     *                  any)\n     * @param request   The HTTP request we are processing\n     * @param response  The HTTP response we are creating\n     * @param parameter The <code>ActionMapping</code> parameter\'s name\n     * @return The method\'s name.\n     * @throws Exception if an error occurs\n     * @since Struts 1.2.0\n     */\n    protected String getMethodName(ActionMapping mapping, ActionForm form,\n        HttpServletRequest request, HttpServletResponse response,\n        String parameter) throws Exception {\n        // Identify the method name to be dispatched to.\n        // dispatchMethod() will call unspecified() if name is null\n        String keyName = request.getParameter(parameter);\n\n        if ((keyName == null) || (keyName.length() == 0)) {\n            return null;\n        }\n\n        String methodName = getLookupMapName(request, keyName, mapping);\n\n        return methodName;\n    }\n}\n\n```\n\n\n\n# 4. 页面转发控制 \n\nhttps://blog.csdn.net/lovesummerforever/article/details/19125933'),(27,'Spring',0,'2021-12-19 15:27:49','J2EE笔记5','# spring\n\n1. 理解BeanFactory\n2. 理解ApplicationContext\n3. 理解FileSystemXmlApplicationContext\n4. 理解ClassPathXmlApplicationContext\n5. 理解XmlWebApplicationContext\n6. 理解JavaEE Web Application如何集成Spring框架***\n7. 理解Spring framework的配置。\n\n```xml\n<bean id=\"a\" class=\"a.b.c.Hello\"/>\n<bean name=\"a\" class=\"a.b.c.Hello\"/>\n```\n\n尽量用id属性来标识bean对象，name属性的值可以重复，另外，bean可以有多个名字，例如：\n\n```xml\n<bean name=\"a,b,c\" class=\"a.b.c.Hello\"/>\n```\n\n在独立的Java应用中启动Spring框架：\n\n```java\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class Test {\n	public static void main(String[] args) {\n		ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");	\n		//要知道下面这条语句和上面的语句，二者有何不同？\n		//ApplicationContext ctx = new FileSystemXmlApplicationContext(\"beans.xml\");\n		\n		a.b.c.Hello h1 = (a.b.c.Hello) ctx.getBean(\"a\");\n		a.b.c.Hello h2 = (a.b.c.Hello) ctx.getBean(\"b\");\n		System.out.println(h1 == h2);  //true， 因为是同一个bean对象。		\n	}\n}\n```\n\n```xml\n<bean class=\"a.b.c.Hello\"/>\n```\n\nid, name都没有指定，那么name值默认为和类的全名一致。\n\n```java\na.b.c.Hello h3 = (a.b.c.Hello) ctx.getBean(\"a.b.c.Hello\");\n```\n\n总结一下，尽量使用id来标识bean，id有唯一性的要求。\n\n关于对象的创建，有一些设计模式，例如，工厂方法，对应的spring配置为\n\n```xml\n<bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/>\n```\n\n对应的Java代码\n\n```java\npublic class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n\n    public static ClientService createInstance() {\n        return clientService;\n    }\n}\n```\n\n也可以不指定类型，完全有一个工厂bean来负责创建\n\n```xml\n<!-- the factory bean, which contains a method called createInstance() -->\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n```\n\n上面的bean声明，没有指定类型，该bean的创建有工厂bean的createClientServiceInstance方法来完成。\n\n当然，一个工厂bean可以定义不同的方法来创建不同类型的bean，配置代码和Java代码如下：\n\n```xml\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    <!-- inject any dependencies required by this locator bean -->\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n\n<bean id=\"accountService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createAccountServiceInstance\"/>\n```\n\n```java\npublic class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n    private static AccountService accountService = new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n\n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}\n```\n\n\n上面举例说明了bean的创建，接下来，bean的属性的处理，包括依赖注入（Dependency Injection）\n通过构函数来完成依赖注入\n\n```java\npackage x.y;\n\npublic class ThingOne {\n\n    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\n        // ...\n    }\n}\npublic class ThingTwo {}\npublic class ThingThree {}\n```\n\n```xml\n<beans>\n    <bean id=\"beanOne\" class=\"x.y.ThingOne\">\n        <constructor-arg ref=\"beanTwo\"/>\n        <constructor-arg ref=\"beanThree\"/>\n    </bean>\n\n    <bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\n    <bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\n</beans>\n```\n\n另外一个通过构造函数来写入bean属性的例子\n\n```java\npackage examples;\n\npublic class ExampleBean {\n\n    // Number of years to calculate the Ultimate Answer\n    private int years;\n\n    // The Answer to Life, the Universe, and Everything\n    private String ultimateAnswer;\n\n    public ExampleBean(int years, String ultimateAnswer) {\n        this.years = years;\n        this.ultimateAnswer = ultimateAnswer;\n    }\n}\n```\n\n```xml\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    <constructor-arg type=\"int\" value=\"7500000\"/>\n    <constructor-arg type=\"java.lang.String\" value=\"42\"/>\n</bean>\n```\n\n从上面的两个例子可以看出Spring对构造函数的调用，会自动匹配构造函数的参数类型。\n也可以直接指定参数名字。\n\n```xml \n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    <constructor-arg name=\"years\" value=\"7500000\"/>\n    <constructor-arg name=\"ultimateAnswer\" value=\"42\"/>\n</bean>\n```\n\n下面是通过Setter方法注入依赖。\n\n```xml\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n    <!-- setter injection using the nested ref element -->\n    <property name=\"beanOne\">\n        <ref bean=\"anotherExampleBean\"/>\n    </property>\n\n    <!-- setter injection using the neater ref attribute -->\n    <property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n    <property name=\"integerProperty\" value=\"1\"/>\n</bean>\n\n<bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n<bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\n```\n\n需要注意的是，可以通过ref=\"aBean\"属性来注入依赖，也可以通过<ref bean=\"aBean\"/>子元素来完成注入依赖。\nref是reference的简写，是指某个bean的引用。\n\nJava代码就不提供了，无非就是getter/setter方法。\n\n下面是通过Spring来给应用程序配置一个连接池的代码\n\n```xml\n<bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n    <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb\"/>\n    <property name=\"username\" value=\"root\"/>\n    <property name=\"password\" value=\"asdfasdf\"/>\n</bean>\n```\n\nApplicationContext是组件的容器，得到ApplicationContext对象，就可以通过getBean方法得到Bean，那么在我们的应用程序中，如何得到ApplicationContext对象呢？\n来介绍一个有趣的接口，Aware接口，什么什么Aware接口，Aware这个英语单词，意思是“知道的”，知道什么什么。既然知道，那么就拥有什么什么类型的引用变量，指向那个对象。\n所以：ApplicationContextAware接口中的抽象函数就是	public void setApplicationContext(ApplicationContext applicationContext)  在Web应用程序中，可以通过WebApplicationContextUtils这个类的public static WebApplicationContext getWebApplicationContext(ServletContext sc)获取ApplicationContext对象，不过我们很少调用这个函数，为什么？\n\n在独立的Java应用，可以使用一个全局静态方法来获取ApplicationContext对象。\n\nbean对象的作用域，默认是单例模式，只有一个实例。\n\n```xml\n<!-- the following is equivalent, though redundant (singleton scope is the default) -->\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/>\n```\n\nscope的值可以是singleton, prototype, request, session, application, 以及websocket。\n\n一定要理解singleton和prototype的区别！\n\n最后，使用xml来定义bean是否很麻烦？如果bean的数量特别多，那么在xml文件中声明很麻烦了。\n可以通过注解（Annotation）来简化声明。\n在xml文件中声明使用Java注解\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n对应的Java代码\n\n```java\n@Configuration\npublic class MyConfiguration {\n\n    @Bean\n    public StringStore stringStore() {\n        return new StringStore();\n    }\n\n    @Bean\n    public IntegerStore integerStore() {\n        return new IntegerStore();\n    }\n}\n```\n\n注入依赖， 使用这个注解： @Autowired， Autowired注解可以注解在变量上，也可以注解在Setter方法上。\n构造函数注入依赖\n\n```java\npublic class MovieRecommender {\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n        this.customerPreferenceDao = customerPreferenceDao;\n    }\n	\n}\n```\n\nSetter方法注入依赖\n\n```java\npublic class SimpleMovieLister {\n\n    @Autowired\n    public void setMovieFinder(Optional<MovieFinder> movieFinder) {\n        ...\n    }\n}\n```\n\n再来看另外的Java代码，加载组件\n\n```java\n@Configuration\n@ComponentScan(basePackages = \"org.example\")\npublic class AppConfig  {\n    ...\n}\n```\n\n或者使用xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n	<context:annotation-config/> <!--  annotation-config可以不声明了，因为component-scan会自动打开注解扫描 -->\n    	<context:component-scan base-package=\"org.example\"/>\n\n</beans>\n```\n\n通过base-package指明要扫描的包中的组件类。\n组件类可以通过这些注解来声明：@Component, @Repository, @Service, @Controller\n\n比较一下Java注解来声明bean，和使用xml来声明bean\n\n```java\n@Configuration\npublic class AppConfig {\n\n    @Bean(\"myService\")\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}\n```\n\n```xml\n<beans>\n    <bean id=\"myService\" class=\"com.acme.services.MyServiceImpl\"/>\n</beans>\n```\n\n接下来看看资源文件的处理\n一切资源都使用接口Resource来声明，非常抽象的一个接口，如同BeanFactory, ApplicationContext\n该接口定义在org.springframework.core.io包中，当然也属于spring core(核心包），\n然后该接口有很多派生接口，处理各种不同来源的资源，以及对资源的读写。\n如同其他注入的属性类型，也可以注入Resource，例如给某个bean对象注入Resource属性\n\n```xml\n<property name=\"template\" value=\"classpath:some/resource/path/myTemplate.txt\">\n<property name=\"template\" value=\"file:///some/resource/path/myTemplate.txt\"/>\n```\n\nSpring对配置文件的加载\n\n```xml\n<context:property-placeholder location=\"classpath:jdbc.properties \" />\n```\n\n注意property-placeholderlocation元素只能出现一次，出现多个的话，只加载一个，其余不加载。\n所以，如果想加载多个属性文件（.proeprties）\n可以这样使用：\n\n```xml\n<context:property-placeholderlocation=\"classpath:*.properties\" />\n```\n\n或者\n\n```xml\n<bean id=\"propertyConfigurer\"class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n   <property name=\"locations\">\n	 <list>\n		<value>conf/sqlmap/jdbc.properties</value>\n		<value>conf/config/app.properties</value>\n	</list>\n   </property>\n</bean>\n```\n\n在Java代码中使用，例如注入：\n#app.properties\nabc=123\n\n在Bean中注入\n@Value(\"${abc}\")\nprivate String abc;\n需要开启< context:annotation-config />，通过注解来完成配置。否则@Value不起作用\n@Value可以注解一个属性成员变量，或者Setter方法，或者参数。\n\n在属性文件中使用：\n\n```xml\n<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n    <property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/>\n</bean>\n\n<bean id=\"dataSource\" destroy-method=\"close\"\n        class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/>\n    <property name=\"url\" value=\"${jdbc.url}\"/>\n    <property name=\"username\" value=\"${jdbc.username}\"/>\n    <property name=\"password\" value=\"${jdbc.password}\"/>\n</bean>\n```\n\n# spring-controller\n\nspring框架全面支持mvc设计模式。\n\nspring mvc很灵活。\n\nStruts 1的后端控制器侵入性太强，要求必须继承Action或者Action类的某个派生类。\n\n从请求(HttpServletRequest)中获取参数也使用了类型（ActionForm），所以使用起来需要记住很多类，需要封装。\n\nStrtus2 的后端控制器尽管比较灵活，但是也需要些繁琐的配置文件。后端控制器到路径的映射也是很麻烦。\n\n无论Struts哪个版本，对视图技术（view）的支持都不够强。\n\nspring 前端控制器是org.springframework.web.servlet.DispatcherServlet，导入它很简单，在web.xml中配置\n\n复习一下，web.xml中导入spring framework\n\n```xml\n<web-app>\n	<listener>\n		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n	</listener>\n\n	<context-param>\n		<param-name>contextConfigLocation</param-name>\n		<param-value>/WEB-INF/app-context.xml</param-value>\n	</context-param>\n</web-app>\n```\n\n\nweb.xml中导入前端控制器\n\n```xml\n<!-- 这个子元素必须有，Servlet容器新增加的特性，支持多模块开发 -->\n<absolute-ordering /> \n<servlet>\n	<servlet-name>app</servlet-name>\n	<servlet-class>org.springframework.web.servlet.DispatcherServlet\n	</servlet-class>\n	<init-param>\n		<param-name>contextConfigLocation</param-name>\n		<param-value></param-value>\n	</init-param>\n	<load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n	<servlet-name>app</servlet-name>\n	<url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\nurl-pattern可以写成很多形式，例如*.action, * .do，或者/app/* \n不管是什么形式，只要是访问后端控制器，那么前端控制器一定要映射到。这个url-pattern路径一定要映射到包括所有的后端控制器，当然，除了映射到后端所有的控制器，也可以映射到某些静态资源文件。\n\n先讲一下servlet组件的映射规则\na.html\n/*\n/*.html\n/\n\n如果有四个Servlet，对应的url-pattern是上面的四种形式，那么客户端任何URL，那么执行哪个Servlet?\n大家一定要把这个映射的优先级记下来。\n\n由于tomcat安装文件夹下的子文件夹conf下有一个全局的配置文件web.xml，它提供了几个Servlet组件，也配置了/和*.jsp路径。\n请记住：如果应用的web.xml文件的配置路径和tomcat的web.xml中的路径一致，那么应用程序优先，如果没有配置，那么会继承tomcat的web.xml中的配置。\n\n建议配置成拦截所有资源，但是不包括jsp文件。用户发送过来的任何请求，都视作用户动作，用户动作当然要由控制器来进行处理!!!\n!!!所以前端控制器的url-pattern应该是/，而不是/*\n\n另外，这个前端控制器DispatcherServlet也可以通过init-param加载ApplicationContext的配置文件。\n那么问题来了，ContextLoaderListener和DispatcherServlet都会创建ApplicationContext，前面创建的\n是后面创建的AppicationContext的parent，这个可以调用ApplicationContext的getParent函数获取。\n\n这个真是人为制造麻烦啊！！！\n当然有区别，DispatcherServlet和MVC有关，所以，MVC的组件可以配置在DispatcherServlet对应的配置文件中。\n而ContextLoaderListener尽量是业务逻辑对应的组件。\n不过，还是使用一个ApplicationContext吧！！！\nhttps://blog.csdn.net/zollty/article/details/86137225\n\n```xml\n<web-app>\n\n	<absolute-ordering /> \n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/root-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app1</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/app1-context.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>app1</servlet-name>\n        <url-pattern>/app1/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n\n上面的配置文件也可以，不过，不建议使用。配置文件可以有多个，可以使用*做适配符，也可以使用逗号分隔符。\n\n好了，导入了前端控制器，前端控制器收到客户端发送过来的url，它如何处理呢？\n\n可以把静态资源和后端控制器逻辑分开。例如，在配置文件中声明：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xmlns:p=\"http://www.springframework.org/schema/p\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/mvc\n	    http://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n	\n	<mvc:resources mapping=\"/js/**\" location=\"/WEB-INF/js/\" />\n	<mvc:resources mapping=\"/css/**\" location=\"/WEB-INF/css/\" />\n\n</bean>\n```\n\n上面映射中的**表示支持子文件夹\n\n下面说一下，后端控制器。\nhttps://www.jianshu.com/p/84d85081c65a\nhttps://www.jianshu.com/p/0f981efdfbbd\n\nSpring的后端控制器可以使用xml配置，也可以使用注解来声明。都很简单。\n配置过程比struts1, struts2都容易一些。\n\n使用注解来定义后端控制器非常方便，后端控制器也不需要继承声明。\n\n```java\npakcage com.abc.project.controller;\n\n@Controller\npublic class MyController {\n\n}\n```\n\n在配置文件中开启mvc\n< mvc:annotation-driven />\n\n在配置文件中启动扫描组件，注意是包的名字，别写其他的，也别写适配符*\n<context:component-scan	base-package=\"com.abc.project.controller\" />\n\n那么路径到处理函数的映射？\n\n```java\n@Controller\npublic class MyController {\n	@RequestMapping(\"/calc/add\")\n	public String add(@RequestParam(value=\"v1\") String v1, @RequestParam(value=\"v2\") String v2) {\n	\n	}\n	\n	@RequestMapping(\"/calc/subtract\")\n	public String subtract(@RequestParam(value=\"v1\") String v1, @RequestParam(value=\"v2\") String v2) {\n	\n	}\n}\n```\n\n也可以是这种形式，支持模块开发\n\n```java\n@Controller\n@RequestMapping(\"/calc\")\npublic class MyController {\n	@RequestMapping(\"/add\")\n	public String add(String v1, String v2) {\n	\n	}\n	\n	@RequestMapping(\"/subtract\")\n	public String subtract(String v1, String v2) {\n	\n	}\n}\n```\n\n也支持区分不同的请求方法\n@RequestMapping(value=\"/add\", method = RequestMethod.GET)\n或者直接使用不同的注解\n@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, ...\n	\n后端控制器的函数名称没有任何要求，不过参数当然不能随意的写。\n后端控制器支持的常见参数类型列表\nHttpServletRequest, HttpServletResponse,javax.servlet.http.HttpSession\njava.util.Locale\n@PathVariable\n@RequestParam\n@RequestHeader\n@CookieValue\n@RequestBody\n@RequestPart\n\njava.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap\n\n@ModelAttribute, @SessionAttributes, @SessionAttribute, @RequestAttribute\n\n例如，常用的@RequestParam\n\n```java\npublic String add(@RequestParam(\"v1\") String v1, @RequestParam(\"v2\") String v2)\npublic String add(@RequestParam Map<String, Object> params)\n\npublic String add(@RequestBody Account account)	//直接处理JSON格式的数据，转换为Account对象了。\n                                                //如果是form表单，那么也可以是Map集合。\n```\n\nSpring对路径的支持非常灵活，支持带参数的路径，或者说模板路径\n\n```java\n@RequestMapping(\"/student/{studentid}/modify\");\n//或者下面的声明\n@RequestMapping(\"/student/modify/{studentid}\") \npublic String modify(@PathVariable String studentid) {\n\n}\n//或者下面的声明\n@RequestMapping(\"/student/modify/{studentid}\") \npublic String modify(@PathVariable(\"studentid\") String studentid) {\n\n}\n```\n\n\n\n接下来说一下controller处理函数的返回数据\n1.ModelAndView（重要）\n2.Model\n3.ModelMap\n4.Map\n5.View\n6.String\n7.void			\n8.@ResponseBody Object\n\n7返回void，那么在后端控制器处理函数中，可以直接使用重定向技术，如果没有重定向，那么\n\n6返回String，那么字符串描述的视图的逻辑名字，通过视图解析器解析为物理视图地址。\n例如 return \"index\"; return \"forward:index\"; return \"redirect: index\";\nredirect（resp，慢，session保持，两次web请求）\n和forward(req，快)有何区别？!!!\n\n5直接返回视图。\n\n4返回json数据。\n\n```java\npublic @ResponseBody Map<String, Object> add(@RequestParam String id) {\n Map<String,Object> map = new HashMap<String,Object>();\n map.put(.........);\n ......;\n return map;\n}\n```\n\nSping支持RESTful服务，对4的返回形式，可以更简单！\n\n```java\n//不用@Controller，而使用@RestController\n@RestController\npublic class MyController {\n  @RequestMapping(value=\"/add\", produces = \"application/json; charset=utf-8\")\n  public Map /* 或者其他格式的数据，只要能转JSON就可以*/ add(@RequestBody Student s) {\n\n  }\n  @RequestMapping(\"/retrieve\")\n  public Student retrieve(String id) {\n\n  }\n}\n```\n\n处理JSON编码，有更方便的办法\n\n```xml\n   <mvc:annotation-driven>\n        <mvc:message-converters> \n			<bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n				<constructor-arg value=\"UTF-8\"/>\n			</bean>\n			<bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"/>\n		</mvc:message-converters>\n	</mvc:annotation-driven>\n```\n\nModel, ModelAndView, View以后再说。\n');
/*!40000 ALTER TABLE `t_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_user` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
INSERT INTO `t_user` VALUES (1,'moyu','8a7d290c56f71539a5c79b97c3a23886');
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-12-19 23:29:24
